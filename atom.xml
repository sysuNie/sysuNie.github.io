<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sysuNie</title>
  
  <subtitle>Gotta to change</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-20T13:35:47.707Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JiKang Nie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>findduplicationNoEdit</title>
    <link href="http://yoursite.com/2018/01/20/findduplicationNoEdit/"/>
    <id>http://yoursite.com/2018/01/20/findduplicationNoEdit/</id>
    <published>2018-01-20T13:17:35.000Z</published>
    <updated>2018-01-20T13:35:47.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面试题：不修改数组找出重复的数字"><a href="#面试题：不修改数组找出重复的数字" class="headerlink" title="面试题：不修改数组找出重复的数字"></a>面试题：不修改数组找出重复的数字</h3><p>​        在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或者3。</p><p><strong>思路</strong>：如果没有重复的数字，那么1~n的范围内只有n个数字。有余数组里包含n个数字，所以一定包含了重复的数字。我们把从1~n的数字把中间的数字m分为两部分，前一半为1~m，后一半为m+1~n．如果1~m的数字的数目超过m，那么这一半的区间里一定包含重复数字；否则另外一半m+1~n的区间里一定包含重复的数字。我么可以继续把包含重复的数字的区间一分为二，直到找到一个重复的数字。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* numbers, <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// 参数:</span></div><div class="line"><span class="comment">//        numbers:     一个整数数组</span></div><div class="line"><span class="comment">//        length:      数组的长度</span></div><div class="line"><span class="comment">// 返回值:</span></div><div class="line"><span class="comment">//        正数  - 输入有效，并且数组中存在重复的数字，返回值为重复的数字</span></div><div class="line"><span class="comment">//        负数  - 输入无效，或者数组中没有重复的数字</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDuplication</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> end = length <span class="number">-1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(start &lt;= end)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> middle = ((end - start) &gt;&gt; <span class="number">1</span>) + start;</div><div class="line">        <span class="keyword">int</span> count = countRange(numbers, length, start, middle);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(start == end)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(count &gt; <span class="number">1</span>)</div><div class="line">                <span class="keyword">return</span> start;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>((middle-start+<span class="number">1</span>) &lt; count)</div><div class="line">        &#123;</div><div class="line">            end = middle;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            start = middle+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* numbers, <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(numbers[i]&gt;=start &amp;&amp; numbers[i]&lt;=end)</div><div class="line">            ++count;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ====================测试代码====================</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* testName, <span class="keyword">int</span>* numbers, <span class="keyword">int</span> length, <span class="keyword">int</span>* duplications, <span class="keyword">int</span> dupLength)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> result = getDuplication(numbers, length);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dupLength; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(result == duplications[i])</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; testName &lt;&lt; <span class="string">" passed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; testName &lt;&lt; <span class="string">" FAILED."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 一个重复的数字</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</div><div class="line">    <span class="keyword">int</span> duplications[] = &#123; <span class="number">4</span> &#125;;</div><div class="line">    test(<span class="string">"test1"</span>, numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), duplications, <span class="keyword">sizeof</span>(duplications) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 多个重复的数字</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</div><div class="line">    <span class="keyword">int</span> duplications[] = &#123; <span class="number">2</span>, <span class="number">3</span> &#125;;</div><div class="line">    test(<span class="string">"test2"</span>, numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), duplications, <span class="keyword">sizeof</span>(duplications) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 数组中只有两个数字</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">1</span>, <span class="number">1</span> &#125;;</div><div class="line">    <span class="keyword">int</span> duplications[] = &#123; <span class="number">1</span> &#125;;</div><div class="line">    test(<span class="string">"test3"</span>, numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), duplications, <span class="keyword">sizeof</span>(duplications) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 数组中没有重复的数字</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</div><div class="line">    <span class="keyword">int</span> duplications[] = &#123; <span class="number">1</span> &#125;;</div><div class="line">    test(<span class="string">"test4"</span>, numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), duplications, <span class="keyword">sizeof</span>(duplications) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 无效的输入</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span>* numbers = <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">int</span> duplications[] = &#123; <span class="number">1</span> &#125;;</div><div class="line">    test(<span class="string">"test5"</span>, numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), duplications, <span class="keyword">sizeof</span>(duplications) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    test1();</div><div class="line">    test2();</div><div class="line">    test3();</div><div class="line">    test4();</div><div class="line">    test5();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;面试题：不修改数组找出重复的数字&quot;&gt;&lt;a href=&quot;#面试题：不修改数组找出重复的数字&quot; class=&quot;headerlink&quot; title=&quot;面试题：不修改数组找出重复的数字&quot;&gt;&lt;/a&gt;面试题：不修改数组找出重复的数字&lt;/h3&gt;&lt;p&gt;​        在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或者3。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：如果没有重复的数字，那么1~n的范围内只有n个数字。有余数组里包含n个数字，所以一定包含了重复的数字。我们把从1~n的数字把中间的数字m分为两部分，前一半为1~m，后一半为m+1~n．如果1~m的数字的数目超过m，那么这一半的区间里一定包含重复数字；否则另外一半m+1~n的区间里一定包含重复的数字。我么可以继续把包含重复的数字的区间一分为二，直到找到一个重复的数字。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程，数组" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch</title>
    <link href="http://yoursite.com/2018/01/16/torch/"/>
    <id>http://yoursite.com/2018/01/16/torch/</id>
    <published>2018-01-16T05:57:07.000Z</published>
    <updated>2018-01-19T13:25:49.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Torch"><a href="#Torch" class="headerlink" title="Torch"></a>Torch</h3><p><code>torch</code>包含了多维的数据结构以及基于其上的数学运算。它提供了多种实用工具，具有CUDA对应的实现</p><h2 id="张量-Tensors"><a href="#张量-Tensors" class="headerlink" title="张量 Tensors"></a>张量 Tensors</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.is_tensor(obj)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">b = np.random.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">torch.is_tensor(a)</div><div class="line">Out[<span class="number">1</span>]: <span class="keyword">True</span></div><div class="line">torch.is_tensor(b)</div><div class="line">Out[<span class="number">2</span>]: <span class="keyword">False</span></div></pre></td></tr></table></figure><p>判断是否为张量，如果是pytorch张量，则返回True</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.is_storage(obj)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">x = torch.FloatTensor(a)</div><div class="line">y = x.storage()</div><div class="line">torch.is_storage(x)</div><div class="line">Out[<span class="number">1</span>]: <span class="keyword">False</span></div><div class="line">torch.is_storage(y)</div><div class="line">Out[<span class="number">2</span>]: <span class="keyword">True</span></div></pre></td></tr></table></figure><p>判断是否为pytorch Storage，如何是，则返回True</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.numel(input)-&gt;int</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">torch.numel(a)</div><div class="line">Out[<span class="number">1</span>]: <span class="number">12</span></div></pre></td></tr></table></figure><p>返回<code>input</code> 张量中的元素个数　　参数:  input (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="external">Tensor</a>) – 输入张量</p><h2 id="创建操作-Creation-Ops"><a href="#创建操作-Creation-Ops" class="headerlink" title="创建操作 Creation Ops"></a>创建操作 Creation Ops</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.eye(n, m=<span class="keyword">None</span>, out=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>参数: </p><ul><li><code>n</code> (int) – 行数</li><li><code>m</code> (int, 可选) – 列数.如果为None,则默认为<em>n</em> </li><li><code>out</code>  (Tensor,可选) -  输出张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">torch.eye(<span class="number">3</span>)</div><div class="line">Out[<span class="number">1</span>]: [torch.FloatTensor of size <span class="number">3</span>x3]</div><div class="line">    </div><div class="line">torch.eye(<span class="number">3</span>, m=<span class="number">4</span>)</div><div class="line">torch.eye(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">Out[<span class="number">2</span>]:</div><div class="line"><span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div><div class="line"></div><div class="line">torch.eye(<span class="number">3</span>,<span class="number">3</span>,out=torch.LongTensor())</div><div class="line">Out[<span class="number">3</span>]:[torch.LongTensor of size <span class="number">3</span>x4]</div></pre></td></tr></table></figure><p>返回一个2维张量，对角线数字为1，其它位置为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.from_numpy(ndarray) → Tensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line">torch.from_numpy(x)</div><div class="line">Out[<span class="number">1</span>]: [torch.LongTensor of size <span class="number">3</span>]</div><div class="line">x</div><div class="line">Out[<span class="number">13</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div></pre></td></tr></table></figure><p>将<code>numpy.ndarray</code>转换为<code>Tensor</code>。返回的张量tensor和numpy的ndarray共享一个内存空间。修改一个会导致另外一个也被修改。返回的张量不能调整大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.linspace(start, end, steps=<span class="number">100</span>, ut=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><p>参数: </p><ul><li><code>start</code> (float) – 点集的开始值</li><li><code>end</code> (float) – 点集的最终值</li><li><code>steps</code>  (int) -  在<code>start</code>和<code>end</code>之间的采样数</li><li><code>out (Tensor, 可选的)</code> – 结果张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">torch.linspace(<span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line">  <span class="number">1</span></div><div class="line">  <span class="number">4</span></div><div class="line">  <span class="number">7</span></div><div class="line"> <span class="number">10</span></div><div class="line">[torch.FloatTensor of size <span class="number">4</span>]</div></pre></td></tr></table></figure><p>返回start和end之间长度为<code>steps</code>的一维张量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.ones(*sizes, out=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">m = a.size()</div><div class="line">torch.ones(*m)</div><div class="line">Out[<span class="number">1</span>]:</div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div></pre></td></tr></table></figure><p>返回一个全为1的张量，形状由可变参数<code>sizes</code>定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.randperm(n, out=<span class="keyword">None</span>) → LongTensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">torch.randperm(<span class="number">3</span>)</div><div class="line">Out[<span class="number">25</span>]: </div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">2</span></div><div class="line"> <span class="number">0</span></div><div class="line">[torch.LongTensor of size <span class="number">3</span>]</div></pre></td></tr></table></figure><p>输入参数<code>n</code>，返回一个从<code>0</code> 到<code>n -1</code>的随机整数排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.arange(start, end, step=<span class="number">1</span>, out=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">torch.arange(<span class="number">1</span>, <span class="number">10</span>, step=<span class="number">4</span>)</div><div class="line">Out[<span class="number">27</span>]: </div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">5</span></div><div class="line"> <span class="number">9</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>]</div></pre></td></tr></table></figure><p>返回一个1维张量，长度为floor((end−start)/step),floor代表向下取整。包含从<code>start</code>到<code>end</code>，以<code>step</code>为步长的一组序列值(默认步长为1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.zeros(*sizes, out=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">m = a.size()</div><div class="line">torch.zeros(*m)</div><div class="line">Out[<span class="number">1</span>]:</div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div></pre></td></tr></table></figure><p>返回一个全0的张量，形状由可变参数<code>sizes</code>定义。</p><h2 id="索引-切片-连接-变异操作"><a href="#索引-切片-连接-变异操作" class="headerlink" title="索引,切片,连接,变异操作"></a>索引,切片,连接,变异操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.cat(seq, dim=0, out=None) → Tensor</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>seq</code>（Tensors的序列） - 可以是相同类型的Tensor的任何python序列。</li><li><code>dim</code>（int，可选） - 张量连接的尺寸</li><li><code>out</code>（Tensor，可选） - 输出参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">torch.cat((a, a, a),<span class="number">0</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line">[torch.FloatTensor of size <span class="number">9</span>x4]</div><div class="line"></div><div class="line">torch.cat((a, a, a),<span class="number">1</span>) &amp; torch.cat((a, a, a),<span class="number">-1</span>)</div><div class="line">Out[<span class="number">2</span>]: </div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x12]</div></pre></td></tr></table></figure><p>在给定维度上对输入的张量序列<code>seq</code> 进行连接操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.chunk(tensor, chunks, dim=<span class="number">0</span>)</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>tensor</code> (Tensor) – 待分块的输入张量</li><li><code>chunks</code> (int) – 分块的个数</li><li><code>dim</code>(int) – 沿着此维度进行分块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">b = torch.randn(<span class="number">3</span>,<span class="number">6</span>)</div><div class="line">torch.chunk(b, <span class="number">3</span>, <span class="number">0</span>)</div><div class="line">Out[<span class="number">46</span>]: </div><div class="line">(</div><div class="line"> <span class="number">-1.2120</span>  <span class="number">0.0617</span>  <span class="number">0.2106</span> <span class="number">-0.3776</span> <span class="number">-2.2615</span>  <span class="number">1.2279</span></div><div class="line"> [torch.FloatTensor of size <span class="number">1</span>x6], </div><div class="line">  <span class="number">0.1425</span>  <span class="number">1.3961</span> <span class="number">-0.6864</span>  <span class="number">0.7581</span>  <span class="number">0.5757</span> <span class="number">-0.7915</span></div><div class="line"> [torch.FloatTensor of size <span class="number">1</span>x6], </div><div class="line">  <span class="number">0.5075</span> <span class="number">-1.8589</span> <span class="number">-0.5447</span> <span class="number">-0.6180</span>  <span class="number">0.2896</span>  <span class="number">0.1451</span></div><div class="line"> [torch.FloatTensor of size <span class="number">1</span>x6])</div><div class="line"></div><div class="line">torch.chunk(b, <span class="number">3</span>, <span class="number">1</span>)</div><div class="line">Out[<span class="number">47</span>]: </div><div class="line">(</div><div class="line"> <span class="number">-1.2120</span>  <span class="number">0.0617</span></div><div class="line">  <span class="number">0.1425</span>  <span class="number">1.3961</span></div><div class="line">  <span class="number">0.5075</span> <span class="number">-1.8589</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>x2], </div><div class="line">  <span class="number">0.2106</span> <span class="number">-0.3776</span></div><div class="line"> <span class="number">-0.6864</span>  <span class="number">0.7581</span></div><div class="line"> <span class="number">-0.5447</span> <span class="number">-0.6180</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>x2], </div><div class="line"> <span class="number">-2.2615</span>  <span class="number">1.2279</span></div><div class="line">  <span class="number">0.5757</span> <span class="number">-0.7915</span></div><div class="line">  <span class="number">0.2896</span>  <span class="number">0.1451</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>x2])</div></pre></td></tr></table></figure><p>将张量沿着给定维度分解成的多个块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.gather(input, dim, index, out=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><p>参数： </p><ul><li><code>input</code>(Tensor) - 源张量</li><li><code>dim</code>(int) - 要索引的轴</li><li><code>index</code>(LongTensor) - 要收集的元素的索引</li><li><code>out</code>(Tensor，可选) - 目的张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">x = torch.FloatTensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</div><div class="line">Out[<span class="number">50</span>]: </div><div class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line"> <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line"> <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x3]</div><div class="line"></div><div class="line">torch.gather(x, <span class="number">0</span>, torch.LongTensor([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]))</div><div class="line">Out[<span class="number">58</span>]: </div><div class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x3]</div><div class="line"></div><div class="line">torch.gather(x, <span class="number">1</span>, torch.LongTensor([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]))</div><div class="line">Out[<span class="number">60</span>]: </div><div class="line"> <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span></div><div class="line"> <span class="number">4</span>  <span class="number">4</span>  <span class="number">4</span></div><div class="line"> <span class="number">7</span>  <span class="number">7</span>  <span class="number">7</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x3]</div><div class="line"></div><div class="line">torch.gather(x, <span class="number">0</span>, torch.LongTensor([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]))</div><div class="line">Out[<span class="number">59</span>]: </div><div class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line"> <span class="number">4</span>  <span class="number">2</span>  <span class="number">6</span></div><div class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x3]</div></pre></td></tr></table></figure><p>沿给定轴<code>dim</code>，将输入索引张量<code>index</code>指定位置的值进行聚合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.index_select(input, dim, index, out=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>input</code> (Tensor) – 输入张量</li><li><code>dim</code> (int) – 索引的轴</li><li><code>index</code> (LongTensor) – 包含索引下标的一维张量</li><li><code>out</code> (Tensor, 可选的) – 目标张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">index = torch.LongTensor([<span class="number">0</span>,<span class="number">1</span>])</div><div class="line">torch.index_select(a, <span class="number">0</span>, index)</div><div class="line">Out[<span class="number">66</span>]: </div><div class="line"> <span class="number">0.6552</span>  <span class="number">1.2615</span> <span class="number">-1.8676</span> <span class="number">-1.3015</span></div><div class="line"><span class="number">-0.6448</span> <span class="number">-0.0267</span>  <span class="number">0.6535</span> <span class="number">-0.2193</span></div><div class="line">[torch.FloatTensor of size <span class="number">2</span>x4]</div><div class="line"></div><div class="line">torch.index_select(a, <span class="number">1</span>, index)</div><div class="line">Out[<span class="number">67</span>]: </div><div class="line"> <span class="number">0.6552</span>  <span class="number">1.2615</span></div><div class="line"><span class="number">-0.6448</span> <span class="number">-0.0267</span></div><div class="line"><span class="number">-0.0179</span> <span class="number">-0.2577</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x2]</div></pre></td></tr></table></figure><p>返回一个新的张量，其索引input 张量沿尺寸 dim使用的条目中index这是一个LongTensor。</p><p>返回的Tensor具有与原始Tensor相同数量的尺寸。注意： 返回的张量不与原始张量共享内存空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"> <span class="number">0.6552</span>  <span class="number">1.2615</span> <span class="number">-1.8676</span> <span class="number">-1.3015</span></div><div class="line"><span class="number">-0.6448</span> <span class="number">-0.0267</span>  <span class="number">0.6535</span> <span class="number">-0.2193</span></div><div class="line"><span class="number">-0.0179</span> <span class="number">-0.2577</span>  <span class="number">0.0076</span>  <span class="number">0.2455</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div><div class="line"></div><div class="line">mask = a.ge(<span class="number">0.5</span>)</div><div class="line">a.ge(<span class="number">0.5</span>)</div><div class="line">Out[<span class="number">2</span>]: </div><div class="line"> <span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line"> <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></div><div class="line"> <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">[torch.ByteTensor of size <span class="number">3</span>x4]</div><div class="line"></div><div class="line">torch.masked_select(a, mask)</div><div class="line">Out[<span class="number">3</span>]: </div><div class="line"> <span class="number">0.6552</span></div><div class="line"> <span class="number">1.2615</span></div><div class="line"> <span class="number">0.6535</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>]</div></pre></td></tr></table></figure><p>根据掩码张量<code>mask</code>中的二元值，取输入张量中的指定项( <code>mask</code>为一个 <em>ByteTensor</em>)，将取值返回到一个新的1D张量，张量 <code>mask</code>须跟<code>input</code>张量有相同数量的元素数目，但形状或维度不需要相同。注意： 返回的张量不与原始张量共享内存空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.nonzero(input, out=<span class="keyword">None</span>) → LongTensor</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>input</code> (Tensor) – 源张量</li><li><code>out</code> (LongTensor, 可选的) – 包含索引值的结果张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">b = torch.Tensor([<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>])</div><div class="line">torch.nonzero(b)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"> <span class="number">0</span></div><div class="line"> <span class="number">2</span></div><div class="line"> <span class="number">3</span></div><div class="line">[torch.LongTensor of size <span class="number">3</span>x1]</div></pre></td></tr></table></figure><p>返回一个包含输入<code>input</code>中非零元素索引的张量。输出张量中的每行包含输入中非零元素的索引。</p><p>如果输入<code>input</code>有<code>n</code>维，则输出的索引张量<code>output</code>的形状为 z x n, 这里 z 是输入张量<code>input</code>中所有非零元素的个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.split(tensor, split_size, dim=<span class="number">0</span>)</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>tensor</code>  (Tensor) – 待分割张量</li><li><code>split_size</code>  (int) – 单个分块的形状大小</li><li><code>dim</code>  (int) – 沿着此维进行分割</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">torch.split(a,<span class="number">1</span>,<span class="number">0</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line">(</div><div class="line">  <span class="number">0.6552</span>  <span class="number">1.2615</span> <span class="number">-1.8676</span> <span class="number">-1.3015</span></div><div class="line"> [torch.FloatTensor of size <span class="number">1</span>x4], </div><div class="line"> <span class="number">-0.6448</span> <span class="number">-0.0267</span>  <span class="number">0.6535</span> <span class="number">-0.2193</span></div><div class="line"> [torch.FloatTensor of size <span class="number">1</span>x4], </div><div class="line"> <span class="number">-0.0179</span> <span class="number">-0.2577</span>  <span class="number">0.0076</span>  <span class="number">0.2455</span></div><div class="line"> [torch.FloatTensor of size <span class="number">1</span>x4])</div><div class="line"></div><div class="line">torch.split(a,<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">Out[<span class="number">101</span>]: </div><div class="line">(</div><div class="line">  <span class="number">0.6552</span></div><div class="line"> <span class="number">-0.6448</span></div><div class="line"> <span class="number">-0.0179</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>x1], </div><div class="line">  <span class="number">1.2615</span></div><div class="line"> <span class="number">-0.0267</span></div><div class="line"> <span class="number">-0.2577</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>x1], </div><div class="line"> <span class="number">-1.8676</span></div><div class="line">  <span class="number">0.6535</span></div><div class="line">  <span class="number">0.0076</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>x1], </div><div class="line"> <span class="number">-1.3015</span></div><div class="line"> <span class="number">-0.2193</span></div><div class="line">  <span class="number">0.2455</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>x1])</div></pre></td></tr></table></figure><p>将输入张量分割成相等形状的chunks（如果可分）。 如果沿指定维的张量形状大小不能被<code>split_size</code> 整分， 则最后一个分块会小于其它分块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.squeeze(input, dim=<span class="keyword">None</span>, out=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>参数: </p><ul><li><code>input</code> (Tensor) – 输入张量</li><li><code>dim</code> (int, 可选的) – 如果给定，则<code>input</code>只会在给定维度挤压</li><li><code>out</code> (Tensor, 可选的) – 输出张量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">x = torch.zeros(2, 1, 2, 1, 2)</div><div class="line">torch.squeeze(x)</div><div class="line">Out[1]: </div><div class="line">[torch.FloatTensor of size 2x2x2]</div><div class="line"></div><div class="line">torch.squeeze(x, 0)</div><div class="line">Out[2]: </div><div class="line">[torch.FloatTensor of size 2x1x2x1x2]</div><div class="line"></div><div class="line">torch.squeeze(x,1)</div><div class="line">Out[3]:</div><div class="line">[torch.FloatTensor of size 2x2x1x2]</div></pre></td></tr></table></figure><p>将输入张量形状中的<code>1</code> 去除并返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.unsqueeze(input, dim, out=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>tensor</code> (Tensor) – 输入张量</li><li><code>dim</code> (int)  – 插入维度的索引</li><li><code>out</code> (Tensor, 可选的) – 结果张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">x = torch.FloatTensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</div><div class="line">torch.unsqueeze(x, <span class="number">0</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line">(<span class="number">0</span> ,.,.) = </div><div class="line">  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line">  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line">[torch.FloatTensor of size <span class="number">1</span>x2x3]</div><div class="line"></div><div class="line">torch.unsqueeze(x, <span class="number">1</span>)</div><div class="line">Out[<span class="number">2</span>]: </div><div class="line">(<span class="number">0</span> ,.,.) = </div><div class="line">  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line">(<span class="number">1</span> ,.,.) = </div><div class="line">  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line">[torch.FloatTensor of size <span class="number">2</span>x1x3]</div><div class="line"></div><div class="line">torch.unsqueeze(x, <span class="number">2</span>)</div><div class="line">Out[<span class="number">3</span>]: </div><div class="line">(<span class="number">0</span> ,.,.) = </div><div class="line">  <span class="number">1</span></div><div class="line">  <span class="number">2</span></div><div class="line">  <span class="number">3</span></div><div class="line">(<span class="number">1</span> ,.,.) = </div><div class="line">  <span class="number">4</span></div><div class="line">  <span class="number">5</span></div><div class="line">  <span class="number">6</span></div><div class="line">[torch.FloatTensor of size <span class="number">2</span>x3x1]</div></pre></td></tr></table></figure><p>返回一个新的张量，对输入的制定位置插入维度 1</p><p>如果<code>dim</code>为负，则将会被转化dim+input.dim()+1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.stack(sequence, dim=0)</div></pre></td></tr></table></figure><p>参数: </p><ul><li><code>sequence</code> (Sequence) – 待连接的张量序列</li><li><code>dim</code> (int) – 插入的维度。必须介于 0 与 待连接的张量序列数之间。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">x = torch.FloatTensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</div><div class="line">torch.stack((x, x), <span class="number">0</span>)</div><div class="line">Out[<span class="number">115</span>]: </div><div class="line">(<span class="number">0</span> ,.,.) = </div><div class="line">  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line">  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line">(<span class="number">1</span> ,.,.) = </div><div class="line">  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line">  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line">[torch.FloatTensor of size <span class="number">2</span>x2x3]</div><div class="line"></div><div class="line">torch.stack((x, x), <span class="number">2</span>)</div><div class="line">Out[<span class="number">117</span>]: </div><div class="line">(<span class="number">0</span> ,.,.) = </div><div class="line">  <span class="number">1</span>  <span class="number">1</span></div><div class="line">  <span class="number">2</span>  <span class="number">2</span></div><div class="line">  <span class="number">3</span>  <span class="number">3</span></div><div class="line">(<span class="number">1</span> ,.,.) = </div><div class="line">  <span class="number">4</span>  <span class="number">4</span></div><div class="line">  <span class="number">5</span>  <span class="number">5</span></div><div class="line">  <span class="number">6</span>  <span class="number">6</span></div><div class="line">[torch.FloatTensor of size <span class="number">2</span>x3x2]</div></pre></td></tr></table></figure><p>沿着一个新维度对输入张量序列进行连接。序列中所有的张量都应该为相同形状。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.take(input, indices) → Tensor</div></pre></td></tr></table></figure><p>参数: </p><ul><li><code>input</code> (Tensor) – 输入张量</li><li><code>indices</code>(LongTensor) – 索引到张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">x = torch.FloatTensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</div><div class="line">torch.take(x, torch.LongTensor([<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>]))</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">3</span></div><div class="line"> <span class="number">6</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>]</div></pre></td></tr></table></figure><p>用给定索引处的输入元素返回一个新的张量， 输入张量被看作是一维张量。 结果与指数具有相同形状。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.transpose(input, dim0, dim1, out=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><p>参数: </p><ul><li><code>input</code> (Tensor) – 输入张量</li><li><code>dim0</code> (int) – 转置的第一维</li><li><code>dim1</code>  (int) – 转置的第二维 </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"> <span class="number">0.6552</span>  <span class="number">1.2615</span> <span class="number">-1.8676</span> <span class="number">-1.3015</span></div><div class="line"><span class="number">-0.6448</span> <span class="number">-0.0267</span>  <span class="number">0.6535</span> <span class="number">-0.2193</span></div><div class="line"><span class="number">-0.0179</span> <span class="number">-0.2577</span>  <span class="number">0.0076</span>  <span class="number">0.2455</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div><div class="line"></div><div class="line">torch.transpose(a, <span class="number">0</span>, <span class="number">1</span>)</div><div class="line">Out[<span class="number">2</span>]: </div><div class="line"> <span class="number">0.6552</span> <span class="number">-0.6448</span> <span class="number">-0.0179</span></div><div class="line"> <span class="number">1.2615</span> <span class="number">-0.0267</span> <span class="number">-0.2577</span></div><div class="line"><span class="number">-1.8676</span>  <span class="number">0.6535</span>  <span class="number">0.0076</span></div><div class="line"><span class="number">-1.3015</span> <span class="number">-0.2193</span>  <span class="number">0.2455</span></div><div class="line">[torch.FloatTensor of size <span class="number">4</span>x3]</div></pre></td></tr></table></figure><p>返回输入矩阵<code>input</code>的转置。交换维度<code>dim0</code>和<code>dim1</code>。输出张量与输入张量共享内存，所以改变其中一个会导致另外一个也被修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.unbind(tensor, dim=<span class="number">0</span>)</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>tensor</code> (Tensor) – 输入张量</li><li><code>dim</code> (int) – 删除的维度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">torch.unbind(a, <span class="number">1</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line">(</div><div class="line">  <span class="number">0.6552</span></div><div class="line"> <span class="number">-0.6448</span></div><div class="line"> <span class="number">-0.0179</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>], </div><div class="line">  <span class="number">1.2615</span></div><div class="line"> <span class="number">-0.0267</span></div><div class="line"> <span class="number">-0.2577</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>], </div><div class="line"> <span class="number">-1.8676</span></div><div class="line">  <span class="number">0.6535</span></div><div class="line">  <span class="number">0.0076</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>], </div><div class="line"> <span class="number">-1.3015</span></div><div class="line"> <span class="number">-0.2193</span></div><div class="line">  <span class="number">0.2455</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>])</div><div class="line"></div><div class="line">torch.unbind(a, <span class="number">0</span>)</div><div class="line">Out[<span class="number">2</span>]: </div><div class="line">(</div><div class="line">  <span class="number">0.6552</span></div><div class="line">  <span class="number">1.2615</span></div><div class="line"> <span class="number">-1.8676</span></div><div class="line"> <span class="number">-1.3015</span></div><div class="line"> [torch.FloatTensor of size <span class="number">4</span>], </div><div class="line"> <span class="number">-0.6448</span></div><div class="line"> <span class="number">-0.0267</span></div><div class="line">  <span class="number">0.6535</span></div><div class="line"> <span class="number">-0.2193</span></div><div class="line"> [torch.FloatTensor of size <span class="number">4</span>], </div><div class="line"> <span class="number">-0.0179</span></div><div class="line"> <span class="number">-0.2577</span></div><div class="line">  <span class="number">0.0076</span></div><div class="line">  <span class="number">0.2455</span></div><div class="line"> [torch.FloatTensor of size <span class="number">4</span>])</div></pre></td></tr></table></figure><p>移除指定维后，返回一个元组，包含了沿着指定维切片后的各个切片</p><h2 id="随机抽样-Random-sampling"><a href="#随机抽样-Random-sampling" class="headerlink" title="随机抽样 Random sampling"></a>随机抽样 Random sampling</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.manual_seed(seed)</div></pre></td></tr></table></figure><p>设定生成随机数的种子，并返回一个 _torch.<em>C.Generator</em> 对象.</p><p>参数: seed (int or long) – 种子.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.initial_seed()</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">torch.manual_seed(<span class="number">2</span>)</div><div class="line">Out[<span class="number">1</span>]: &lt;torch._C.Generator at <span class="number">0x7fa4860b2370</span>&gt;</div><div class="line">    </div><div class="line">torch.initial_seed()</div><div class="line">Out[<span class="number">2</span>]: <span class="number">2L</span></div></pre></td></tr></table></figure><p>返回生成随机数的原始种子值（python long）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.get_rng_state()</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">torch.get_rng_state()</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line">   <span class="number">2</span></div><div class="line">   <span class="number">0</span></div><div class="line">   <span class="number">0</span></div><div class="line"> ⋮  </div><div class="line">   <span class="number">0</span></div><div class="line">   <span class="number">0</span></div><div class="line">   <span class="number">0</span></div><div class="line">[torch.ByteTensor of size <span class="number">5048</span>]</div></pre></td></tr></table></figure><p>返回随机生成器状态(<em>ByteTensor</em>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.set_rng_state(new_state)</div></pre></td></tr></table></figure><p>设定随机生成器状态参数:     new_state (torch.ByteTensor) – 期望的状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.bernoulli(input, out=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">b = torch.Tensor(<span class="number">3</span>,<span class="number">4</span>).uniform_(<span class="number">0</span>,<span class="number">1</span>)</div><div class="line">b</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"> <span class="number">0.5596</span>  <span class="number">0.5591</span>  <span class="number">0.0915</span>  <span class="number">0.2100</span></div><div class="line"> <span class="number">0.0072</span>  <span class="number">0.0390</span>  <span class="number">0.9929</span>  <span class="number">0.9131</span></div><div class="line"> <span class="number">0.6186</span>  <span class="number">0.9744</span>  <span class="number">0.3189</span>  <span class="number">0.2148</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div><div class="line"></div><div class="line">torch.bernoulli(b)</div><div class="line">Out[<span class="number">2</span>]: </div><div class="line"> <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line"> <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span></div><div class="line"> <span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div></pre></td></tr></table></figure><p>从伯努利分布中抽取二元随机数(0 或者 1)。输入张量须包含用于抽取上述二元随机值的概率。 因此，输入中的所有值都必须在［0,1］区间，即 ( 0&lt;=input_i&lt;=1 )输出张量的第<em>i</em>个元素值， 将会以输入张量的第<em>i</em>个概率值等于<code>1</code>。返回值将会是与输入相同大小的张量，每个值为0或者1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.multinomial(input, num_samples,replacement=False, out=None) → LongTensor</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>input</code> (Tensor) – 包含概率值的张量</li><li><code>num_samples</code> (int) – 抽取的样本数</li><li><code>replacement</code> (bool, 可选的) – 布尔值，决定是否能重复抽取</li><li><code>out</code> (Tensor, 可选的) – 结果张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">weights = torch.Tensor([<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">1</span>])</div><div class="line">torch.multinomial(weights, <span class="number">4</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">2</span></div><div class="line"> <span class="number">3</span></div><div class="line"> <span class="number">0</span></div><div class="line">[torch.LongTensor of size <span class="number">4</span>]</div><div class="line"></div><div class="line">torch.multinomial(weights, <span class="number">4</span>, replacement=<span class="keyword">True</span>)</div><div class="line">Out[<span class="number">2</span>]: </div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">1</span></div><div class="line">[torch.LongTensor of size <span class="number">4</span>]</div></pre></td></tr></table></figure><p>返回一个张量，每行包含从<code>input</code>相应行中定义的多项分布中抽取的<code>num_samples</code>个样本。 </p><p>当抽取样本时，依次从左到右排列(第一个样本对应第一列)。</p><p>如果输入<code>input</code>是一个向量，输出<code>out</code>也是一个相同长度<code>num_samples</code>的向量。如果输入<code>input</code>是有 (m )行的矩阵，输出<code>out</code>是形如( m * n )的矩阵。</p><p>如果参数<code>replacement</code> 为 <em>True</em>, 则样本抽取可以重复。否则，一个样本在每行不能被重复抽取。</p><p>参数<code>num_samples</code>必须小于<code>input</code>长度(即，<code>input</code>的列数，如果是<code>input</code>是一个矩阵)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.normal(means, std, out=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>means</code>  (Tensor) – 均值</li><li><code>std</code>  (Tensor) – 标准差</li><li><code>out</code>  (Tensor) – 可选的输出张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">torch.normal(means=torch.arange(<span class="number">0</span>, <span class="number">11</span>), std=torch.arange(<span class="number">1</span>, <span class="number">0</span>, <span class="number">-0.1</span>))</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line">  <span class="number">0.3889</span></div><div class="line"> <span class="number">-0.1244</span></div><div class="line">  <span class="number">1.4945</span></div><div class="line">  <span class="number">3.0249</span></div><div class="line">  <span class="number">3.4251</span></div><div class="line">  <span class="number">4.1258</span></div><div class="line">  <span class="number">6.5222</span></div><div class="line">  <span class="number">7.0321</span></div><div class="line">  <span class="number">7.9798</span></div><div class="line">  <span class="number">8.9608</span></div><div class="line"> <span class="number">10.0000</span></div><div class="line">[torch.FloatTensor of size <span class="number">11</span>]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.normal(mean=<span class="number">0.0</span>, std, out=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">torch.normal(mean=<span class="number">0.5</span>, std=torch.arange(<span class="number">1</span>,<span class="number">6</span>))</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"><span class="number">-0.4879</span></div><div class="line"><span class="number">-0.2523</span></div><div class="line"><span class="number">-0.3742</span></div><div class="line"><span class="number">-1.0413</span></div><div class="line"> <span class="number">2.2176</span></div><div class="line">[torch.FloatTensor of size <span class="number">5</span>]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.normal(means, std=<span class="number">1.0</span>, out=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">torch.normal(means=torch.arange(<span class="number">1</span>,<span class="number">6</span>))</div><div class="line">Out[<span class="number">171</span>]: </div><div class="line"> <span class="number">1.9339</span></div><div class="line"> <span class="number">1.5494</span></div><div class="line"> <span class="number">1.9340</span></div><div class="line"> <span class="number">3.5107</span></div><div class="line"> <span class="number">3.8822</span></div><div class="line">[torch.FloatTensor of size <span class="number">5</span>]</div></pre></td></tr></table></figure><p>返回一个张量，包含从给定参数<code>means</code>,<code>std</code>的离散正态分布中抽取随机数。均值<code>means</code>是一个张量，包含每个输出元素相关的正态分布的均值。<code>std</code>是一个张量，包含每个输出元素相关的正态分布的标准差。均值和标准差的形状不须匹配，但每个张量的元素个数须相同。</p><h2 id="序列化-Serialization"><a href="#序列化-Serialization" class="headerlink" title="序列化 Serialization"></a>序列化 Serialization</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.save(obj, f, pickle_module=&lt;module <span class="string">'pickle'</span> <span class="keyword">from</span> <span class="string">'/usr/bin/python2.7/pickle.py'</span>&gt;, pickle_protocol=<span class="number">2</span>)</div></pre></td></tr></table></figure><p>参数：</p><ul><li><code>obj</code> – 保存对象</li><li><code>f</code> － 类文件对象 (返回文件描述符)或一个保存文件名的字符串</li><li><code>pickle_module</code>  – 用于pickling元数据和对象的模块</li><li><code>pickle_protocol</code>  – 指定pickle protocal 可以覆盖默认参数</li></ul><p>保存一个对象到一个硬盘文件上。参见 <a href="http://pytorch.org/docs/0.3.0/notes/serialization.html#recommend-saving-models" target="_blank" rel="external">Recommended approach for saving a model</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.load(f, map_location=<span class="keyword">None</span>, pickle_module=&lt;module <span class="string">'pickle'</span> <span class="keyword">from</span> <span class="string">'/usr/bin/python2.7/pickle.py'</span>&gt;)</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>f</code> – 类文件对象 (返回文件描述符)或一个保存文件名的字符串</li><li><code>map_location</code>  – 一个函数或字典规定如何remap存储位置</li><li><code>pickle_module</code>   – 用于unpickling元数据和对象的模块 (必须匹配序列化文件时的pickle_module )</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>torch.load(<span class="string">'tensors.pt'</span>)</div><div class="line"><span class="comment"># Load all tensors onto the CPU</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>torch.load(<span class="string">'tensors.pt'</span>, map_location=<span class="keyword">lambda</span> storage, loc: storage)</div><div class="line"><span class="comment"># Map tensors from GPU 1 to GPU 0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>torch.load(<span class="string">'tensors.pt'</span>, map_location=&#123;<span class="string">'cuda:1'</span>:<span class="string">'cuda:0'</span>&#125;)</div></pre></td></tr></table></figure><p>从磁盘文件中读取一个通过<code>torch.save()</code>保存的对象。<code>torch.load()</code> 可通过参数<code>map_location</code><br>动态地进行内存重映射，使其能从不动设备中读取文件。一般调用时，需两个参数: storage 和 location tag. 返回不同地址中的storage，或着返回None (此时地址可以通过默认方法进行解析). 如果这个参数是字典的话，意味着其是从文件的地址标记到当前系统的地址标记的映射。默认情况下， location tags中 “cpu”对应host tensors，‘cuda:device_id’ (e.g. ‘cuda:2’) 对应cuda tensors。</p><p>用户可以通过register_package进行扩展，使用自己定义的标记和反序列化方法。</p><h1 id="数学操作Math-operations"><a href="#数学操作Math-operations" class="headerlink" title="数学操作Math operations"></a>数学操作Math operations</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.abs(input, out=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">torch.abs(torch.FloatTensor([<span class="number">-1</span>, <span class="number">2</span>, <span class="number">-3</span>]))</div><div class="line">Out[<span class="number">8</span>]: </div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">2</span></div><div class="line"> <span class="number">3</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>]</div></pre></td></tr></table></figure><p>计算输入张量的每个元素绝对值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.add(input, value, out=None)</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>input</code> (Tensor) – 输入张量</li><li><code>value</code> (Number) – 添加到输入每个元素的数</li><li><code>out</code> (Tensor, 可选的) – 结果张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>, <span class="number">4</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"><span class="number">-0.5815</span> <span class="number">-1.6031</span>  <span class="number">1.9077</span>  <span class="number">0.0478</span></div><div class="line"> <span class="number">2.6821</span>  <span class="number">1.0581</span>  <span class="number">0.0966</span> <span class="number">-0.8499</span></div><div class="line"><span class="number">-0.7623</span>  <span class="number">1.3194</span>  <span class="number">1.4320</span> <span class="number">-0.0202</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div><div class="line"></div><div class="line">torch.add(a, <span class="number">10</span>)</div><div class="line">Out[<span class="number">2</span>]: </div><div class="line">  <span class="number">9.4185</span>   <span class="number">8.3969</span>  <span class="number">11.9077</span>  <span class="number">10.0478</span></div><div class="line"> <span class="number">12.6821</span>  <span class="number">11.0581</span>  <span class="number">10.0966</span>   <span class="number">9.1501</span></div><div class="line">  <span class="number">9.2377</span>  <span class="number">11.3194</span>  <span class="number">11.4320</span>   <span class="number">9.9798</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div></pre></td></tr></table></figure><p>对输入张量<code>input</code>逐元素加上标量值<code>value</code>，并返回结果到一个新的张量<code>out</code>，即 ( out = tensor + value )。如果输入<code>input</code>是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.addcdiv(tensor, value=1, tensor1, tensor2, out=None) → Tensor</div></pre></td></tr></table></figure><p>参数：</p><ul><li>tensor (Tensor) – 张量，对 tensor1 ./ tensor 进行相加</li><li>value (Number, 可选的) –  标量，对 tensor1 ./ tensor2 进行相乘</li><li>tensor1 (Tensor) – 张量，作为被除数(分子)</li><li>tensor2 (Tensor) –张量，作为除数(分母)</li><li>out (Tensor, 可选的) – 输出张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>, <span class="number">4</span>)</div><div class="line">a1 = torch.randn(<span class="number">2</span>, <span class="number">6</span>)</div><div class="line">a2 = torch.randn(<span class="number">6</span>, <span class="number">2</span>)</div><div class="line">torch.addcdiv(a, <span class="number">0.1</span>, a1, a2)</div></pre></td></tr></table></figure><p>对<code>tensor2</code>对<code>tensor1</code>逐元素相除，然后乘以标量值<code>value</code> 并加到<code>tensor</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.addcmul(tensor, value=1, tensor1, tensor2, out=None) → Tensor</div></pre></td></tr></table></figure><p>用<code>tensor2</code>对<code>tensor1</code>逐元素相乘，并对结果乘以标量值<code>value</code>然后加到<code>tensor</code>。张量的形状不需要匹配，但元素数量必须一致。如果输入是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.ceil(input, out=None) → Tensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">b = torch.randn(<span class="number">4</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"><span class="number">-0.4149</span></div><div class="line"> <span class="number">1.1449</span></div><div class="line"><span class="number">-1.3121</span></div><div class="line"> <span class="number">1.4417</span></div><div class="line">[torch.FloatTensor of size <span class="number">4</span>]</div><div class="line"></div><div class="line">torch.ceil(b)</div><div class="line">Out[<span class="number">20</span>]: </div><div class="line"><span class="number">-0</span></div><div class="line"> <span class="number">2</span></div><div class="line"><span class="number">-1</span></div><div class="line"> <span class="number">2</span></div><div class="line">[torch.FloatTensor of size <span class="number">4</span>]</div></pre></td></tr></table></figure><p>对输入<code>input</code>张量每个元素向上取整, 即取不小于每个元素的最小整数，并返回结果到输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.clamp(input, min, max, out=None) → Tensor</div></pre></td></tr></table></figure><p>操作定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      | min, if x_i &lt; min</div><div class="line">y_i = | x_i, if min &lt;= x_i &lt;= max</div><div class="line">      | max, if x_i &gt; max</div></pre></td></tr></table></figure><p>如果输入是FloatTensor or DoubleTensor类型，则参数<code>min</code> <code>max</code> 必须为实数，否则须为整数。</p><p>参数：</p><ul><li>input (Tensor) –  输入张量</li><li>min (Number) – 限制范围下限</li><li>max (Number) – 限制范围上限</li><li>out (Tensor, 可选的) – 输出张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">b = torch.randn(<span class="number">4</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"><span class="number">-0.4149</span></div><div class="line"> <span class="number">1.1449</span></div><div class="line"><span class="number">-1.3121</span></div><div class="line"> <span class="number">1.4417</span></div><div class="line">[torch.FloatTensor of size <span class="number">4</span>]</div><div class="line"></div><div class="line">torch.clamp(b, <span class="number">-1</span>, <span class="number">1</span>)</div><div class="line">Out[<span class="number">22</span>]: </div><div class="line"><span class="number">-0.4149</span></div><div class="line"> <span class="number">1.0000</span></div><div class="line"><span class="number">-1.0000</span></div><div class="line"> <span class="number">1.0000</span></div><div class="line">[torch.FloatTensor of size <span class="number">4</span>]</div></pre></td></tr></table></figure><p>将输入<code>input</code>张量每个元素的夹紧到区间 ([min, max] )，并返回结果到一个新张量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.floor(input, out=None) → Tensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">b = torch.randn(<span class="number">4</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"><span class="number">-0.4149</span></div><div class="line"> <span class="number">1.1449</span></div><div class="line"><span class="number">-1.3121</span></div><div class="line"> <span class="number">1.4417</span></div><div class="line">[torch.FloatTensor of size <span class="number">4</span>]</div><div class="line"></div><div class="line">torch.floor(b)</div><div class="line">Out[<span class="number">24</span>]: </div><div class="line"><span class="number">-1</span></div><div class="line"> <span class="number">1</span></div><div class="line"><span class="number">-2</span></div><div class="line"> <span class="number">1</span></div><div class="line">[torch.FloatTensor of size <span class="number">4</span>]</div></pre></td></tr></table></figure><p>床函数: 返回一个新张量，包含输入<code>input</code>张量每个元素的floor，即不小于元素的最大整数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Torch&quot;&gt;&lt;a href=&quot;#Torch&quot; class=&quot;headerlink&quot; title=&quot;Torch&quot;&gt;&lt;/a&gt;Torch&lt;/h3&gt;&lt;p&gt;&lt;code&gt;torch&lt;/code&gt;包含了多维的数据结构以及基于其上的数学运算。它提供了多种实用工具，具有CUDA对应的实现&lt;/p&gt;
&lt;h2 id=&quot;张量-Tensors&quot;&gt;&lt;a href=&quot;#张量-Tensors&quot; class=&quot;headerlink&quot; title=&quot;张量 Tensors&quot;&gt;&lt;/a&gt;张量 Tensors&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;torch.is_tensor(obj)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;a = torch.randn(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;b = np.random.randn(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;torch.is_tensor(a)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Out[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]: &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;torch.is_tensor(b)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Out[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]: &lt;span class=&quot;keyword&quot;&gt;False&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;判断是否为张量，如果是pytorch张量，则返回True&lt;/p&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源，torch" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90%EF%BC%8Ctorch/"/>
    
  </entry>
  
  <entry>
    <title>cache_model</title>
    <link href="http://yoursite.com/2018/01/15/cache-model/"/>
    <id>http://yoursite.com/2018/01/15/cache-model/</id>
    <published>2018-01-15T10:02:44.000Z</published>
    <updated>2018-01-15T10:13:21.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h3><p>我们提出对神经网络语言模型进行的一个扩展，以使其预测适应最近的历史。我们的模型是内存增强网络的简化版本。它将过去隐藏的激活存储为内存，并通过当前隐藏激活的点积访问它们。这种机制非常有效，可以扩展到非常大的内存大小。我们还在神经网络中使用外部存储器和基于计数的语言模型使用缓存模型之间建立了联系。我们在几个语言模型数据集上进行演示，我们的方法比最近的内存扩展网络性能更好。</p><h3 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h3><p>语言模型是单词序列的概率分布，具有许多应用，如machine translation，speech recognition 或dialogue agents。虽然传统的神经网络语言模型已经在这个领域获得了最先进的性能，但是它们缺乏适应其最近历史的能力，这限制了它们在动态环境中的应用。最近的解决这个问题的方法是用external memory来扩充这些网络。这些模型可能会使用外部存储器来存储新的信息并适应不断变化的环境。</p><p>虽然这些网络在语言建模数据集上取得了很好的结果，但它们在计算上相当昂贵。通常，他们必须学习一个可以参数化的机制来读取或写入存储单元。这可能会限制其可用内存的大小以及可以训练的数据量。在这项工作中，我们提出了一个非常轻量级的选择，它可以共享内存扩展网络的一些特性，特别是随着时间的推移动态调整的能力。通过最小化内存的计算负担，我们可以使用更大的内存并扩展到更大的数据集。我们在实践中观察到，这使我们能够在不同的语言建模任务上超越记忆增强网络的性能。</p><a id="more"></a><p>我们的模型与Kuhn提出的模型有一些相似之处，称为缓存模型。缓存模型存储最近过去的简单表示，通常以unigrams和…的形式存储使用它们进行预测。这种上下文信息是非常容易存储并且可以有效地访问。它也不需要任何训练，可以应用在任何模型之上。这使得这个模型对领域适应尤其有意思。</p><p>我们的主要贡献是提出一个缓存模型的连续版本，称为神经缓存模型，它可以适应任何神经网络语言模型。我们存储最近隐藏的激活并将其用作上下文的表示。并和当前的隐藏激活使用简单的点积操作，结果发现获得料非常丰富的预测。我们的模型不需要训练，可以用于任何预先训练的神经网络。它也可以毫不费力地扩展到数千个存储单元。我们演示了几种语言模型任务和LAMBADA数据集的神经缓存模型的质量。</p><h3 id="LANGUAGE-MODELING"><a href="#LANGUAGE-MODELING" class="headerlink" title="LANGUAGE MODELING"></a>LANGUAGE MODELING</h3><p>语言模型是单词序列的概率分布。令词汇表的大小为$V$。每个单词由在$R^V = K$中的one-hot编码向量表示，对应于其在词汇表中的索引。使用链式规则，分配给一系列单词$x_1,…,x_T$的概率可以被分解为:</p><script type="math/tex; mode=display">p(x_1,...,x_T) = P(x1)P(x_2|x_1)P(x_3|x_2, x_1)· · · P(x_T |x_1 . . . x_{T −1})</script><script type="math/tex; mode=display">=\prod_{t-1}^{T}p(x_t|x_{t-1},...,x_1)</script><p>Language modeling通常被定义为在给定历史的情况下在单词上学习条件概率。这个条件概率传统上是用基于计数统计的非参数模型来近似的，特别是平滑的N-gram模型在实践中取得了良好的表现。参数化模型有最大熵语言模型，前馈网络语言模型或循环神经网络语言模型。特别地，循环神经网络是目前近似这个条件概率最好的解决方案，并在标准语言建模基准上 实现了state-of-the-arts的性能。</p><p><strong>Recurrent networks.</strong> 假设我们有一个向量为$h_t \in R^d$对历史单词$x_t,…,x_1$进行编码，则可以将单词w的条件概率参数化为：</p><script type="math/tex; mode=display">p_{vocab}(w|x_t,...,x_1) \propto exp(h_t^To_w)</script><p>历史向量$h_t$通过递归地应用形式的等式由循环神经网络计算</p><script type="math/tex; mode=display">h_t = \Phi(x_t,h_{t-1})</script><p>其中$\Phi$是一个取决于网络架构的函数。已经提出了几种循环神经网络的架构，例如Elman network，LSTM,GRU。Elman network是最简单的循环神经网络之一，其中：</p><script type="math/tex; mode=display">h_t = \sigma(Lx_t+Rh_{t-1})</script><p>其中$\sigma$是非线性的，例如logistic或tanh函数，$L \in R^{d\times V}$是一个word embedding 矩阵，$R \in R^{d\times d}$是隐藏层矩阵。LSTM架构在语言建模方面尤为有趣我们将读者引用Graves到了解这个架构的细节。</p><p>通过最小化训练数据的负对数似然性来学习循环神经网络语言模型的参数。这个目标函数通常通过使用随机梯度下降算法或Adagrad等变体来最小化。使用截断后向传播时间算法计算梯度。</p><p><strong>Cache model.</strong>一个单词在一个文档出现后，它很有可能再次出现。例如，在维基百科页面上单词$tiger$出现相同名字的频率是2.8％，而整个维基百科的频率是0.0037％。Cache model利用这个简单的观察来通过捕获文档中的远程依赖关系来改进n-gram语言模型。更确切地说，这些模型有一个缓存组件，其中包含近期历史中出现的单词（文档或固定数量的单词）。一个简单的语言模型，比如一个unigram或平滑的bigram模型，被放在缓存中的单词上，并用静态语言模型进行插值（在较大的数据集上进行训练）。这种技术有很多优点。首先，这是使语言模型适应新领域的一种非常有效的方法。其次，这样的模型能够预测不在词汇表中的词（OOV词），在看过一次这些词后。最后，这有助于捕获文档中的远程依赖关系，以便生成更加一致的文本。</p><p>　　　　　　　　　　　<img src="/home/miacher/Pictures/datastructure/cache_model.png" alt="cache_model"></p><p>神经缓存模型将先前的隐藏状态存储在存储器单元中。然后将它们用作key来检索它们相应的单词，即下一个单词。在写作和阅读过程中，存储没有任何转换。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ABSTRACT&quot;&gt;&lt;a href=&quot;#ABSTRACT&quot; class=&quot;headerlink&quot; title=&quot;ABSTRACT&quot;&gt;&lt;/a&gt;ABSTRACT&lt;/h3&gt;&lt;p&gt;我们提出对神经网络语言模型进行的一个扩展，以使其预测适应最近的历史。我们的模型是内存增强网络的简化版本。它将过去隐藏的激活存储为内存，并通过当前隐藏激活的点积访问它们。这种机制非常有效，可以扩展到非常大的内存大小。我们还在神经网络中使用外部存储器和基于计数的语言模型使用缓存模型之间建立了联系。我们在几个语言模型数据集上进行演示，我们的方法比最近的内存扩展网络性能更好。&lt;/p&gt;
&lt;h3 id=&quot;INTRODUCTION&quot;&gt;&lt;a href=&quot;#INTRODUCTION&quot; class=&quot;headerlink&quot; title=&quot;INTRODUCTION&quot;&gt;&lt;/a&gt;INTRODUCTION&lt;/h3&gt;&lt;p&gt;语言模型是单词序列的概率分布，具有许多应用，如machine translation，speech recognition 或dialogue agents。虽然传统的神经网络语言模型已经在这个领域获得了最先进的性能，但是它们缺乏适应其最近历史的能力，这限制了它们在动态环境中的应用。最近的解决这个问题的方法是用external memory来扩充这些网络。这些模型可能会使用外部存储器来存储新的信息并适应不断变化的环境。&lt;/p&gt;
&lt;p&gt;虽然这些网络在语言建模数据集上取得了很好的结果，但它们在计算上相当昂贵。通常，他们必须学习一个可以参数化的机制来读取或写入存储单元。这可能会限制其可用内存的大小以及可以训练的数据量。在这项工作中，我们提出了一个非常轻量级的选择，它可以共享内存扩展网络的一些特性，特别是随着时间的推移动态调整的能力。通过最小化内存的计算负担，我们可以使用更大的内存并扩展到更大的数据集。我们在实践中观察到，这使我们能够在不同的语言建模任务上超越记忆增强网络的性能。&lt;/p&gt;
    
    </summary>
    
      <category term="论文" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="论文，cache model" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%EF%BC%8Ccache-model/"/>
    
  </entry>
  
  <entry>
    <title>worldcloud</title>
    <link href="http://yoursite.com/2018/01/13/worldcloud/"/>
    <id>http://yoursite.com/2018/01/13/worldcloud/</id>
    <published>2018-01-13T12:25:37.000Z</published>
    <updated>2018-01-13T13:20:13.063Z</updated>
    
    <content type="html"><![CDATA[<p>　　今天介绍一个python库－－wordcloud，这个库的主要功能是对一个文本中的单词进行统计，并且以词云的方式进行展示，从生成的图片中，我们可以直观的发现哪些单词出现的频率较高，一个很有意思的用途就是统计一个会议中，提交论文的主题是哪些，从而看出当前研究的趋势。</p><h3 id="快速安装词云"><a href="#快速安装词云" class="headerlink" title="快速安装词云"></a>快速安装词云</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install wordcloud</div></pre></td></tr></table></figure><a id="more"></a><h3 id="快速生成词云"><a href="#快速生成词云" class="headerlink" title="快速生成词云"></a>快速生成词云</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</div><div class="line"></div><div class="line">f = open(<span class="string">u'moment.txt'</span>,<span class="string">'r'</span>).read()</div><div class="line">wordcloud = WordCloud(background_color=<span class="string">"white"</span>,width=<span class="number">1000</span>, height=<span class="number">860</span>, margin=<span class="number">2</span>).generate(f)</div><div class="line"></div><div class="line"><span class="comment"># width,height,margin可以设置图片属性</span></div><div class="line"><span class="comment"># generate 可以对全部文本进行自动分词,但是他对中文支持不好,对中文的分词处理请看我的下一篇文章</span></div><div class="line"><span class="comment">#wordcloud = WordCloud(font_path = r'~\Fonts\simkai.ttf').generate(f)</span></div><div class="line"><span class="comment"># 你可以通过font_path参数来设置字体集</span></div><div class="line"><span class="comment">#background_color参数为设置背景颜色,默认颜色为黑</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">plt.imshow(wordcloud)</div><div class="line">plt.axis(<span class="string">"off"</span>)</div><div class="line">plt.show()</div><div class="line"></div><div class="line">wordcloud.to_file(<span class="string">'test.png'</span>)</div><div class="line"><span class="comment"># 保存图片,但是在第三模块的例子中 图片大小将会按照 mask 保存</span></div></pre></td></tr></table></figure><h2 id="利用背景图片生成词云"><a href="#利用背景图片生成词云" class="headerlink" title="利用背景图片生成词云"></a>利用背景图片生成词云</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</div><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud, STOPWORDS, ImageColorGenerator</div><div class="line"></div><div class="line">d = path.dirname(__file__)</div><div class="line"></div><div class="line"><span class="comment"># Read the whole text.</span></div><div class="line">text = open(path.join(d, <span class="string">'moment.txt'</span>)).read()</div><div class="line"></div><div class="line"><span class="comment"># read the mask / color image taken from</span></div><div class="line"><span class="comment"># http://jirkavinse.deviantart.com/art/quot-Real-Life-quot-Alice-282261010</span></div><div class="line">alice_coloring = np.array(Image.open(path.join(d, <span class="string">"alice_color.png"</span>)))</div><div class="line"></div><div class="line"><span class="comment"># 设置停用词</span></div><div class="line">stopwords = set(STOPWORDS)</div><div class="line">stopwords.add(<span class="string">"life"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 你可以通过 mask 参数 来设置词云形状</span></div><div class="line">wc = WordCloud(background_color=<span class="string">"white"</span>, max_words=<span class="number">2000</span>, mask=alice_coloring,</div><div class="line">               stopwords=stopwords, max_font_size=<span class="number">40</span>, random_state=<span class="number">42</span>)</div><div class="line"><span class="comment"># generate word cloud</span></div><div class="line">wc.generate(text)</div><div class="line"></div><div class="line"><span class="comment"># create coloring from image</span></div><div class="line">image_colors = ImageColorGenerator(alice_coloring)</div><div class="line"></div><div class="line"><span class="comment"># show</span></div><div class="line"><span class="comment"># 在只设置mask的情况下,你将会得到一个拥有图片形状的词云</span></div><div class="line">plt.imshow(wc, interpolation=<span class="string">"bilinear"</span>)</div><div class="line">plt.axis(<span class="string">"off"</span>)</div><div class="line">plt.figure()</div><div class="line"><span class="comment"># recolor wordcloud and show</span></div><div class="line"><span class="comment"># we could also give color_func=image_colors directly in the constructor</span></div><div class="line"><span class="comment"># 我们还可以直接在构造函数中直接给颜色</span></div><div class="line"><span class="comment"># 通过这种方式词云将会按照给定的图片颜色布局生成字体颜色策略</span></div><div class="line">plt.imshow(wc.recolor(color_func=image_colors), interpolation=<span class="string">"bilinear"</span>)</div><div class="line">plt.axis(<span class="string">"off"</span>)</div><div class="line">plt.figure()</div><div class="line">plt.imshow(alice_coloring, cmap=plt.cm.gray, interpolation=<span class="string">"bilinear"</span>)</div><div class="line">plt.axis(<span class="string">"off"</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　今天介绍一个python库－－wordcloud，这个库的主要功能是对一个文本中的单词进行统计，并且以词云的方式进行展示，从生成的图片中，我们可以直观的发现哪些单词出现的频率较高，一个很有意思的用途就是统计一个会议中，提交论文的主题是哪些，从而看出当前研究的趋势。&lt;/p&gt;
&lt;h3 id=&quot;快速安装词云&quot;&gt;&lt;a href=&quot;#快速安装词云&quot; class=&quot;headerlink&quot; title=&quot;快速安装词云&quot;&gt;&lt;/a&gt;快速安装词云&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;pip install wordcloud&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源，词云" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90%EF%BC%8C%E8%AF%8D%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Exploring Word Vectors with GloVe</title>
    <link href="http://yoursite.com/2018/01/12/Golve/"/>
    <id>http://yoursite.com/2018/01/12/Golve/</id>
    <published>2018-01-12T11:25:20.000Z</published>
    <updated>2018-01-12T11:28:14.006Z</updated>
    
    <content type="html"><![CDATA[<p>在处理文字时，处理庞大但是稀少的语言是很困难的。即使对于一个晓得语料库，神经网络也需要支持数以千计的离散输入和输出。</p><p>除了原始数字外，将单词表示为one-hot向量的方法无法捕获任何有关单词之间关系的信息。</p><p>Ｗord Vector 通过在多维向量空间中表示单词来解决这个问题。这样就可以将问题的维度数十万减少到数百。而且向量空间能够从距离向量之间的夹角来捕获单词之间的语义关系。</p><p><img src="../img/analogy.png" alt="analogy"></p><p>现已有一些创建Ｗord Vector的技巧。word2vec算法可预测上下文中的单词(例如”the cat”最可能出现的单词是”the mouse”)，而Glove向量则基于整个语料库的全局计数。glove最大的特点就是可以轻松的下载多套预先训练好的词向量。</p><a id="more"></a><h3 id="Loading-word-vectors"><a href="#Loading-word-vectors" class="headerlink" title="Loading word vectors"></a>Loading word vectors</h3><p>Torchtext包括下载GloVe（和其他）嵌入的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch</div><div class="line"><span class="keyword">import</span> torchtext.vocab <span class="keyword">as</span> vocab</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">glove = vocab.GloVe(name=<span class="string">'6B'</span>, dim=<span class="number">100</span>)</div></pre></td></tr></table></figure><blockquote><p>[out]: 98%|█████████▊| 391063/400000 [00:19&lt;00:00, 19964.76it/s]<br>​          98%|█████████▊| 393086/400000 [00:19&lt;00:00, 19965.52it/s]<br>​          99%|█████████▉| 395108/400000 [00:19&lt;00:00, 19966.79it/s]<br>​          99%|█████████▉| 397132/400000 [00:19&lt;00:00, 19968.13it/s]<br>​          100%|█████████▉| 399154/400000 [00:19&lt;00:00, 19968.55it/s]<br>​          100%|██████████| 400000/400000 [00:20&lt;00:00, 19969.45it/s]</p></blockquote><p>返回的GloVe对象包含以下属性：</p><ul><li><code>stoi</code> <em>string-to-index</em> returns a dictionary of words to indexes</li><li><code>itos</code> <em>index-to-string</em> returns an array of words by index</li><li><code>vectors</code> returns the actual vectors. To get a word vector get the index to get the vector</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_word</span><span class="params">(word)</span>:</span></div><div class="line">    <span class="keyword">return</span> glove.vectors[glove.stoi[word]]</div><div class="line"><span class="comment">#get_word('google')  输出size为100的向量</span></div></pre></td></tr></table></figure><h3 id="Finding-closest-vectors"><a href="#Finding-closest-vectors" class="headerlink" title="Finding closest vectors"></a>Finding closest vectors</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">closest</span><span class="params">(vec, n=<span class="number">10</span>)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Find the closest words for a given vector</span></div><div class="line"><span class="string">    """</span></div><div class="line">    all_dists = [(w, torch.dist(vec, get_word(w))) <span class="keyword">for</span> w <span class="keyword">in</span> glove.itos]</div><div class="line">    <span class="keyword">return</span> sorted(all_dists, key=<span class="keyword">lambda</span> t: t[<span class="number">1</span>])[:n]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_tuples</span><span class="params">(tuples)</span>:</span></div><div class="line">    <span class="keyword">for</span> tuple <span class="keyword">in</span> tuples:</div><div class="line">        print(<span class="string">'(%.4f) %s'</span> % (tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]))</div><div class="line">print_tuples(closest(get_word(<span class="string">'google'</span>)))</div></pre></td></tr></table></figure><blockquote><p>[out]: (0.0000) google<br>​           (3.0772) yahoo<br>​           (3.8836) microsoft<br>​           (4.1048) web<br>​           (4.1082) aol<br>​           (4.1165) facebook<br>​           (4.3917) ebay<br>​           (4.4122) msn<br>​           (4.4540) internet<br>​           (4.4651) netscape</p></blockquote><h3 id="Word-analogies-with-vector-arithmetic"><a href="#Word-analogies-with-vector-arithmetic" class="headerlink" title="Word analogies with vector arithmetic"></a>Word analogies with vector arithmetic</h3><p>训练有素的单词向量空间的最有趣的特征是可以用正则向量算法来捕捉某些语义关系（不仅仅是单词的紧密性）。</p><p><img src="../../Pictures/datastructure/anology_ex.png" alt="anology_ex"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># In the form w1 : w2 :: w3 : ?</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">analogy</span><span class="params">(w1, w2, w3, n=<span class="number">5</span>, filter_given=True)</span>:</span></div><div class="line">    print(<span class="string">'\n[%s : %s :: %s : ?]'</span> % (w1, w2, w3))</div><div class="line">   </div><div class="line">    <span class="comment"># w2 - w1 + w3 = w4</span></div><div class="line">    closest_words = closest(get_word(w2) - get_word(w1) + get_word(w3))</div><div class="line">    </div><div class="line">    <span class="comment"># Optionally filter out given words</span></div><div class="line">    <span class="keyword">if</span> filter_given:</div><div class="line">        closest_words = [t <span class="keyword">for</span> t <span class="keyword">in</span> closest_words <span class="keyword">if</span> t[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> [w1, w2, w3]]</div><div class="line">        </div><div class="line">    print_tuples(closest_words[:n])</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">analogy(<span class="string">'king'</span>, <span class="string">'man'</span>, <span class="string">'queen'</span>)</div></pre></td></tr></table></figure><blockquote><p>[out]: [king : man :: queen : ?]<br>​          (4.0811) woman<br>​          (4.6916) girl<br>​          (5.2703) she<br>​          (5.2788) teenager<br>​          (5.3084) boy</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在处理文字时，处理庞大但是稀少的语言是很困难的。即使对于一个晓得语料库，神经网络也需要支持数以千计的离散输入和输出。&lt;/p&gt;
&lt;p&gt;除了原始数字外，将单词表示为one-hot向量的方法无法捕获任何有关单词之间关系的信息。&lt;/p&gt;
&lt;p&gt;Ｗord Vector 通过在多维向量空间中表示单词来解决这个问题。这样就可以将问题的维度数十万减少到数百。而且向量空间能够从距离向量之间的夹角来捕获单词之间的语义关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../img/analogy.png&quot; alt=&quot;analogy&quot;&gt;&lt;/p&gt;
&lt;p&gt;现已有一些创建Ｗord Vector的技巧。word2vec算法可预测上下文中的单词(例如”the cat”最可能出现的单词是”the mouse”)，而Glove向量则基于整个语料库的全局计数。glove最大的特点就是可以轻松的下载多套预先训练好的词向量。&lt;/p&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
      <category term="Glove词向量" scheme="http://yoursite.com/tags/Glove%E8%AF%8D%E5%90%91%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>An Empirical Study of Language CNN for Image Captioning</title>
    <link href="http://yoursite.com/2018/01/10/language-CNN/"/>
    <id>http://yoursite.com/2018/01/10/language-CNN/</id>
    <published>2018-01-10T13:16:39.000Z</published>
    <updated>2018-01-10T13:22:53.769Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>In contrast to previous models which predict next word based on one previous word and hidden state, our language CNN is fed with all the previous words and can model the long-range dependencies in history words, which are critical for image captioning.</p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Image captioning model should be capable of capturing implicit semantic information of an im-age and generating humanlike sentences. Most image captioning models follow the encoder-decoder pipeline.</p><p>Although models like LSTM networks have memory cells which aim to memorize history information for long-term, they are still limited to several time steps because long-term information is gradually diluted at every time step</p><p>To better model the hierarchical structure and long-term dependencies in word sequences we adopt a language CNN which applies temporal convolution to extract features from sequences.</p><p>To summarize, our primary contribution lies in incorporating a language CNN, which is capable of capturing long-range dependencies in sequences, with RNNs for image captioning.</p><a id="more"></a><h3 id="Model-Architecture"><a href="#Model-Architecture" class="headerlink" title="Model Architecture"></a>Model Architecture</h3><h4 id="Overall-Framework"><a href="#Overall-Framework" class="headerlink" title="Overall Framework"></a>Overall Framework</h4><p><img src="../img/language_CNN.png" alt="language_CNN"></p><p>Given an image I, we take the widely-used CNN architecture VGGNet (16-layer)  pre-trained on ImageNet to extract the image features $V \in R^K$ .</p><script type="math/tex; mode=display">V = CNN_L(I)</script><h4 id="CNN-L-Layer"><a href="#CNN-L-Layer" class="headerlink" title="$CNN_L$ Layer"></a>$CNN_L$ Layer</h4><p>The $CNN_L$  is designed to represent words and their hierarchical structure in word sequences. It takes a sequence of t generated words (each word is encoded as a one-hot representation) as inputs and generates a bottom-up representation of these words.</p><p>The first layer of $CNN_L$ is a word embedding layer.Suppose we have t input words$S = ${$ {S^{[0]}, S^{[1]}, … , S^{[t-1]}}$ }, $S^{[i]}$ is the one-of-V( one-hot ) encoding.</p><p>We map each word $S^{[t]}$ in the sentence into a K-dimensional vector $x^{[t]} = W_{e}S^{[t]}$, $W_e \in R^{K \times V}$ is word embedding matrix. Those embedding are concatenated to produce a matrix:</p><script type="math/tex; mode=display">x = [x^{[0]}, x^{[1]}, ... , x^{[t-1]}]^{T}   x \in R^{t \times K}</script><p>We use the temporal convolution to model the sentence. Given an input feature map $y^{(\ell-1)} \in R^{M_{\ell-1}\times K}$of Layer-$\ell$-1,the output feature map $y^{(\ell)} \in R^{M_{\ell}\times K}$of the temporal convolution layer-$\ell$ will be:</p><script type="math/tex; mode=display">y_i^{(l)}(x) = \delta (w_L^{(l)}y_i^{(\ell -1)}+b_L^{\ell})</script><p>here $y_i^{(l)}(x)$ dives the output feature map for location $i$ in Layer-$\ell$ , $w_L^{(l)}$denotes the parameters on  Layer-$\ell$. The input feature map $y_i^{(\ell -1)}$ is the segment of Layer-$\ell$-1 for the convolution at location $i$.</p><p>While $y^{[0]}$ is the concatenation of $t$ word embeddings from the sequence input $S^{[0:t-1]}$.</p><p><img src="../img/sentence_modeling.png" alt="sentence_modeling"></p><p>The output features of the final convolution layer are fed into a fully connected layer that projects the extracted words features into a low-dimensional representation. Next, the projected features will be fed to a highway connection which controls flows of information in the layer and improves the gradient flow. The final output of the highway connection is a K-dimensional vector $y^{[t]}$.</p><h4 id="Multimodal-Fusion-Layer"><a href="#Multimodal-Fusion-Layer" class="headerlink" title="Multimodal Fusion Layer"></a>Multimodal Fusion Layer</h4><script type="math/tex; mode=display">m^{[t]} = f_{multimodal}(y^{[t]},V) = \delta (f_y; W_Y,b_Y)+g_v(V; W_V,b_V)</script><h4 id="Recurrent-Networks"><a href="#Recurrent-Networks" class="headerlink" title="Recurrent Networks"></a>Recurrent Networks</h4><p>RHN has directly gated connections between previous state $r^{[t-1]}$and current input $z^{[t]}$ to modulate the flow of information. The transition equations of RHN can be formulated as follows:</p><p><img src="../img/RHN.png" alt="RHN"></p><p><img src="../img/highway_net.png" alt="highway_net"></p><p>where $c^{[t]}$ is the carry gate, $t^{[t]}$is the transform gate, $h^{[t]}$ denotes the modulated  input, M:$R^{2K+d} \rightarrow R^{3d}$ is an affine trandformation. $z^{[t]} \in R^{[2k]}$ denotes the concatenation of two vectors: $m^{[t]}$ and $x^{[t-1]}$.</p><script type="math/tex; mode=display">z^{[t]} = [f_{multimodal}(CNN_L(x^{[0,...,t-1]}),V);x^{[t-1]}]</script><h4 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h4><p>During training, given the ground truth words S and corresponding image I, the loss function for a single training instance (S, I) is defined as a sum of the negative log likelihood of the words. The loss can be written as:</p><script type="math/tex; mode=display">L(S,I) = - \sum_{T=0}^{N-1}log P(S^{[t]}|S^{[0]},...,S^{[t-1]},I)</script><p>where N is the sequence length, and $S^{[t]}$ denotes a word in the sentence S. The training objective is to minimize the cost function.</p><h3 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h3><h4 id="Datasets-and-Evaluation-Metrics"><a href="#Datasets-and-Evaluation-Metrics" class="headerlink" title="Datasets and Evaluation Metrics"></a>Datasets and Evaluation Metrics</h4><p><strong>BLEU</strong>-n is a precision-based metric. It measures how many words are shared by the generated captions and ground truth captions.</p><p><strong>METEOR</strong> is based on the explicit word to word matches between generated captions and ground-truth captions.</p><p><strong>CIDEr</strong> is a metric developed specifically for evaluating image captions. It measures consensus in image caption by performing a Term Frequency-Inverse Document Frequency weighting for each n-gram.</p><p><strong>SPICE</strong> is a more recent metric which has been shown to correlate better with the human judgment<br>of semantic quality than previous metrics.</p><h4 id="Results-Using-CNN-L-on-MS-COCO-and-Filcker30k"><a href="#Results-Using-CNN-L-on-MS-COCO-and-Filcker30k" class="headerlink" title="Results Using CNN L on MS COCO and Filcker30k"></a>Results Using CNN L on MS COCO and Filcker30k</h4><p><img src="../img/ms_coco.png" alt="ms_coco"></p><p><img src="../img/flicker30k.png" alt="flicker30k"></p><p><img src="../img/MS_coco.png" alt="MS_coco"></p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>In this work, we present an image captioning model with language CNN to explore both hierarchical and temporal information in sequence for image caption generation. Experiments conducted on MS COCO and Flickr30K image captioning datasets validate our proposal and analysis. Performance improvements are clearly observed when compared with other image captioning methods. Future research directions will go towards integrating extra attributes learning into image captioning, and how to apply a single language CNN for image caption generation is worth trying.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;In contrast to previous models which predict next word based on one previous word and hidden state, our language CNN is fed with all the previous words and can model the long-range dependencies in history words, which are critical for image captioning.&lt;/p&gt;
&lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;Image captioning model should be capable of capturing implicit semantic information of an im-age and generating humanlike sentences. Most image captioning models follow the encoder-decoder pipeline.&lt;/p&gt;
&lt;p&gt;Although models like LSTM networks have memory cells which aim to memorize history information for long-term, they are still limited to several time steps because long-term information is gradually diluted at every time step&lt;/p&gt;
&lt;p&gt;To better model the hierarchical structure and long-term dependencies in word sequences we adopt a language CNN which applies temporal convolution to extract features from sequences.&lt;/p&gt;
&lt;p&gt;To summarize, our primary contribution lies in incorporating a language CNN, which is capable of capturing long-range dependencies in sequences, with RNNs for image captioning.&lt;/p&gt;
    
    </summary>
    
      <category term="论文" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="论文，image caption model" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%EF%BC%8Cimage-caption-model/"/>
    
  </entry>
  
  <entry>
    <title>Exploring the Limits of Language Modeling</title>
    <link href="http://yoursite.com/2018/01/09/language-modeling-limit/"/>
    <id>http://yoursite.com/2018/01/09/language-modeling-limit/</id>
    <published>2018-01-09T02:46:00.000Z</published>
    <updated>2018-01-09T02:49:01.917Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h3><p>We extend current models to deal with two key challenges present in this task: corpora and vocabulary sizes, and complex, long term structure of language. We perform an exhaustive study on techniques such as character Convolutional Neural Networks or Long-Short Term Memory, on the One Billion Word Benchmark.</p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Models which can accurately place distributions over sentences not only encode complexities of language such as grammatical structure, but also distill a fair amount of information about the knowledge that a corpora may contain.(提取大量关于语料库可能包含的知识的信息).</p><p>Language Modeling can apply in speech recoginition, machine translation, text summarization etc. (such as word error rate for speech recognition, or BLEU score for translation). </p><p>When trained on vast amounts of data, language models compactly extract knowledge encoded in the training data. For example, when trained on movie subtitles, language models are able to generate basic answers to questions about object colors,  facts about people, etc.</p><a id="more"></a><p>language model such as N-grams, only use a short history of previous words to predict the next word, , they are still a key component to high quality, low perplexity Language Modeling.  RNNs based language model are great in  combination with N-grams.</p><p>The contributions:</p><blockquote><p>Unify some of the current research on larger scale LM</p><p>Designed a Softmax loss which is based on character level CNNs instead of a full softmax</p><p>Reduce the number of parameters </p></blockquote><h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h3><h4 id="Language-Models"><a href="#Language-Models" class="headerlink" title="Language Models"></a>Language Models</h4><p>Much work has been done on both parametric (e.g., log-linear models) and non-parametric approaches (e.g., count-based LMs).</p><p>Count-based approaches(based on statistics of N-grams). For example: unigram, bigram, trigram, 5-gram models. Log-linear approaches(based on recurrent neural network).  For example: RNN-based, LSTM, GRU.</p><p><img src="../img/char_RNN.png" alt="char_RNN"></p><h4 id="Convolution-Embedding-Models"><a href="#Convolution-Embedding-Models" class="headerlink" title="Convolution Embedding Models"></a>Convolution Embedding Models</h4><p>There is an increased interest in incorporating character-level inputs to build word embeddings for various NLP problems, including part-of-speech tagging, parsing and language modeling.</p><p>Several approach building word embedding: </p><blockquote><p><strong>Bidirectional LSTMs </strong>over the characters.<br><strong>The recurrent networks</strong> process sequences of characters from both sides and their final state vectors are concatenated.<br>The words characters are processed by a <strong>1-d CNN</strong> with max-pooling across the sequence for each convolutional feature. <strong>The resulting features are fed to a 2-layer highway network, which allows the embedding to learn semantic representations.</strong></p></blockquote><h4 id="Softmax-Over-Large-Vocabularies"><a href="#Softmax-Over-Large-Vocabularies" class="headerlink" title="Softmax Over Large Vocabularies"></a>Softmax Over Large Vocabularies</h4><p>Assigning probability distributions over large vocabularies is computationally challenging. For modeling language, maximizing log-likelihood of a given word sequence leads to optimizing cross entropy between the target probability distribution, and our model predictions $p$. Generaly, predictions come from a linear layer follows by a Sofemax non-linearity:  $p(w)={\exp(z_w) \over \sum_{w’ \in V} exp(z_{w’})}$,where $z_w$ is the  logit corresponding to a word $w$. The logit is generally computed as an inner product $z_w = h^Te_w$ where $h$ is a context vector and $e_w$ is a “word embedding” for $w$.</p><p>The main challenge when $|V|$ is very large is the fact that computing all inner products between h and all embeddings becomes prohibitively slow during training. Several approaches have been proposed to cope with the scaling issue: <strong>importance sampling , Noise Contrastive Estimation (NCE), self normalizing partition functions, Hierarchical Softmax</strong>.</p><h3 id="Language-Modeling-Improvements"><a href="#Language-Modeling-Improvements" class="headerlink" title="Language Modeling Improvements"></a>Language Modeling Improvements</h3><p>Recurrent Neural Networks based LMs employ the chain rule to model joint probabilities over word sequences:</p><script type="math/tex; mode=display">p(w_1,...,w_N)=\prod_{i=1}^{N}p(w_i|w_{i-1},...,x_1)</script><p>where the context of all previous words is encoded with an LSTM, and the probability over words uses a Softmax.</p><h4 id="Relationship-between-Noise-Contrastive-Estimation-and-Importance-Sampling"><a href="#Relationship-between-Noise-Contrastive-Estimation-and-Importance-Sampling" class="headerlink" title="Relationship between Noise Contrastive Estimation and Importance Sampling"></a>Relationship between Noise Contrastive Estimation and Importance Sampling</h4><p>A large scale Softmax is necessary for training good LMs because of the vocabulary size.  A <strong>Hierarchical Softmax</strong> employs a tree in which the probability distribution over words is decomposed into a product of two probabilities for each word, greatly reducing training and inference time as only the path specified by the hierarchy needs to be computed and updated. Choosing a good hierarchy is important for obtaining good results and we did not explore this approach further for this paper as sampling methods worked well for our setup.</p><p><strong>Sampling approaches</strong> are only useful during training, as they propose an approximation to the loss which is cheap to compute (also in a distributed setting) – however, at inference time one still has to compute the normalization term over all words. Noise Contrastive Estimation (NCE) pro-<br>poses to consider a surrogate binary classification task in which a classifier is trained to discriminate between true data, or samples coming from some arbitrary distribution. If both the noise and data distributions were known, the optimal classifier would be:</p><script type="math/tex; mode=display">p(Y = true|w) = {p_d(w) \over p_d(w)+kp_n(w) }</script><p>where $Y$ is the binary random variable indicating whether w comes from the true data distribution, $k$ is the number of negative samples per positive word, and $p_d$ and $p_n$ are the data and noise distribution respectively (we dropped any dependency on previous words for notational simplicity). It is easy to show that if we train a logistic classifier $p_{\theta}(Y=true|w) = \sigma(s_{\theta}(w,h)-logkp_n(w))$, then, $p’(w)=softmax(s_{\theta}(w,h))$ is good approximation of $p_d(w)$($s_{\theta}$ is a logit which e.g. an LSTM LM computes).</p><p>The other technique, which is based on <strong>importance sampling (IS)</strong>, proposes to directly approximate the partition function (which comprises a sum over all words) with an estimate of it through importance sampling. Though the methods look superficially similar, we will derive a similar surrogate classification task akin to NCE which arrives at IS, showing a strong connection between the two.</p><p>Suppose that, instead of having a binary task to decide if a word comes from the data or from the noise distribution, we want to identify the words coming from the true data distribution in a set</p><p>$W={w_1,…,W_{k+1}}$, comprised of $k$ noise samples and one data distribution sample. we can train a multiclass loss over a multinomial random variable $Y$ which maximizes $logp(Y=1|W)$, assuming w.l.o.g. that $w_1 \in W$ is always the word coming from true data. By Bayes rule, and ignoring terms that are constant with respect to $Y$, we can write:</p><script type="math/tex; mode=display">p(Y=k|W) \propto_{Y}{p_d(w_k) \over p_n(w_k)}</script><p>and, following a similar argument than for NCE, if we define :$p(Y=k|W) = softmax(s_{\theta}(w_k)-logp_n(w_k))$ then $p’(w)=softmax(s_{\theta}(w,h))$. Note that the only difference between NCE and IS is that, in NCE, we define a binary classification task<br>between true or noise words with a logistic loss, whereas in IS we define a multiclass classification problem with a Softmax and cross entropy loss. We hope that our derivation helps clarify the similarities and differences between the two. In particular, we observe that IS, as it optimizes<br>a multiclass classification task (in contrast to solving a binary task), may be a better choice. Indeed, the updates to the logits with IS are tied whereas in NCE they are independent.</p><h4 id="CNN-softmax"><a href="#CNN-softmax" class="headerlink" title="CNN softmax"></a>CNN softmax</h4><p>The character-level features allow for a smoother and compact parametrization of the word embeddings. Recall that the Softmax computers a logit as $z_w=h^Te_w$ where $h$ is a context vector and $e_w$ is a “word embedding” for $w$. Instead of building a matrix of$|V| \times |h|$(whose rows correspond to $e_w$),  we produce $e_w$w with a CNN over the characters of $w$ as$e_w=CNN(chars_w)$– we call this a CNN Softmax. We used the same network architecture to dynamically generate the Softmax word embeddings without sharing the parameters with the input word-embedding sub-network. For inference, the vectors $e_w$ can be precomputed, so there is no computational complexity increase w.r.t. the regular Softmax.</p><p>When using an importance sampling loss only a few logits have non-zero gradient (those corresponding to the true and sampled words). With a Softmax where $e_w$ are independently<br>learned word embeddings, this is not a problem. But we observed that, when using a CNN, all the logits become tied as the function mapping from $w$ to $e_w$ w is quite smooth. As a result, a much smaller learning rate had to be used. Even with this, the model lacks capacity to differentiate<br>between words that have very different meanings but that are spelled similarly. Thus, a reasonable compromise was to add a small correction factor which is learned per word,<br>such that:</p><script type="math/tex; mode=display">z_w=h^TCNN(chars_w)+h^TM_{corr_w}</script><p>where M is a matrix projecting a low-dimensional embedding vector $corr_w$ back up to the dimensionality of the projected LSTM hidden state of h. This amounts to adding a bottleneck linear layer, and brings the CNN Softmax much closer to our best result, where adding a 128-dim correction halves the gap between regular and the CNN Softmax.</p><p>Aside from a big reduction in the number of parameters and incorporating morphological knowledge from words, the other benefit of this approach is that out-of-vocabulary (OOV) words can easily be scored. This may be useful for other problems such as Machine Translation where handling out-of-vocabulary words is very important . This approach also allows parallel training<br>over various data sets since the model is no longer explicitly parametrized by the vocabulary size – or the language. </p><h4 id="Char-LSTM-Predictions"><a href="#Char-LSTM-Predictions" class="headerlink" title="Char LSTM Predictions"></a>Char LSTM Predictions</h4><p>The CNN Softmax layer can handle arbitrary words and is much more efficient in terms of number of parameters than the full Softmax matrix. It is, though, still considerably slow, as to evaluate perplexities we need to compute the partition function. A class of models that solve this prob-<br>lem more efficiently are character-level LSTMs. They make predictions one character at a time, thus allowing to compute probabilities over a much smaller vocabulary. On the other hand,<br>these models are more difficult to train and seem to perform worse even in small tasks like PTB Most likely this is due to the sequences becoming much longer on average as the LSTM reads the input character by character instead of word by word. </p><p>Thus, we combine the word and character-level models by feeding a word-level LSTM hidden state h into a small LSTM that predicts the target word one character at a time. In order to make the whole process reasonably efficient, we train the standard LSTM model until convergence, freeze its weights, and replace the standard word-level Softmax layer with the aforementioned character-level LSTM.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ABSTRACT&quot;&gt;&lt;a href=&quot;#ABSTRACT&quot; class=&quot;headerlink&quot; title=&quot;ABSTRACT&quot;&gt;&lt;/a&gt;ABSTRACT&lt;/h3&gt;&lt;p&gt;We extend current models to deal with two key challenges present in this task: corpora and vocabulary sizes, and complex, long term structure of language. We perform an exhaustive study on techniques such as character Convolutional Neural Networks or Long-Short Term Memory, on the One Billion Word Benchmark.&lt;/p&gt;
&lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;Models which can accurately place distributions over sentences not only encode complexities of language such as grammatical structure, but also distill a fair amount of information about the knowledge that a corpora may contain.(提取大量关于语料库可能包含的知识的信息).&lt;/p&gt;
&lt;p&gt;Language Modeling can apply in speech recoginition, machine translation, text summarization etc. (such as word error rate for speech recognition, or BLEU score for translation). &lt;/p&gt;
&lt;p&gt;When trained on vast amounts of data, language models compactly extract knowledge encoded in the training data. For example, when trained on movie subtitles, language models are able to generate basic answers to questions about object colors,  facts about people, etc.&lt;/p&gt;
    
    </summary>
    
      <category term="论文" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="论文，语言模型待解决问题" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%EF%BC%8C%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%BE%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>语言模型数据处理</title>
    <link href="http://yoursite.com/2018/01/04/language-model-data/"/>
    <id>http://yoursite.com/2018/01/04/language-model-data/</id>
    <published>2018-01-04T07:25:32.000Z</published>
    <updated>2018-01-04T08:25:57.020Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">data = [(<span class="string">"me gusta comer en la cafeteria"</span>.split(), <span class="string">"SPANISH"</span>),</div><div class="line">        (<span class="string">"Give it to me"</span>.split(), <span class="string">"ENGLISH"</span>),</div><div class="line">        (<span class="string">"No creo que sea una buena idea"</span>.split(), <span class="string">"SPANISH"</span>),</div><div class="line">        (<span class="string">"No it is not a good idea to get lost at sea"</span>.split(), <span class="string">"ENGLISH"</span>)]</div></pre></td></tr></table></figure><blockquote><p>out[]</p><p>[([‘me’, ‘gusta’, ‘comer’, ‘en’, ‘la’, ‘cafeteria’], ‘SPANISH’),<br> ([‘Give’, ‘it’, ‘to’, ‘me’], ‘ENGLISH’),<br> ([‘No’, ‘creo’, ‘que’, ‘sea’, ‘una’, ‘buena’, ‘idea’], ‘SPANISH’),<br> ([‘No’,  ‘it’,   ‘is’,   ‘not’,   ‘a’,   ‘good’,   ‘idea’,   ‘to’,   ‘get’,   ‘lost’,   ‘at’,   ‘sea’],  ‘ENGLISH’)]</p></blockquote><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">word_to_ix = &#123;&#125;</div><div class="line"><span class="keyword">for</span> sent, _ <span class="keyword">in</span> data + test_data:</div><div class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> sent:</div><div class="line">        <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> word_to_ix:</div><div class="line">            word_to_ix[word] = len(word_to_ix)</div><div class="line">print(word_to_ix)</div><div class="line"><span class="keyword">print</span> (word)</div></pre></td></tr></table></figure><blockquote><p>out[] sent</p><p>[‘me’, ‘gusta’, ‘comer’, ‘en’, ‘la’, ‘cafeteria’]<br>[‘Give’, ‘it’, ‘to’, ‘me’]<br>[‘No’, ‘creo’, ‘que’, ‘sea’, ‘una’, ‘buena’, ‘idea’]<br>[‘No’, ‘it’, ‘is’, ‘not’, ‘a’, ‘good’, ‘idea’, ‘to’, ‘get’, ‘lost’, ‘at’, ‘sea’]</p><p>out[] word </p><p>me<br>gusta<br>comer<br>en<br>la<br>cafeteria<br>Give</p><p>……</p><p> out[] word_to_ix</p><p>{‘en’: 3, ‘No’: 9, ‘buena’: 14, ‘it’: 7, ‘at’: 22, ‘sea’: 12, ‘cafeteria’: 5, ‘la’: 4, ‘to’: 8, ‘creo’: 10, ‘is’: 16, ‘a’: 18, ‘good’: 19, ‘get’: 20, ‘idea’: 15, ‘que’: 11, ‘not’: 17, ‘me’: 0, ‘gusta’: 1, ‘lost’: 21, ‘Give’: 6, ‘una’: 13, ‘comer’: 2}</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> torch</div><div class="line"></div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dictionary</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.word2idx = &#123;&#125;</div><div class="line">        self.idx2word = []</div><div class="line">        self.counter = Counter()</div><div class="line">        self.total = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_word</span><span class="params">(self, word)</span>:</span></div><div class="line">        <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> self.word2idx:</div><div class="line">            self.idx2word.append(word)</div><div class="line">            self.word2idx[word] = len(self.idx2word) - <span class="number">1</span></div><div class="line">        token_id = self.word2idx[word]</div><div class="line">        self.counter[token_id] += <span class="number">1</span></div><div class="line">        self.total += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> self.word2idx[word]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> len(self.idx2word)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Corpus</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, path)</span>:</span></div><div class="line">        self.dictionary = Dictionary()</div><div class="line">        self.train = self.tokenize(os.path.join(path, <span class="string">'train.txt'</span>))</div><div class="line">        self.valid = self.tokenize(os.path.join(path, <span class="string">'valid.txt'</span>))</div><div class="line">        self.test = self.tokenize(os.path.join(path, <span class="string">'test.txt'</span>))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tokenize</span><span class="params">(self, path)</span>:</span></div><div class="line">        <span class="string">"""Tokenizes a text file."""</span></div><div class="line">        <span class="keyword">assert</span> os.path.exists(path)</div><div class="line">        <span class="comment"># Add words to the dictionary</span></div><div class="line">        <span class="keyword">with</span> open(path, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">            tokens = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">                words = line.split() + [<span class="string">'&lt;eos&gt;'</span>]</div><div class="line">                tokens += len(words)</div><div class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> words:</div><div class="line">                    self.dictionary.add_word(word)</div><div class="line"></div><div class="line">        <span class="comment"># Tokenize file content</span></div><div class="line">        <span class="keyword">with</span> open(path, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">            ids = torch.LongTensor(tokens)</div><div class="line">            token = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">                words = line.split() + [<span class="string">'&lt;eos&gt;'</span>]</div><div class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> words:</div><div class="line">                    ids[token] = self.dictionary.word2idx[word]</div><div class="line">                    token += <span class="number">1</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> ids</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;data = [(&lt;span class=&quot;string&quot;&gt;&quot;me gusta comer en la cafeteria&quot;&lt;/span&gt;.split(), &lt;span class=&quot;string&quot;&gt;&quot;SPANISH&quot;&lt;/span&gt;),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        (&lt;span class=&quot;string&quot;&gt;&quot;Give it to me&quot;&lt;/span&gt;.split(), &lt;span class=&quot;string&quot;&gt;&quot;ENGLISH&quot;&lt;/span&gt;),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        (&lt;span class=&quot;string&quot;&gt;&quot;No creo que sea una buena idea&quot;&lt;/span&gt;.split(), &lt;span class=&quot;string&quot;&gt;&quot;SPANISH&quot;&lt;/span&gt;),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        (&lt;span class=&quot;string&quot;&gt;&quot;No it is not a good idea to get lost at sea&quot;&lt;/span&gt;.split(), &lt;span class=&quot;string&quot;&gt;&quot;ENGLISH&quot;&lt;/span&gt;)]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;out[]&lt;/p&gt;
&lt;p&gt;[([‘me’, ‘gusta’, ‘comer’, ‘en’, ‘la’, ‘cafeteria’], ‘SPANISH’),&lt;br&gt; ([‘Give’, ‘it’, ‘to’, ‘me’], ‘ENGLISH’),&lt;br&gt; ([‘No’, ‘creo’, ‘que’, ‘sea’, ‘una’, ‘buena’, ‘idea’], ‘SPANISH’),&lt;br&gt; ([‘No’,  ‘it’,   ‘is’,   ‘not’,   ‘a’,   ‘good’,   ‘idea’,   ‘to’,   ‘get’,   ‘lost’,   ‘at’,   ‘sea’],  ‘ENGLISH’)]&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源，语言模型" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90%EF%BC%8C%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>前向神经网络</title>
    <link href="http://yoursite.com/2018/01/03/Forward%20Neural%20Network/"/>
    <id>http://yoursite.com/2018/01/03/Forward Neural Network/</id>
    <published>2018-01-03T14:22:21.599Z</published>
    <updated>2018-01-03T14:22:21.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深度学习应用于自然语言处理-前向神经网络"><a href="#深度学习应用于自然语言处理-前向神经网络" class="headerlink" title="深度学习应用于自然语言处理-前向神经网络"></a>深度学习应用于自然语言处理-前向神经网络</h2><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>深度学习的浪潮袭来，现已在各个领域中应用。深度学习的表现令人叹为观止，不得不说我们迎来了依靠深度学习的人工智能学习时代。</p><blockquote><p>　人工智能，让世界更美好。</p></blockquote><p>这一章主要是通过学习 <a href="http://cs224d.stanford.edu/" target="_blank" rel="external">Stanford cs224d</a> 课程已经阅读一些有些的博客所作出的总结。</p><a id="more"></a><h2 id="本章介绍"><a href="#本章介绍" class="headerlink" title="本章介绍"></a>本章介绍</h2><p>从数学的角度对前向神经网络数学模型进行介绍、推导和证明。</p><h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><p><a href="http://cs229.stanford.edu/section/cs229-linalg.pdf" target="_blank" rel="external">线性代数(Linear Algebra)</a><br><a href="http://cs229.stanford.edu/section/cs229-prob.pdf" target="_blank" rel="external">概率论(Probability Theory)</a><br><a href="http://cs229.stanford.edu/section/cs229-cvxopt.pdf" target="_blank" rel="external">凸优化(Convex Optimization)</a></p><h2 id="前向神经网络"><a href="#前向神经网络" class="headerlink" title="前向神经网络"></a>前向神经网络</h2><p>所谓神经网络就是将许多个单一“神经元”联结在一起，这样，一个“神经元”的输出就可以是另一个“神经元”的输入。以下是一个简单的<strong>三层前向全连接神经网络：</strong></p><p><img src="http://oddpnmpll.bkt.clouddn.com/2016-10-18-14%3A47%3A20.jpg" alt="neural networks"></p><p>图中<strong>x</strong>为输入层，<strong>h</strong>为隐藏层，$\hat{y}$为输出层。在全连接网络中，上一层和下一层的每个神经元都相连。隐藏层在接收到输入x后会进行一个非线性变化，再将输出信号传递给下一层。非线性变换由激活函数(activation function)实现。在数学上，我们可以用矩阵乘法（Matrix multiplication）来解释:</p><script type="math/tex; mode=display">\begin{align*}\boldsymbol{h} &= \text{sigmoid}(\boldsymbol{xW}_1+\boldsymbol{b}_1)\\\boldsymbol{\hat{y}} &= \text{softmax}(\boldsymbol{hW}_2+\boldsymbol{b}_2)\\\end{align*}</script><p>式中<strong>sigmoid</strong>和<strong>softmax</strong>都是一个激活函数,<strong>W</strong>是指两层之间的权重，<strong>b</strong>是偏置量。我们可以看到<strong>x</strong>进行了线性变换后，再做非线性变换，<strong>x</strong>输出的信号将作为<strong>b</strong>的输入。</p><h3 id="激活函数-Activation-fuction"><a href="#激活函数-Activation-fuction" class="headerlink" title="激活函数(Activation fuction)"></a>激活函数(Activation fuction)</h3><p>激活函数的作用是能够给神经网络加入一些非线性因素，使得神经网络可以更好地解决较为复杂的问题。激活函数的缺点是如果模型比较复杂，面对样本数不大的情况时容易出现<a href="http://blog.csdn.net/artprog/article/details/51278643" target="_blank" rel="external"><strong>过拟合</strong></a>。常用的激活函数还有<strong>tanh函数</strong>，<strong>RelU函数</strong>等等。</p><p><strong>sigmoid</strong>函数的数学形式：</p><script type="math/tex; mode=display">\sigma(x) = \dfrac{1}{1+e^{-x}}</script><p><strong>sigmoid</strong>函数求导：</p><script type="math/tex; mode=display">\sigma '(x)= \dfrac{e^{-x}}{(1+e^{-x})^2}=(1-\sigma)\sigma</script><p><strong>sigmoid</strong>函数和导数python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></div><div class="line">  x = <span class="number">1.</span>/(<span class="number">1</span>+np.exp(-x))</div><div class="line">  <span class="keyword">return</span> x</div><div class="line"><span class="comment"># grad</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_grad</span><span class="params">(f)</span>:</span></div><div class="line">  f = f*(<span class="number">1</span>-f)</div><div class="line">  <span class="keyword">return</span> f</div></pre></td></tr></table></figure><p><strong>softmax</strong>函数的数学形式：</p><script type="math/tex; mode=display">\text{softmax}(z_i) = \dfrac{e^{z_i}}{\sum_{j=1}^{c} e^{z_j}}      \quad 假设a_i=\text{softmax}(z_i)</script><p><strong>softmax</strong>函数求导：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial a_i}{\partial z_i}&=-\dfrac{e^{z_i}(\sum_{j} e^{z_j})-e^{z_i}e^{z_i}}{(\sum_{j} e^{z_j})^2}\\&=-\dfrac{e^{z_i}}{\sum_{j} e^{z_j}}+(\dfrac{e^{z_i}}{\sum_{j} e^{z_j}})^2\\&= a_i(1-a_i)\end{align*}</script><p><strong>softmax函数</strong>的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy</div><div class="line"><span class="comment"># 输出softmax函数值，输入向量或矩阵x</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(x.shape)&gt;<span class="number">1</span>:</div><div class="line">        max = np.max(x,axis=<span class="number">1</span>)[:,np.newaxis]</div><div class="line">        x -= max</div><div class="line">        x = np.exp(x)</div><div class="line">        softmax_deno = np.sum(x, axis=<span class="number">1</span>)[:,np.newaxis]</div><div class="line">        x = x/softmax_deno</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        max = np.max(x)</div><div class="line">        x -= max</div><div class="line">        x = np.exp(x)</div><div class="line">        softmax_deno = np.sum(x)</div><div class="line">        x = x/softmax_deno</div><div class="line">    <span class="keyword">return</span> x</div></pre></td></tr></table></figure><h3 id="目标函数-Objective-fuction"><a href="#目标函数-Objective-fuction" class="headerlink" title="　目标函数(Objective fuction)"></a>　目标函数(Objective fuction)</h3><p>目标函数，有时候又称<strong>损失函数（loss function），代价函数（cost function ）</strong>，是网络中的性能参数，也是编译一个模型必须的两个参数之一。在训练模型时，我们的最终目标就是最大化或者最小化目标函数，用$J$表示目标函数。</p><script type="math/tex; mode=display">\arg\min_{\theta}\ J</script><h4 id="交叉熵-Cross-entropy"><a href="#交叉熵-Cross-entropy" class="headerlink" title="交叉熵(Cross entropy)"></a>交叉熵(Cross entropy)</h4><p>一种常见的目标函数形式：</p><script type="math/tex; mode=display">J = -\sum_{i}y_i\log{\hat{y}_i}</script><p>其中$i$代表响应的类别，$y_i$是训练样本中的标签，而$\hat{y}_i$模型预测结果。</p><p>一般情况下，我们对$y_i$使用<strong>one-hot</strong>编码，而$\hat{y}$代表了对应类别的概率$p(y_i|w,x)$，因此，$\sum_i\hat{y_i}=1$,在这里我们称$y_i$为预测函数。</p><p>*对$\hat{y}$求导：    </p><script type="math/tex; mode=display">\dfrac{\partial{J}}{\partial{\hat{y}_i}}=-\dfrac{y_i}{\hat{y}_i}</script><p>对向量$\hat{\boldsymbol{y}}=(\hat{y}_1,\ \dots\ ,\hat{y}_c)$求导：</p><script type="math/tex; mode=display">\dfrac{\partial{J}}{\partial\hat{\boldsymbol{y}}}=(-\dfrac{y_1}{\hat{y}_1},\ \dots\ ,-\dfrac{y_c}{\hat{y}_c})</script><h3 id="预测函数-Predict-function"><a href="#预测函数-Predict-function" class="headerlink" title="　预测函数(Predict function)"></a>　预测函数(Predict function)</h3><p>对于预测函数$\hat{y}_i$,我们取$\hat{y}_i$最大的$i$作为模型最终预测的类别。使用softmax函数对输出层的输入进行归一化操作，数学表示为：</p><script type="math/tex; mode=display">\hat{y_i}=p(y_i|w,x)=\dfrac{e^{z_i}}{\sum_{j=1}^{c} e^{z_j}}</script><p>其中$c$表示类别个数，在这里即是输出层的神经元个数。$z_i$为输出层的输入。</p><p>根据softmax函数的求导可知，预测函数$\hat{y}_i$对$z_i$求导：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial \hat{y_i}}{\partial z_i} &= -\hat{y_i}(1-\hat{y_i})\\\dfrac{\partial \hat{y_k}}{\partial z_i} &= -\hat{y_k}\hat{y_i}\end{align*}</script><p>根据链式法则，目标函数$J$对$z_i$求导：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial J}{\partial z_i} &=\dfrac{\partial J}{\partial \hat{y_1}} \dfrac{\partial \hat{y_1}}{\partial z_i}+\dots+ \dfrac{\partial J}{\partial \hat{y_c}} \dfrac{\partial \hat{y_c}}{\partial z_i}\\&= y_1\hat{y_i}+\dots+y_i(\hat{y_i}-1)+\dots+y_c\hat{y_i}\\&=\hat{y}_i\sum_{j=1}^cy_c-y_i\\&=\hat{y}_i-y_i\end{align*}</script><p>目标函数$J$对向量$z$求导：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial J}{\partial \boldsymbol{z}} = {\boldsymbol{y}}-{\hat{\boldsymbol{y}}}\end{align*}</script><h3 id="前向传播-Forward-propagation"><a href="#前向传播-Forward-propagation" class="headerlink" title="前向传播(Forward propagation)"></a>前向传播(Forward propagation)</h3><p><strong>前向传播是求目标函数值的过程</strong>，从输入层开始，样本的特征向量$x$遍历模型，到达输出层$\hat{y}$，再将$\hat{y}$和  $y$进行比较，得到目标函数值$J$： </p><script type="math/tex; mode=display">\begin{align*}\boldsymbol{h} &= sigmoid(\boldsymbol{xW}_1+\boldsymbol{b}_1)\\\boldsymbol{\hat{y}} &= sigmoid(\boldsymbol{hW}_2+\boldsymbol{b}_2)\\J &= -\sum_{i}y_i\log{\hat{y}_i}\end{align*}</script><p>训练模型的过程就是优化目标函数的过程，我们需要最小化$J=J(\boldsymbol{W}_1,\boldsymbol{b}_1,\boldsymbol{W}_2,\boldsymbol{b_2})$,这歌优化过程我们可以使用<a href="http://www.cnblogs.com/pinard/p/5970503.html" target="_blank" rel="external">梯度下降法</a>,但是由于$J$是一个非凸函数，因此不能使用梯度下降法求得全局最优，也就是不能获得的$J$最小值。</p><h3 id="随机梯度下降-Stochastic-gradient-descent"><a href="#随机梯度下降-Stochastic-gradient-descent" class="headerlink" title="随机梯度下降(Stochastic gradient descent)"></a>随机梯度下降(Stochastic gradient descent)</h3><p>我们可以求目标函数的梯度，它代表目标函数变化增加最快的地方。相反，沿着梯度相反的方向，梯度减少最快，所以我们可以使用迭代的方法更新参数，使得目标函数往着最优的方向进行优化，找到目标函数的最小值：</p><script type="math/tex; mode=display">\boldsymbol{g}^{(t)} = \dfrac{\partial{J}}{\partial{\boldsymbol{W}^{(t)}}}\\\boldsymbol{W}^{(t+1)} =\boldsymbol{W}^{(t)}+ \alpha\boldsymbol{g}^{(t)}</script><p>$t$表示第$t$次进行迭代更新，$\alpha$表示学习率，代表着每一次迭代要走的步长，$Ｗ$表示我们需要更新的参数，在本例子中，我们需要对$W_1$,$b_2$,$W_2$,$b_2$进行参数更新，每次迭代都需要进行梯度的计算，每次迭代都要计算目标函数的值。</p><p>假设训练样本数量为$N$，如果每次迭代都使用所有的训练样本。这时的目标函数是：</p><script type="math/tex; mode=display">\mathbb{J}=\mathbb{E}(J)=\dfrac{1}{N}\sum_nJ_n</script><p>当$N$很大的时候，每次迭代都十分耗时，因此收敛的速度会较慢。我们可以使用一种逼近方法，称为<strong>mini-batch</strong>。</p><ul><li><strong>mini-batch</strong>很简单，就是每次迭代更新只使用$k$个训练样本，$k$可以是100这种相对较小的数。</li><li>而<strong>随机梯度下降(SGD)</strong>是每次更新迭代只使用$1$个训练样本，即$k=1$。<strong>SGD</strong>是<strong>mini-batch</strong>的特殊情况，但是我们一般说<strong>SGD</strong>就是指<strong>mini-batch</strong>。</li></ul><h3 id="后向传播-Backward-propagation"><a href="#后向传播-Backward-propagation" class="headerlink" title="后向传播(Backward propagation)"></a>后向传播(Backward propagation)</h3><p><strong>后向传播就是一个求梯度的过程</strong>从输出层开始往输入层传入误差。</p><p>我们将三层全连接神经网络模型的前向传播表示为：</p><script type="math/tex; mode=display">\begin{align*}&\boldsymbol{z}_1 = \boldsymbol{xW_1}+\boldsymbol{b}_1\\&\boldsymbol{h} = {\text sigmoid}(\boldsymbol{z}_1)\\&\boldsymbol{z}_2 = \boldsymbol{xW_2}+\boldsymbol{b}_2\\&\hat{\boldsymbol{y}} = softmax(\boldsymbol{z}_2)\\&J = -\sum_{i}y_i\log{\hat{y}_i}\end{align*}</script><p>计算后向传播：</p><script type="math/tex; mode=display">\begin{align*}&\boldsymbol{\delta}_1 = \dfrac{\partial J}{\partial \boldsymbol{z}_2} = \hat{\boldsymbol{y}}-\boldsymbol{y}\\&\boldsymbol{\delta}_2 = \dfrac{\partial J}{\partial \boldsymbol{h}} = \boldsymbol{\delta}_1\dfrac{\partial \boldsymbol{z}_2}{\partial \boldsymbol{h}} =\boldsymbol{\delta}_1\boldsymbol{W}^T_2 \\&\boldsymbol{\delta}_3 = \dfrac{\partial J}{\partial \boldsymbol{z}_1} = \boldsymbol{\delta}_2\dfrac{\partial \boldsymbol{h}}{\partial \boldsymbol{z}_1} =\boldsymbol{\delta}_2*\sigma'(\boldsymbol{z}_1) \\&\boldsymbol{\delta}_4 = \dfrac{\partial J}{\partial \boldsymbol{x}} = \boldsymbol{\delta}_3\dfrac{\partial \boldsymbol{z}_1}{\partial \boldsymbol{x}} =\boldsymbol{\delta}_3\boldsymbol{W}^T_1 \\\end{align*}</script><p>$\boldsymbol{\delta}_1$就是预测误差，得到上面传播的误差，我们对每一层的参数求梯度：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial J}{\partial \boldsymbol{W}_2}&= \boldsymbol{\delta}_1 \dfrac{\partial\boldsymbol{z}_2 }{\partial \boldsymbol{W}_2} = \boldsymbol{h}^T\boldsymbol{\delta}_1\\\dfrac{\partial J}{\partial \boldsymbol{b}_2} &= \boldsymbol{\delta}_1 \dfrac{\partial\boldsymbol{z}_2 }{\partial \boldsymbol{b}_2} = \boldsymbol{\delta}_1\\\dfrac{\partial J}{\partial \boldsymbol{W}_1} &= \boldsymbol{\delta}_3 \dfrac{\partial\boldsymbol{z}_1 }{\partial \boldsymbol{W}_1} = \boldsymbol{x}^T\boldsymbol{\delta}_3\\\dfrac{\partial J}{\partial \boldsymbol{b}_1} &= \boldsymbol{\delta}_3 \dfrac{\partial\boldsymbol{z}_1 }{\partial \boldsymbol{b}_1} = \boldsymbol{\delta}_3\\\end{align*}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;深度学习应用于自然语言处理-前向神经网络&quot;&gt;&lt;a href=&quot;#深度学习应用于自然语言处理-前向神经网络&quot; class=&quot;headerlink&quot; title=&quot;深度学习应用于自然语言处理-前向神经网络&quot;&gt;&lt;/a&gt;深度学习应用于自然语言处理-前向神经网络&lt;/h2&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;深度学习的浪潮袭来，现已在各个领域中应用。深度学习的表现令人叹为观止，不得不说我们迎来了依靠深度学习的人工智能学习时代。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;　人工智能，让世界更美好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一章主要是通过学习 &lt;a href=&quot;http://cs224d.stanford.edu/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stanford cs224d&lt;/a&gt; 课程已经阅读一些有些的博客所作出的总结。&lt;/p&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="http://yoursite.com/2018/01/03/stack/"/>
    <id>http://yoursite.com/2018/01/03/stack/</id>
    <published>2018-01-03T13:30:09.000Z</published>
    <updated>2018-01-03T14:15:58.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈(stack)　限定仅在表尾进行插入或删除操作的线性表。</p><p>表尾端称为<strong>栈顶(top)</strong>，表头端称为<strong>栈底(bottom)</strong>。</p><p><img src="../img/stackfeature.png" alt="stackfeature"></p><p><strong>后进先出</strong>的线性表。栈的抽象数据类型定义：</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ADT Stack&#123;</div><div class="line">  数据对象： D = &#123;ai|ai belong to ElemSet,i=<span class="number">1</span>,<span class="number">2</span>,....,n, n&gt;=<span class="number">0</span>&#125;</div><div class="line">  数据关系： R1 = &#123;&lt;ai<span class="number">-1</span>,ai&gt;|ai<span class="number">-1</span>,ai belong to D,i=<span class="number">1</span>,<span class="number">2</span>,....,n&#125;</div><div class="line">      InitStack(&amp;S)</div><div class="line">      <span class="comment">// 构造一个空栈Ｓ。</span></div><div class="line">      DestoryStack(&amp;S)</div><div class="line">      <span class="comment">// 销毁栈Ｓ。</span></div><div class="line">      ClearStack(&amp;S)</div><div class="line">      <span class="comment">//将S清为空栈。</span></div><div class="line">      StackEmpty(S)</div><div class="line">      <span class="comment">// 若栈Ｓ为空栈，则返回true,否则False。</span></div><div class="line">      StackLength(S)</div><div class="line">      <span class="comment">//返回S的元素个数，即栈的长度。</span></div><div class="line">      GetTop(S,&amp;e)</div><div class="line">      <span class="comment">//用e返回S的栈顶元素。</span></div><div class="line">      Push(&amp;S,e)</div><div class="line">      <span class="comment">//插入元素e为新的栈顶元素。</span></div><div class="line">      Pop(&amp;S,&amp;e)</div><div class="line">      <span class="comment">//删除S的栈顶元素，并用e返回其值。</span></div><div class="line"> </div><div class="line">&#125;ADT Stack</div></pre></td></tr></table></figure><p>顺序栈定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">  SElemType    *base;</div><div class="line">  SElemType    *top;</div><div class="line">  <span class="keyword">int</span>          stacksize;</div><div class="line">&#125;SqStack</div></pre></td></tr></table></figure><p>设定两个常量：<strong>STACK_INIT_SIZE</strong>(存储空间初始分配量) 和<strong>STACKINCREMENT</strong>（存储空间分配增量)</p><p><strong>top</strong>:栈顶指针，初始值指向栈底，<strong>base</strong>:栈底指针，初始值指向栈底顶，<strong>stacksize</strong>:栈当前可用容量</p><p>顺序栈模块说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE  100;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT   10;</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">  SElemType    *base;</div><div class="line">  SElemType    *top;</div><div class="line">  <span class="keyword">int</span>          stacksize;</div><div class="line">&#125;SqStack;</div><div class="line"><span class="comment">//－－－－－基本操作的函数原型说明－－－－－</span></div><div class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">DestoryStack</span><span class="params">(SqStack &amp;S)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Status  <span class="title">ClearStack</span><span class="params">(SqStack &amp;S)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">StackLength</span><span class="params">(SqStack S)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S,SElemType &amp;e)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//－－－－－基本操作的算法描述－－－－－</span></div><div class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</div><div class="line">  S.base = (SElemType *)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="keyword">sizeof</span>(SElemType))</div><div class="line">  <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span> (OVERFLOW);  <span class="comment">//存储分配失败</span></div><div class="line">  S.top = S.base;</div><div class="line">  S.stacksize = STACK_INIT_SIZE;</div><div class="line">  <span class="keyword">return</span> Ok;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S,SElemType &amp;e)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(S.top == S.base) <span class="keyword">return</span> ERROR;</div><div class="line">  e = *(S.top<span class="number">-1</span>);</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize)&#123;</div><div class="line">    S.base = (SElemType *)<span class="built_in">realloc</span> (S.base,(S.stacksize+STACKINCREMENT)*<span class="keyword">sizeof</span>(SElemType));</div><div class="line">    <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span> (OVERFLOW);</div><div class="line">    S.top = S.base+S.stacksize;</div><div class="line">    S.stacksize+= STACKINCREMENT;</div><div class="line">  &#125;</div><div class="line">  *S.top ++ = e;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(S.top == S.base) <span class="keyword">return</span> ERROR;</div><div class="line">  e = *--S.top;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="栈的应用举例"><a href="#栈的应用举例" class="headerlink" title="栈的应用举例"></a>栈的应用举例</h3><p>迷宫求解（从入口到出口的路径算法）</p><p><img src="../img/migong.png" alt="migong"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">  <span class="keyword">int</span>       ord;       <span class="comment">//通道块在路径上的“序号”</span></div><div class="line">  PosType   seat;　　　<span class="comment">//通道块在迷宫中的“坐标位置”</span></div><div class="line">  <span class="keyword">int</span>       di;　　　　<span class="comment">//从此通道走向下一通道块的“方向”</span></div><div class="line">&#125;SElemType;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">MazePath</span><span class="params">(MazeType maze,PosType start,PosType end)</span></span>&#123;</div><div class="line">  InitStack(S); curpos = start;   <span class="comment">//设定“当前位置”为“入口位置”</span></div><div class="line">  curpos = <span class="number">1</span>;　　　　　　　　　　　　<span class="comment">//探索第一步</span></div><div class="line">  <span class="keyword">do</span>&#123;</div><div class="line">    <span class="keyword">if</span>(Pass(curpos))&#123;　　　　　　　<span class="comment">//当前位置可以通过，即是未曾走到过的通道块</span></div><div class="line">      FootPrint(curpos);　　　　　<span class="comment">//留下足迹</span></div><div class="line">      e = (curstep,curpos,<span class="number">1</span>);</div><div class="line">      Push(S,e);　　　　　　　　　<span class="comment">//加入路径</span></div><div class="line">      <span class="keyword">if</span>(corpos == end) <span class="keyword">return</span> (TRUE);</div><div class="line">      curpos = NextPos(curpos,<span class="number">1</span>);</div><div class="line">      curpos ++;　　　　　　　　 <span class="comment">//探索下一步</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;　　　　　　　　　　　　　<span class="comment">//当前位置不可以通过</span></div><div class="line">      <span class="keyword">if</span>(!StackEmpty(S))&#123;</div><div class="line">        Pop(S,e);</div><div class="line">        <span class="keyword">while</span>(e.di == <span class="number">4</span> &amp;&amp; !StackEmpty(S))&#123;</div><div class="line">          MarkPrint(e.seat); Pop(S,e);   <span class="comment">//留下不能通过的标记，并退回一步</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(e.di&lt;<span class="number">4</span>)&#123;</div><div class="line">          e.di++;  Push(S,e); 　　　　　　<span class="comment">//换下一个方向探索</span></div><div class="line">          curpos = NextPos(e.seat,e.di);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="keyword">while</span>(!StackEmpty(S));</div><div class="line">  <span class="keyword">return</span> (FALSE);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="栈与递归的实现"><a href="#栈与递归的实现" class="headerlink" title="栈与递归的实现"></a>栈与递归的实现</h3><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p><strong>队列</strong>(queue)是一种<strong>先进先出</strong>的线性表。只允许在表的<strong>一端进行插入，而在另一端删除元素</strong>。</p><p>队列的抽象数据类型定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ADT Queue&#123;</div><div class="line">  数据对象： D = &#123;ai|ai belong to ElemSet,i=<span class="number">1</span>,<span class="number">2</span>,....,n, n&gt;=<span class="number">0</span>&#125;</div><div class="line">  数据关系： R1 = &#123;&lt;ai<span class="number">-1</span>,ai&gt;|ai<span class="number">-1</span>,ai belong to D,i=<span class="number">1</span>,<span class="number">2</span>,....,n&#125;</div><div class="line">      InitQueue(&amp;Q)</div><div class="line">      <span class="comment">// 构造一个空队列Q。</span></div><div class="line">      DestoryQueue(&amp;Q)</div><div class="line">      <span class="comment">// 销毁栈Q。</span></div><div class="line">      ClearQueue(&amp;Q)</div><div class="line">      <span class="comment">//将Q清为空队列。</span></div><div class="line">      QueueEmpty(Q)</div><div class="line">      <span class="comment">// 若栈Q为空队列，则返回true,否则False。</span></div><div class="line">      QueueLength(Q)</div><div class="line">      <span class="comment">//返回S的元素个数，即队列的长度。</span></div><div class="line">      GetHead(Q,&amp;e)</div><div class="line">      <span class="comment">//用e返回Q的队头元素。</span></div><div class="line">      EnQueue(&amp;Q,e)</div><div class="line">      <span class="comment">//插入元素e为Q的新的队尾元素。</span></div><div class="line">      DeQueue(&amp;S,&amp;e)</div><div class="line">      <span class="comment">//删除Q的队头元素，并用e返回其值。</span></div><div class="line"> </div><div class="line">&#125;ADT Queue</div></pre></td></tr></table></figure><p>链队列</p><p><img src="../img/queue.png" alt="queue"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//－－－－－ADT Queue的表示与实现－－－－－</span></div><div class="line"></div><div class="line"><span class="comment">//－－－－－单链队列－－队列的链式存储结构－－－－－</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></div><div class="line">  QElemType       data;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">QNOde</span>    *<span class="title">next</span>;</span></div><div class="line">&#125;QNOde, *QueuePtr;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">  QueuePtr   front    <span class="comment">//队头指针</span></div><div class="line">  QueuePtr   rear     <span class="comment">//队尾指针</span></div><div class="line">&#125;LinkQueue;</div><div class="line"></div><div class="line"><span class="comment">//－－－－－基本操作的函数原型说明－－－－－</span></div><div class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></div><div class="line"><span class="function">   </span></div><div class="line"><span class="function">Status <span class="title">DestoryQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></div><div class="line"><span class="function">  </span></div><div class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">Status <span class="title">QueueLength</span><span class="params">(LinkQueue Q)</span></span></div><div class="line"><span class="function">  </span></div><div class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span></div><div class="line"><span class="function">  </span></div><div class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span></div><div class="line"><span class="function">  </span></div><div class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="comment">//－－－－－基本操作的算法描述－－－－－</span></span></div><div class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</div><div class="line">  Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</div><div class="line">  <span class="keyword">if</span>(!Q.front)<span class="built_in">exit</span>(OVERFLOW);</div><div class="line">  Q.front-&gt;next = <span class="literal">NULL</span>;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">DestoryQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</div><div class="line">  <span class="keyword">while</span>(Q.front)&#123;</div><div class="line">    Q.rear = Q.front-&gt;next;</div><div class="line">    <span class="built_in">free</span>(Q.front);</div><div class="line">    Q.front = Q.rear;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span>&#123;</div><div class="line">  p = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</div><div class="line">  <span class="keyword">if</span>(!p) <span class="built_in">exit</span>(OVERFLOW);</div><div class="line">  p-&gt;data = e;  p-&gt;next = <span class="literal">NULL</span>;</div><div class="line">  Q.rear-&gt;next = p;</div><div class="line">  Q.rear = p;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;</div><div class="line">  p = Q.front-&gt;next;</div><div class="line">  e = p-&gt;data;</div><div class="line">  Q.front-&gt;next = p-&gt;next;</div><div class="line">  <span class="keyword">if</span>(Q.rear == p) Q.rear = Q.front;</div><div class="line">  <span class="built_in">free</span>(p);</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>循环队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//－－－－－循环队列－－队列的顺序存储结构－－－－－</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQSIZE 100　　　<span class="comment">//最大队列长度</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">  QElemType  *base;   <span class="comment">//初始化的动态分配存储空间</span></div><div class="line">  <span class="keyword">int</span>  front;         <span class="comment">//头指针，若队列不为空，指向队列头元素</span></div><div class="line">  <span class="keyword">int</span>  rear;　　　　　　<span class="comment">//尾指针，若队列不为空，指向队列尾元素的下一个位置</span></div><div class="line">&#125;sqQueue;</div><div class="line"></div><div class="line"><span class="comment">//－－－－－循环队列的基本操作的算法描述－－－－－</span></div><div class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</div><div class="line">  <span class="comment">//构造一个空队列</span></div><div class="line">  Q.base = (QElemType ×)<span class="built_in">malloc</span>(MAXQSIZE *<span class="keyword">sizeof</span>(QElemType));</div><div class="line">  <span class="keyword">if</span>(!Q.base) <span class="built_in">exit</span>(OVERFLOW);</div><div class="line">  Q.front = Q.rear = <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span>&#123;</div><div class="line">  <span class="comment">//返回Ｑ的元素个数，即队列的长度</span></div><div class="line">  <span class="keyword">return</span>(Q.rear-Q.front+MAXQSIZE) % MAXQSIZE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, QElemType e)</span></span>&#123;</div><div class="line">  <span class="comment">//插入元素ｅ为Ｑ的新的队尾元素</span></div><div class="line">  <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MAXQSIZE == Q.front) <span class="keyword">return</span> ERROR; <span class="comment">//队列满</span></div><div class="line">  Q.base[Q.rear]= e;</div><div class="line">  Q.rear = (Q.rear+<span class="number">1</span>) % MAXQSIZE;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">DEQueue</span><span class="params">(SqQueue &amp;Q, QElemType e)</span></span>&#123;</div><div class="line">  <span class="comment">//若对垒不为空，则删除Ｑ的队头元素，用ｅ返回其值，并返回ＯＫ；</span></div><div class="line">  <span class="comment">//否则返回ＥＲＲＯＲ</span></div><div class="line">  <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;</div><div class="line">  e = Q.base[Q.front];</div><div class="line">  Q.front = (Q.front+<span class="number">1</span>) %　MAXQSIZE;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;栈和队列&quot;&gt;&lt;a href=&quot;#栈和队列&quot; class=&quot;headerlink&quot; title=&quot;栈和队列&quot;&gt;&lt;/a&gt;栈和队列&lt;/h2&gt;&lt;h3 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h3&gt;&lt;p&gt;栈(stack)　限定仅在表尾进行插入或删除操作的线性表。&lt;/p&gt;
&lt;p&gt;表尾端称为&lt;strong&gt;栈顶(top)&lt;/strong&gt;，表头端称为&lt;strong&gt;栈底(bottom)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../img/stackfeature.png&quot; alt=&quot;stackfeature&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后进先出&lt;/strong&gt;的线性表。栈的抽象数据类型定义：&lt;/p&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读，栈和队列" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%EF%BC%8C%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Array</title>
    <link href="http://yoursite.com/2018/01/02/array/"/>
    <id>http://yoursite.com/2018/01/02/array/</id>
    <published>2018-01-02T12:24:44.000Z</published>
    <updated>2018-01-03T13:32:44.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><p>简言之，一个线性表是n个数据元素的有限序列。</p><p>在复杂的线性表中，一个数据元素可由若干个数据项(item)组成。在这种情况下，常把数据元素称为记录(record)，含有大量记录的线性表又称为文件（file）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ADT List&#123;</div><div class="line">  <span class="comment">//数据对象</span></div><div class="line">  D = &#123;a1|a2 belong to ElemSet, i=<span class="number">1</span>,<span class="number">2</span>,....,n, n&gt;<span class="number">0</span>&#125;</div><div class="line">  <span class="comment">//数据关系</span></div><div class="line">  R1 = &#123;&lt;ai<span class="number">-1</span>,ai&gt;|ai<span class="number">-1.</span>ai belong to D,i = <span class="number">1</span>,<span class="number">2.</span>..n&#125;</div><div class="line">  <span class="comment">//基本操作</span></div><div class="line">  InitList(&amp;L)</div><div class="line">    <span class="comment">//构造一个空的线性表Ｌ</span></div><div class="line">  DestoryList(&amp;L)</div><div class="line">    <span class="comment">//销毁线性表Ｌ</span></div><div class="line">  ClearList(&amp;L)</div><div class="line">    <span class="comment">//将Ｌ重置为空表</span></div><div class="line">  ListEmpty(L)</div><div class="line">    <span class="comment">//若L为空表，返回True,否则False</span></div><div class="line">  ListLength(L)</div><div class="line">    <span class="comment">//返回L中数据元素个数</span></div><div class="line">  GetElem(L,i,&amp;e)</div><div class="line">    <span class="comment">//用e返回L中第i个数据元素的值</span></div><div class="line">  ListInsert(&amp;L,i,e)</div><div class="line">    <span class="comment">//在Ｌ中第i个位置之前插入新的数据元素e，Ｌ的长度加1。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p>例2.1　LA和LB中的数据元素按值非递减有序排列，要求将LA和LB归并为新的线性表LC，且LC中的数据元素仍然按值非递减有序排列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LA = (3,5,8,11)  LB = (2,6,8,9,11,15,20)</span></div><div class="line"><span class="comment">// LC =(2,3,5,6,8,8,9,11,11,15,20)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(List La,List Lb,List &amp;Lc)</span></span>&#123;</div><div class="line">  InitList(Lc);</div><div class="line">  i = j = <span class="number">1</span>; k=<span class="number">0</span>;</div><div class="line">  La_len = ListLength(La); Lb_len = ListLength(Lb);</div><div class="line">  <span class="keyword">while</span>((i&lt;=La_len)&amp;&amp;(j&lt;=Lb_len))&#123;</div><div class="line">    GetElem(La,i,ai); GetElem(Lb,j,bj);</div><div class="line">    <span class="keyword">if</span>(ai&lt;=bj)&#123;ListInsert(Lc,++k,ai);++i;&#125;</div><div class="line">    <span class="keyword">else</span>&#123;ListInsert(Lc,++k,bj);++j;&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span>(i&lt;=La_len)&#123;</div><div class="line">    GetElem(La,i,ai);ListInsert(Lc,++k,ai);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span>(j&lt;=Lb_len)&#123;</div><div class="line">     GetElem(Lb,i,bj);ListInsert(Lc,++k,bj);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h3><p>线性表的顺序表示指的是用一组地址连续的存储单元以此存储线性表的数据元素。</p><p>一般来说，线性表的第$i$个数据元素$a_j$的存储位置为 $LOC(a_i) = LOC(a_1)+(i-1) \times l$</p><p>线性表的这种机内表示称作线性表的顺序存储结构或顺序映像(sequential mapping)。</p><p>Ｃ语言中可用动态分配的一维数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// －－－－－线性表的动态分配顺序存储结构－－－－－</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE   100  <span class="comment">// 线性表存储空间的初始分配量</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT    10　 <span class="comment">// 线性表存储空间的分配增量</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">  ElemType *elem;       <span class="comment">// 存储空间基址</span></div><div class="line">  <span class="keyword">int</span>      length;      <span class="comment">// 当前长度</span></div><div class="line">  <span class="keyword">int</span>      listsize;    <span class="comment">// 当前分配的存储容量</span></div><div class="line">&#125;SqList;</div></pre></td></tr></table></figure><p>线性表插入和删除操作：</p><p><img src="../Pictures/datastructure/insert.png" alt="insert"></p><p>一般情况下，把第$i(1\le i\le n)$个元素之前插入一个元素时，需要将第$n$至第$i$（共$n-i+1$）个元素向后移动一个位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>) <span class="keyword">return</span> ERROR;</div><div class="line">  <span class="keyword">if</span>(L.length&gt;=L.listsize)&#123;       <span class="comment">//当前存储空间已满，增加分配</span></div><div class="line">    newbase = (ElemType *)<span class="built_in">realloc</span>(L.elem,               (L.listsize+LISTINCREMENT)*<span class="keyword">sizeof</span>(ElemType));</div><div class="line">    <span class="keyword">if</span>(!newbase)<span class="built_in">exit</span>(OVERFLOW);   <span class="comment">//存储分配失败</span></div><div class="line">    L.elem = newbase;             <span class="comment">//新基址  </span></div><div class="line">    L.listsize+= LISTINCREMENT;   <span class="comment">//增加爱存储容量</span></div><div class="line">  &#125;</div><div class="line">  q = &amp;(L.elem[i<span class="number">-1</span>]);            <span class="comment">//q为插入位置</span></div><div class="line">  <span class="keyword">for</span>(p = &amp;(L.elem[L.length<span class="number">-1</span>]);p&gt;=<span class="number">1</span>;--p) *(p+<span class="number">1</span>) = *(p);</div><div class="line">                                 <span class="comment">//插入位置及之后的元素右移</span></div><div class="line">  *q = e;　　　　　　　　　　　　　　<span class="comment">//插入e</span></div><div class="line">  ++L.length;                    <span class="comment">//表长增１</span></div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;                               <span class="comment">//时间复杂度Ｏ(n)</span></div></pre></td></tr></table></figure><p>线性表删除操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">ListDelete_Sq</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>) <span class="keyword">return</span> ERROR;</div><div class="line">  p = &amp;(L.elem[i<span class="number">-1</span>]);         <span class="comment">//p被删除元素的位置</span></div><div class="line">  e = *p;                     <span class="comment">//被删除元素的值赋给e</span></div><div class="line">  q = L.elem + L.length<span class="number">-1</span>;    <span class="comment">//表尾元素的位置</span></div><div class="line">  <span class="keyword">for</span>(++p;p&lt;=q;++p) *(p<span class="number">-1</span>) = *p;  <span class="comment">//被删除元素之后的元素左移  </span></div><div class="line">  --L.length;                 <span class="comment">//表长减1  </span></div><div class="line">  <span class="keyword">return</span> Ok;</div><div class="line">&#125;                            <span class="comment">//时间复杂度Ｏ(n)</span></div></pre></td></tr></table></figure><p>案例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> NO;</div><div class="line">    <span class="keyword">int</span> score;</div><div class="line">&#125;ElemType;</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    ElemType elem[MAXSIZE];</div><div class="line">    <span class="keyword">int</span> length;</div><div class="line">&#125;SqList;</div><div class="line"></div><div class="line"><span class="comment">//初始化</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList *pL)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    pL-&gt;length =<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//插入</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertList</span><span class="params">(SqList *pL,ElemType e,<span class="keyword">int</span> i)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(pL-&gt;length &gt;MAXSIZE)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    pL-&gt;elem [i]=e;</div><div class="line">    pL-&gt;length ++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//排序</span></div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">SortScore</span><span class="params">(SqList *pL)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pL-&gt;length ;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;pL-&gt;length ;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(pL-&gt;elem [i].score&lt;pL-&gt;elem [j].score )</div><div class="line">            &#123;</div><div class="line">                ElemType temp=pL-&gt;elem [i];</div><div class="line">                pL-&gt;elem [i]=pL-&gt;elem [j];</div><div class="line">                pL-&gt;elem [j]=temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(SqList *pL,SqList *pS,SqList *T)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i&lt;pL-&gt;length &amp;&amp;j&lt;pS-&gt;length )</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(pL-&gt;elem [i].score &gt;pS-&gt;elem [j].score )</div><div class="line">            T-&gt;elem [k++]=pL-&gt;elem [i++];</div><div class="line">            </div><div class="line">        <span class="keyword">else</span></div><div class="line">    </div><div class="line">            T-&gt;elem [k++]=pS-&gt;elem [j++];</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i&lt;pL-&gt;length )</div><div class="line">        T-&gt;elem [k ++]=pL-&gt;elem [i++ ];</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(j&lt;pS-&gt;length )</div><div class="line">        T-&gt;elem [k ++]=pS-&gt;elem [j ++];    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printf</span><span class="params">(SqList *pL)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pL-&gt;length ;i++)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"(%2d,%2d)\n"</span>,pL-&gt;elem [i].NO ,pL-&gt;elem [i].score );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    SqList L,S,T;</div><div class="line">    ElemType e;</div><div class="line">    InitList(&amp;L);</div><div class="line">    e.NO =<span class="number">5</span>; e.score =<span class="number">60</span>;</div><div class="line">    InsertList(&amp;L,e,<span class="number">0</span>);</div><div class="line">    e.NO =<span class="number">6</span>; e.score =<span class="number">80</span>;</div><div class="line">    InsertList(&amp;L,e,<span class="number">1</span>);</div><div class="line">    e.NO =<span class="number">7</span>; e.score =<span class="number">76</span>;</div><div class="line">    InsertList(&amp;L,e,<span class="number">2</span>);</div><div class="line">    e.NO =<span class="number">8</span>; e.score =<span class="number">50</span>;</div><div class="line">    InsertList(&amp;L,e,<span class="number">3</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"顺序表L:\n"</span>);</div><div class="line">    Printf(&amp;L);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n按照成绩大小排序后的顺序表L：\n"</span>);</div><div class="line">    SortScore(&amp;L);</div><div class="line">    Printf(&amp;L);</div><div class="line"></div><div class="line">    InitList(&amp;S);</div><div class="line">    e.NO =<span class="number">10</span>; e.score =<span class="number">70</span>;</div><div class="line">    InsertList(&amp;S,e,<span class="number">0</span>);</div><div class="line">    e.NO =<span class="number">20</span>; e.score =<span class="number">85</span>;</div><div class="line">    InsertList(&amp;S,e,<span class="number">1</span>);</div><div class="line">    e.NO =<span class="number">30</span>; e.score =<span class="number">75</span>;</div><div class="line">    InsertList(&amp;S,e,<span class="number">2</span>);</div><div class="line">    e.NO =<span class="number">40</span>; e.score =<span class="number">90</span>;</div><div class="line">    InsertList(&amp;S,e,<span class="number">3</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n顺序表S:\n"</span>);</div><div class="line">    Printf(&amp;S);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n按照成绩大小排序后的顺序表S：\n"</span>);</div><div class="line">    SortScore(&amp;S);</div><div class="line">    Printf(&amp;S);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</div><div class="line"></div><div class="line">    InitList(&amp;T);</div><div class="line">    T.length =L.length +S.length ;</div><div class="line">    Merge(&amp;L,&amp;S,&amp;T);</div><div class="line">    Printf(&amp;T);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>线性表的顺序存储结构特点：逻辑关系上相邻的两个单元在物理位置上也相邻。缺点：在作插入或删除操作时，需要移动大量元素。</p><h3 id="线性表的链式表现和实现"><a href="#线性表的链式表现和实现" class="headerlink" title="线性表的链式表现和实现"></a>线性表的链式表现和实现</h3><p>线性表链式存储结构特点：用一组任意的存储单元(连续或不连续)存储线性表的数据元素 。</p><p>如何表示数据元素$a_i$与其直接后继数据元素$a_{i+1}$之间关系:结点｛<strong>本身信息+直接后继的存储位置</strong>｝</p><p>结点包含两个域：数据域＋指针域　　n个结点链结成一个链表。</p><p><img src="../../Pictures/datastructure/list_operate.png" alt="list_operate"></p><blockquote><p>线性单链表：(ZHAO, QIAN, SUN, LI, ZHOU, WU, ZHENG, WANG)</p></blockquote><p><img src="../Pictures/datastructure/linear_list.png" alt="linear_list"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//－－－－－线性表的单链存存储结构－－－－－－</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></div><div class="line">  ElemType        data;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>   *<span class="title">next</span>;</span></div><div class="line">&#125;LNode, *LinkList;</div></pre></td></tr></table></figure><p>$p-&gt;data = a_i$, 则$p-&gt;next-&gt;data = a_{i+1}$。</p><p>GetElem在单链表中的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span>&#123;</div><div class="line">  <span class="comment">//L为带头结点的单链表的头指针。</span></div><div class="line">  <span class="comment">//当第i个元素存在时，其值赋给e并返回OK，否则返回error。</span></div><div class="line">  p = L-&gt;next; j = <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(p&amp;&amp;j&lt;i)&#123;</div><div class="line">    p = p-&gt;next;++j;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(!p||j&gt;i) <span class="keyword">return</span> ERROR;</div><div class="line">  e = p-&gt;data;         <span class="comment">//取第i个元素</span></div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>单链表插入操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</div><div class="line">  <span class="comment">//在带头结点的单链表Ｌ中第i个位置之前插入元素e</span></div><div class="line">  p = L; j = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(p&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;p = p-&gt;next;++j;&#125;  <span class="comment">//寻找第i－１个结点</span></div><div class="line">  <span class="keyword">if</span>(!p||j&gt;i) <span class="keyword">return</span> ERROR;</div><div class="line">  s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode)); <span class="comment">//生成新结点</span></div><div class="line">  s-&gt;data = e; s-&gt;next = p-&gt;next;　　　　<span class="comment">//插入Ｌ中</span></div><div class="line">  p-&gt;next = s;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;　                                 <span class="comment">//O(n)</span></div></pre></td></tr></table></figure><p>单链表删除操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span>&#123;</div><div class="line">  <span class="comment">//在带头结点的单链表Ｌ中删除第i个元素，并由e返回其值</span></div><div class="line">  p = L;j=<span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(p-&gt;next&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;       <span class="comment">//寻找第i个结点，并令p指向其前趋</span></div><div class="line">    p = p-&gt;next;++j;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(!(p-&gt;next)||j&gt;i) <span class="keyword">return</span> ERROR;</div><div class="line">  q = p-&gt;next; p-&gt;next = q-&gt;next;   <span class="comment">//删除并释放结点</span></div><div class="line">  e = q-&gt;data; <span class="built_in">free</span>(q);</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;                                  <span class="comment">//O(n)</span></div></pre></td></tr></table></figure><p>两个有序链表合并为一个有序链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_L</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span></span>&#123;</div><div class="line">  pa = La-&gt;next; pb = Lb-&gt;next;</div><div class="line">  Lc = pc = La;       <span class="comment">//用La的头结点作为Lc的头结点</span></div><div class="line">  <span class="keyword">while</span>(pa&amp;&amp;pb)&#123;</div><div class="line">    <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;</div><div class="line">      pc-&gt;next = pa; pc = pa; pa= pa-&gt;next;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span>&#123;pa-next = pb; pc=pb; pb = pb-&gt;next;&#125;</div><div class="line">  &#125;</div><div class="line">  pc-&gt;next = pa?pa:pb; <span class="comment">//插入剩余段</span></div><div class="line">  <span class="built_in">free</span>(Lb);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>双向链表</strong>：结点有两个指针域，其一指向直接后继，另一指向直接前趋</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//－－－－－线性表的双向链表存储结构－－－－－</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></div><div class="line">  ElemType        data;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>   *<span class="title">prior</span>;</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>   *<span class="title">next</span>;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="../Pictures/datastructure/dulnode.png" alt="dulnode"></p><p>结构特性：$d-&gt;next-&gt;prior = d-&gt;prior-&gt;next = d$&gt;</p><p>双向链表插入操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">ListInsert_DuL</span><span class="params">(DuLinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</div><div class="line">  <span class="comment">//在带头结点的双链循环表Ｌ中第i个位置之前插入元素e</span></div><div class="line">  <span class="keyword">if</span>(!(p = GetElemP_Dul(L,i)))   <span class="comment">//在Ｌ中确定插入位置</span></div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">  <span class="keyword">if</span>(!(s = (DuLinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLNode))))</div><div class="line">    <span class="keyword">return</span> ERROR</div><div class="line">  s-&gt;data = e;</div><div class="line">  s-&gt;prior = p-&gt;prior; p-&gt;prior-&gt;next = s;</div><div class="line">  s-&gt;next = p;         p-&gt;prior = s;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>双向链表删除操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">ListDElete_DuL</span><span class="params">(DuLinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</div><div class="line">  <span class="comment">//删除带头结点的双链循环表Ｌ第i个元素</span></div><div class="line">  <span class="keyword">if</span>(!(p = GetElemP_Dul(L,i)))   <span class="comment">//在Ｌ中确定插入位置</span></div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line"> e = p-&gt;data;</div><div class="line">  p-&gt;prior-&gt;next = p-&gt;next;</div><div class="line">  p-&gt;next-&gt;prior = p-&gt;prior;</div><div class="line">  <span class="built_in">free</span>(p);</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h2&gt;&lt;h3 id=&quot;类型定义&quot;&gt;&lt;a href=&quot;#类型定义&quot; class=&quot;headerlink&quot; title=&quot;类型定义&quot;&gt;&lt;/a&gt;类型定义&lt;/h3&gt;&lt;p&gt;简言之，一个线性表是n个数据元素的有限序列。&lt;/p&gt;
&lt;p&gt;在复杂的线性表中，一个数据元素可由若干个数据项(item)组成。在这种情况下，常把数据元素称为记录(record)，含有大量记录的线性表又称为文件（file）。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ADT List&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//数据对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  D = &amp;#123;a1|a2 belong to ElemSet, i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,....,n, n&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//数据关系&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  R1 = &amp;#123;&amp;lt;ai&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,ai&amp;gt;|ai&lt;span class=&quot;number&quot;&gt;-1.&lt;/span&gt;ai belong to D,i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt;..n&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//基本操作&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  InitList(&amp;amp;L)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//构造一个空的线性表Ｌ&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  DestoryList(&amp;amp;L)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//销毁线性表Ｌ&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ClearList(&amp;amp;L)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//将Ｌ重置为空表&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ListEmpty(L)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//若L为空表，返回True,否则False&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ListLength(L)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//返回L中数据元素个数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  GetElem(L,i,&amp;amp;e)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//用e返回L中第i个数据元素的值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ListInsert(&amp;amp;L,i,e)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//在Ｌ中第i个位置之前插入新的数据元素e，Ｌ的长度加1。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读，线性表" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%EF%BC%8C%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://yoursite.com/2017/12/27/computer-network/"/>
    <id>http://yoursite.com/2017/12/27/computer-network/</id>
    <published>2017-12-27T11:22:47.000Z</published>
    <updated>2017-12-29T12:20:10.128Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h3><p>计算机网络的分类标准很多，比如按拓扑结构、截至交换方式、交换方式以及数据传输率等．</p><h4 id="局域网-LAN"><a href="#局域网-LAN" class="headerlink" title="局域网(LAN)"></a>局域网(LAN)</h4><p>　　指的是范围几百米到几十公里内办公楼群或校园内的计算接相互连接所构成的计算机网络．局域网区别其他网络的主要体现：(1)网络所覆盖的物理范围；(2)网络所使用的传输技术；(3)网络的拓扑结构．</p><p>　　局域网机场使用共享通道，即所以的机器都接在同一条电缆上．</p><p>　　局域网具有不同的拓扑结构．在总线网络中，任何时刻只允许一台机器发送数据，其他所有奇迹处于接受状态．当两台或多台机器想要同时发送数据时必须进行仲裁，仲裁机制可以是集中式也可以是分布式．<strong>以太网是基于共享总线采用分布控制机制的局域网．</strong>在环形网中，数据沿着环不停地旋转．</p><a id="more"></a><h4 id="城域网-MAN"><a href="#城域网-MAN" class="headerlink" title="城域网(MAN)"></a>城域网(MAN)</h4><p>　　城域网可以覆盖距离不远的几栋办公楼，也可以覆盖一座城市；既可以是私人网，也可以是公用网；即可以支持数据和话音传输，也可以与有线电视相连．</p><p>　　城域网的标准名称为分布式队列双总线(DQDB)，其工作范围一般是160km，数据传输率为44.736Mbps. DQDB采用两条单项总线相连，其中每条总线都有一个端接点，各自产生一个53字节的信元流．每个信元都从端接点沿着总线往下传，当它到达终点时，就从总线消失．</p><h4 id="广域网-WAN"><a href="#广域网-WAN" class="headerlink" title="广域网(WAN)"></a>广域网(WAN)</h4><p>　　通常跨接很大的物理范围，如一个国家．广域网包含很多用来运行用户应用程序的机器集合，我们通常把这些机器叫做主机；把这些主机连接在一起的是<strong>通信子网</strong>．通信子网的任务是在主机之间传送报文．通信子网包含两部分：传输信道和转接设备．传输信道用于在机器间传送数据，转接设备是专用计算机，用来连接两条或多条传输线．当数据从一条输入信道到达后，转接设备必须选择一条输出信道，把数据继续向前发送．</p><h4 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h4><p>　　世界上有许多网络，不同网络的物理结构、协议和所采用的标准是各不相同的．如果连接到不同网络的用户需要进行相互通信，就需要将这些不兼容的网络通过称为网关的机器设备连接起来，并有网管完成相应的１转换功能．多个网络相互连接构成的集合称为互联网．</p><h4 id="无线网"><a href="#无线网" class="headerlink" title="无线网　"></a>无线网　</h4><p>　　无线网易于安装和使用，但是数据传输率一般较低，远低于有限局域网；另外无线局域网的误码率也比较高，而且站点之间相互干扰比较厉害．</p><ul><li><strong>要想让两台计算机进行通信，必须是它们采用相同的信息交换规则．我们吧计算机网络中用于规定信息的格式以及如何发送和接收信息的一套规则称为网络协议或通信协议</strong>．</li></ul><h3 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分　"></a>网络层次划分　</h3><p>　　为了是不用计算机厂家生产的计算机能够相互通信，更大范围内建立计算机网络，国际标准化组织(ISO)在1978年提出＂开放系统互联参考模型OSI/RM模型（Open System Interconnection/Reference Model）＂它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层．第四层完成数据传送服务，上面三层面向用户．</p><p>　　除了标准的OSI七层模型之外，常见的网络层此划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示：</p><p><img src="http://images2015.cnblogs.com/blog/764050/201509/764050-20150904094019903-1923900106.jpg" alt="通信协议"></p><h4 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h4><p>　　TCP/IP协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开TCP/IP协议。</p><p><img src="http://images2015.cnblogs.com/blog/764050/201509/764050-20150904095142060-1017190812.gif" alt=""></p><p><strong>物理层(Physical Layer)</strong></p><p>　　激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性．<strong>该层为上层协议提供了传输数据的可靠物理媒体，简单的说，物理层确保原始的数据可在各种物理媒体上传输</strong>．物理层记住两个重要的设备名称：中继器和集线器．</p><p><strong>数据链路层(Data Link Layer)</strong></p><p>　　数据链路层在物理层提供的服务的基础上想网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层．未达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路从中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接受方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理．数据链路层在不可靠的物理介质上提供可靠的传输．该层的作用包括：物理层地址寻址、数据的成帧、流量控制、数据的检错、重发等．</p><blockquote><p>数据链路层为网络层提供可靠的数据传输．</p><p>基本数据单位为帧．</p><p>主要的协议为以太网协议．</p><p>两个重要的设备名称：网桥和交换机．</p></blockquote><p><strong>网络层（Network Layer）</strong></p><p>　　网络层实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的选择、保持和终止等．它提供的服务使传输层不元哦了解网络中的数据传输和交换技术．＂路劲选择、路由和逻辑寻址＂．</p><p>　　网络层中涉及众多的协议，其中包括TCP/IP的核心协议——IP协议．IP协议非常简单，仅仅提供不可靠、无连接的传送服务．IP协议的主要功能有：</p><ul><li>无连接数据报传输、数据报路由选择和差错控制，与IP协议配套使用实现其功能的还有地址解析协议ARP，逆地址解析协议RARP、因特网报文协议ICMP、因特网管理协议IGMP．</li></ul><p><strong>1&gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；</strong></p><p><strong>2&gt; 基本数据单位为IP数据报；</strong></p><p><strong>3&gt; 包含的主要协议：</strong></p><ul><li><strong>IP协议（Internet Protocol，因特网互联协议）;</strong></li><li><strong>ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;</strong></li><li><strong>ARP协议（Address Resolution Protocol，地址解析协议）;</strong></li><li><strong>RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。</strong></li></ul><p><strong>4&gt; 重要的设备：路由器。</strong></p><p><strong>传输层（Transport Layer）</strong></p><p>　　第一个端到端，即主机到主机的层次．传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输．此外传输层还要处理端到端的差错控制和流量控制问题．</p><p>　　传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输．在这一层，信息传送的协议数据单元称为段或报文．</p><p>　　网络协议值根据网路地址将源结点出发的数据包传送到目的终点，而传输层则负责将数据可靠地传送到相应的端口．</p><ul><li><strong>传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题．</strong></li><li><strong>包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）．</strong></li><li><strong>重要设备：网关．</strong></li></ul><p><strong>会话层（Session Layer）</strong></p><p>会话层管理主机之间的会话进程，负责建立、管理、终止进程之间的回话．会话层还利用在数据中插入校检点来实现数据的同步．</p><p><strong>表示层（Presentation Layer）</strong></p><p>表示层岁上层数据或信息进行狡猾以保证一个主机信息应用层信息可以被另外一个主句的应用程序来理解．表示层的数据转换包括数据的加密、压缩、格式转换等．</p><p><strong>应用层（Application Layer）</strong></p><p>为操作系统或网络应用程序提供访问网络服务的接口．</p><p>会话层、表示层和应用层重点：</p><ul><li><strong>数据传输基本单位为报文</strong></li><li><strong>包含的主要协议：FTP（文件传送协议）、Telnet(远程登录协议)、DNS(域名解析协议)、SMTP(邮件传送协议)、POP3协议(邮局协议)、HTTP协议（Hyper Text Transfer Protocol）．</strong></li></ul><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p><strong>网络地址</strong></p><p>IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。</p><p><strong>广播地址</strong></p><p>广播地址通常称为直接广播地址，是为了区分首先广播地址。</p><p>广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1.当向某个网络的广播地址发送消息时，该网络的所有主机都能接收到该广播的地址。</p><p><strong>组播地址</strong></p><p>D类地址就是组播地址。</p><ul><li><p>A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255;</p></li><li><p>B类地址以10开头，前两个字节作为网络号，地址范围为：128.0.0.0~191.255.255.255;</p></li><li><p>C类地址以110开头，前三个字节作为网络号，地址范围为：192.0.0.0~223.255.255.255;</p></li><li><p>D类地址以1110开头，地址范围为：224.0.0.0~239.255.255.255,D类地址作为组播地址（一对多通信）；</p></li><li><p>E类地址以1111开头，地址范围为：240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用</p><p>​</p></li></ul><p>A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><p><strong>255.255.255.255</strong></p><p>该IP四肢指的是受限的广播地址。首先广播地址与一般广播地址（直接广播地址）的区别在于，受限广播只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址即可在本地广播，也可跨网段广播。例如主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能接收到该数据包；若发送受限广播数据包，则不能收到。受限的广播不能通过路由器。</p><p><strong>0.0.0.0</strong></p><p>常用于寻找自己的IP地址，例如在我们的RARP,BOOTP和DHCP协议中，若某个未知的IP地址的无盘机想要知道自己的IP地址，他就以255.255.255.255为目的的地址，向本地范围（具体而言就是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p><p><strong>回环地址</strong></p><p>127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用语对本机的测试，用的最多的是127.0.0.0</p><p><strong>A,B,C类私有地址</strong></p><p>私有地址也叫专用地址，它们不会在全球使用，只具体本地意义。</p><ul><li>A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255</li><li>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</li><li>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168..255.255</li></ul><h3 id="子掩码及网络划分"><a href="#子掩码及网络划分" class="headerlink" title="子掩码及网络划分"></a>子掩码及网络划分</h3><p>　　IPv4网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供不同规模的用户群使用，为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。</p><p><strong>子掩码</strong></p><p>　　子掩码是标志两个IP地址是否同属于一个子网的，也是32为二进制地址，其每一个为1代表改为是网络位，为0代表主机位。他和IP地址一样也是使用点式十进制来表示。如果两个IP地址在子网掩码的按位与的计算下得到相同结果，即表明它们共属于同一子网。</p><p>　　<strong>在计算子网掩码时，我们要注意IP地址中的保留地址，即“0”地址和广播地址，它们是指主机地址或网络地址全为0或1时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。</strong></p><p><strong>子网掩码的计算：</strong></p><p>　　对于无须再划分成子网的IP地址来说，其子网掩码非常简单，即按照其定义可写出：如某B类IP地址为10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果他是一个C类地址，则其子网掩码为255.255.255.0。</p><p>子网掩码和网络划分常见面试考题：</p><p><strong>利用子网数来计算</strong></p><p>在求子网掩码之前必须搞清楚要划分的子网数目，以及每个子网内所需主机数目。</p><p>（１）将子网数目转化为二进制表示：</p><p>如欲将B类IP地址168.195.0.0划分成27个子网：27=11011；</p><p>（２）取得该耳机在南海的位数，为N；</p><p>该耳机在南海为五位数，N=5</p><p>（３）取IP地址的类子网掩码，将主机地址部分的前N位置1即可以得出该IP地址划分子网的子网掩码。</p><p>将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0</p><p><strong>利用主机数来计算</strong></p><p>如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台：</p><p>(1) 将主机数目转化为二进制来表示；</p><p>　700=1010111100；</p><p>(２)如果主机数小与或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数为N，这里肯定N<8。如果大于254，则n>8，这就是说主机地址将占据不止8位；</8。如果大于254，则n></p><p>该二进制是十位数，N=10</p><p>(3) 使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。</p><p>将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后 10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。</p><p><strong>根据每个网络的主机数量进行子网地址的规划和计算子网掩码</strong></p><p>比如一个子网有10台主机，那么对于这个子网需要的IP地址是：10+1+1+1=13</p><p><strong>加的第一个1是这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址</strong></p><p>因为13小于16（16等于2的4次方），所以主机为为4位，而256－16＝240，所以该子网掩码为255.255.255.240。如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。</p><h3 id="ARP-RARP协议"><a href="#ARP-RARP协议" class="headerlink" title="ARP/RARP协议"></a>ARP/RARP协议</h3><p>　　地址解析协议，即ARP(Address Resolution Protocol)，是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求是直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上，网络的主机可以自助发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其计入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</p><p><strong>ARP工作流程举例：</strong></p><p>主机B的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01;</p><p>主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02;</p><p>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p><ul><li>根据主机A上的路由表的内容，IP确定用于访问主机B的转发IP协议地址是192.168.1.2。然后Ａ主机在自己本地ARP缓存中检查主机Ｂ的匹配MAC地址。</li><li>如果主机Ａ在ARP缓存中没有找到映射，他将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机Ａ的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台诸暨都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</li><li>主机Ｂ确定ARP请求中的IP地址与自己的IP地址匹配，则将主机Ａ的IP地址和MAC地址映射田间道本地的ARP缓存中。</li><li>主机Ｂ将包含其MAC地址的ARP回复消息直接发送回去主机Ａ。</li><li>当主机Ａ收到从主机Ｂ发来的ARP回复消息时，会用主机Ｂ的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机Ｂ的MAC地址一旦确定，主机Ａ就能想主机Ｂ发送IP通信了。</li></ul><p>　　<strong>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址。</strong>比如局域网中的一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答.</p><p>　　RARP协议工作流程：</p><ul><li>给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配的一个IP地址</li><li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址相应的IP地址</li><li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用</li><li>如果不存在，RARP服务器对此不作任何的响应</li><li>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</li></ul><h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><p>常见的路由选择协议有：RIP协议、OSPF协议。</p><ul><li><strong>RIP**</strong>协议** ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</li><li><strong>OSPF**</strong>协议** ：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</li></ul><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><p>　　<strong>TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。</strong></p><p>　　IP层接收由更底层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层－－TCP或UDP；相反IP层也把从TCP或UDP层接收来的数据包传送到更低层．IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者没有被破坏，IP数据包中含义发送它的主机地址（源地址）和接收它主机的地址（目的地址）．</p><p>　　TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯．TCP提供的是一种可靠的数据流业务，采用＂带重穿的肯定确认＂技术来实现传输的可靠性．TCP还采用一种称为＂滑动窗口＂的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送放的发送速度．</p><p><strong>TCP报文首部格式：</strong></p><p><img src="http://images2015.cnblogs.com/blog/764050/201509/764050-20150904110054856-961661137.png" alt="报文首部格式"></p><blockquote><p><strong>TCP协议的三次握手和四次挥手：</strong></p></blockquote><p><img src="http://images2015.cnblogs.com/blog/764050/201509/764050-20150904110008388-1768388886.gif" alt="三次握手"></p><ul><li><strong>seq</strong>:”sequance”序列号；<strong>ack</strong>:”acknowledge”确认号；</li><li><strong>SYN</strong>:”synchronize”请求同步标志；<strong>ACK</strong>:”acknowledge”确认标志”<strong>；FIN</strong>：”Finally”结束标志。</li></ul><p><strong>TCP连接建立过程：</strong>首先Client端发送链接请求报文，Server段接收连接后回复ACK报文后也向Server段发ACK报文，并分配资源，这样TCP连接就建立了．</p><p><strong>TCP连接断开过程：</strong>假设Client端发起中断请求连接，也就是发送FIN报文．Server段收到FIN报文后，意思是说＂我Client端没有数据要发给你了＂，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据．所以你先发送ACK，＂告诉Client端，你的请求我收到了，但是我还没准备好，请继续等我的消息＂．这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文．当Server端确定数据已发送完成，则向Client端发送FIN报文，＂告诉Client端，好了，我这边数据发完了，准备好关闭连接了＂．Client端收到FIN报文还有，＂就知道可以关闭连接了，蛋挞还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传．＂，Server端收到ACK后，＂就知道可以断开连接了＂．Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了．OK，TCP连接就这样关闭了</p><p><strong>为什么需要三次握手</strong></p><p>　　在只有两次＂握手＂的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报文丢失了，故Client端不得不重新发送一遍；这格式化Server端仅收到一个连接请求，因此可以正常的建立连接．但是，有时候Client端重新发送请求不是因为数据报文丢失了，而是有可能数据传输过程因为网络并发亮很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据．．．问题就在这里，Client端实际上只有一次请求，而Server端却有2个相应，极端的情况下由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费．因此＂三次握手＂很有必要！</p><p><strong>为什么要四次挥手？</strong></p><p>　　试想一下，假如现在你是客户端，你想要断开与Server的所有连接该怎么做？第一步，你自己现停止向Server端发送数据，并等待Server的回复．但事情还没完，虽然你自身不往Server发送数据，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认．其实，说白了就是保证双方的一个合约的完整执行！</p><p>　　使用TCP的协议：FTP(文件传输协议)、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。</p><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>　　<strong>UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送，UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中需要程序员编程验证．</strong></p><p>　　UDP和TCP位于同一层，但它不管数据包的顺序、错误或重发．因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询－－应答的服务，例如NFS．相对与FTP或Telnet，这些服务需要交换的信息量较小。</p><p>　　每个UDP报文分UDP报头和UDP数据区两部分．报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度及校检值．UDP报头由四个域组成，其中每个域各占用2个字节，具体如下：</p><ul><li>源端口号</li><li>目标端口号</li><li>数据报长度</li><li>校检值</li></ul><p>使用UDP协议包括：TFTP(简单文件传输协议)、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP．</p><p><strong>TCP和UDP的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务．</strong></p><h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><p>　　DNS是域名系统（DomainNameSystem）的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为<strong>将URL转换为IP地址</strong>．域名是由圆点分开一串单词或缩写组成，每一个域名都对应一个唯一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器．DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务．</p><h3 id="NAT协议"><a href="#NAT协议" class="headerlink" title="NAT协议"></a>NAT协议</h3><p>　　NAT网络地址转换(Network Address Translation)属于接入广域网（WAN）技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，他被广泛应用与各种类型Internet接入方式和各种类型的网络中．原因很简单，NAT不仅完美地解决了IP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机．</p><h3 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3><p>　　DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段．</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>　　超文本传输协议（HTTP, HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议．所有的WWW文件必须遵守这个标准．</p><p>　　HTTP包括哪些请求：</p><ul><li>GET:　请求读取由URL所标志的信息</li><li>POST:　给服务器添加信息（如注释）</li><li>PUT：　在给定的URL下存储一个文档</li><li>DELETE：　删除给定的URL所标志的资源</li></ul><p><strong>HTTP中，POST与GET的区别</strong></p><ul><li>GET是服务器上获取数据，POST是向服务器传送数据</li><li>GET是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到</li><li>GET传送的数据量小，不能大于2KB；POST传送的数据量较大，一般被默认不受限制</li><li>根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的</li></ul><p>所谓的<strong>安全的</strong>意味着该操作用于获取信息而非修改信息．换句话说，GET请求一般不应该产生副作用．就是说，它仅仅是获取资源信息，就像是数据库查询一样，不会修改、增加数据，不会影响资源的状态</p><p><strong>幂等</strong>的意味着对同一URL的多个请求应该返回同样的结果</p><h3 id="一个生动形象的例子"><a href="#一个生动形象的例子" class="headerlink" title="一个生动形象的例子"></a>一个生动形象的例子</h3><p><strong>在浏览器中输入 <a href="http://www.baidu.com/" target="_blank" rel="external">www.baidu.com </a> 后执行的全部过程</strong></p><p>　　现在假设如果我们在客户端浏览器输入<a href="http://www.baidu.com，而baidu.com为要访问的服务器，下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：" target="_blank" rel="external">http://www.baidu.com，而baidu.com为要访问的服务器，下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：</a></p><ul><li>客户端浏览器通过DNS解析到www.baidu.com的IP地址为220.181.27.48，通过这个IP地址客户端到服务器的路径．客户端浏览器发起一个HTTP会话到220.181.27.48，然后通过TCP进行封装数据包，输入到网络层．</li><li>在客户端的传输层，把HTTP会话请求分成报文段，天剑源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口．然后使用IP层的IP地址查找目的端．</li><li>客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多描述，无非就是通过查找路由表决定通过那个路径到达服务器．</li><li>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包就可以传输了，然后发送IP数据包到达服务器的地址．</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;计算机网络分类&quot;&gt;&lt;a href=&quot;#计算机网络分类&quot; class=&quot;headerlink&quot; title=&quot;计算机网络分类&quot;&gt;&lt;/a&gt;计算机网络分类&lt;/h3&gt;&lt;p&gt;计算机网络的分类标准很多，比如按拓扑结构、截至交换方式、交换方式以及数据传输率等．&lt;/p&gt;
&lt;h4 id=&quot;局域网-LAN&quot;&gt;&lt;a href=&quot;#局域网-LAN&quot; class=&quot;headerlink&quot; title=&quot;局域网(LAN)&quot;&gt;&lt;/a&gt;局域网(LAN)&lt;/h4&gt;&lt;p&gt;　　指的是范围几百米到几十公里内办公楼群或校园内的计算接相互连接所构成的计算机网络．局域网区别其他网络的主要体现：(1)网络所覆盖的物理范围；(2)网络所使用的传输技术；(3)网络的拓扑结构．&lt;/p&gt;
&lt;p&gt;　　局域网机场使用共享通道，即所以的机器都接在同一条电缆上．&lt;/p&gt;
&lt;p&gt;　　局域网具有不同的拓扑结构．在总线网络中，任何时刻只允许一台机器发送数据，其他所有奇迹处于接受状态．当两台或多台机器想要同时发送数据时必须进行仲裁，仲裁机制可以是集中式也可以是分布式．&lt;strong&gt;以太网是基于共享总线采用分布控制机制的局域网．&lt;/strong&gt;在环形网中，数据沿着环不停地旋转．&lt;/p&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读，计算机网络" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>数据预处理</title>
    <link href="http://yoursite.com/2017/12/27/data-preconfig/"/>
    <id>http://yoursite.com/2017/12/27/data-preconfig/</id>
    <published>2017-12-27T09:39:25.000Z</published>
    <updated>2018-01-03T13:27:22.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>机器学习中，对于输入特征做归一化预处理操作是最常见的步骤．图像处理中，图像的每个像素信息同样可以看做一种特征．在实践中，对每个特征减去平均值来中心化数据(mean normalization)．卷积神经网络中数据预处理通常是计算<strong>训练集图像像素均值</strong>，之后在处理训练集、验证集和测试集图像时需要分别减去该均值．减均值操作原理：默认自然图像是一类平稳的数据分布（数据在每一个唯独的统计都服从相同分布），在每个样本上减去数据的统计平均值（逐样本计算），移除共同部分，凸显个体差异</p><a id="more"></a><h3 id="网络参数初始化"><a href="#网络参数初始化" class="headerlink" title="网络参数初始化"></a>网络参数初始化</h3><p>神经网络模型一般依靠随机梯度下降法进行模型训练和参数更新，网络的最终性能与收敛得到的最优解直接相关，而收敛效果实际上很大成都取决于网络参数的初始化．下面介绍几种初始化方式．</p><ul><li>全零初始化</li></ul><p>通过合理的数据预处理和规范化，当网络达到稳定状态时，参数在理想情况下应该保持正负各半的状态（期望为０）．因此，可以干脆将所有参数初始化为０（此时参数期望也为０）．</p><ul><li>随机初始化</li></ul><p>将参数随机设定为接近0的一个很小的随机数(有正有负)．随机参数服从高斯分布或菊云分布都是比较有效的初始化方式．为解决网络输出数据分布的方差会随着输入神经元个数改变，需要在初始化的同时加上对方差大小的规范化．</p><ul><li>预训练模型参数初始化</li></ul><p>将预训练模型的参数作为新任务模型的参数初始化．</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据预处理&quot;&gt;&lt;a href=&quot;#数据预处理&quot; class=&quot;headerlink&quot; title=&quot;数据预处理&quot;&gt;&lt;/a&gt;数据预处理&lt;/h3&gt;&lt;p&gt;机器学习中，对于输入特征做归一化预处理操作是最常见的步骤．图像处理中，图像的每个像素信息同样可以看做一种特征．在实践中，对每个特征减去平均值来中心化数据(mean normalization)．卷积神经网络中数据预处理通常是计算&lt;strong&gt;训练集图像像素均值&lt;/strong&gt;，之后在处理训练集、验证集和测试集图像时需要分别减去该均值．减均值操作原理：默认自然图像是一类平稳的数据分布（数据在每一个唯独的统计都服从相同分布），在每个样本上减去数据的统计平均值（逐样本计算），移除共同部分，凸显个体差异&lt;/p&gt;
    
    </summary>
    
      <category term="论文" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="论文，数据预处理" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%EF%BC%8C%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据扩充</title>
    <link href="http://yoursite.com/2017/12/27/data-augmentation/"/>
    <id>http://yoursite.com/2017/12/27/data-augmentation/</id>
    <published>2017-12-27T05:20:58.000Z</published>
    <updated>2018-01-10T14:28:22.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据扩充"><a href="#数据扩充" class="headerlink" title="数据扩充"></a>数据扩充</h3><p>深度卷积网络自身拥有强大的表达能力，网络本身更需要大量的数据来驱动模型训练，否则极有可能陷入过拟合的窘境．实际中，并不是所有数据集都拥有海量样本．因此，在实践中数据扩充是非常有必要的．有效的数据扩充不仅能扩充训练样本数量，还能增加训练样本额多样性，一方面可以避免过拟合，另一方面提升模型的性能．</p><a id="more"></a><h4 id="简单的数据扩充方式"><a href="#简单的数据扩充方式" class="headerlink" title="简单的数据扩充方式"></a>简单的数据扩充方式</h4><p>在数据扩充方面，简单的方法有图像水平翻转、随机扣取、尺寸变换和旋转．在此基础上，对原图或已变化的图像进行色彩抖动也是一种常用的数据扩充手段．</p><h4 id="特殊的数据扩充方式"><a href="#特殊的数据扩充方式" class="headerlink" title="特殊的数据扩充方式"></a>特殊的数据扩充方式</h4><ul><li><strong>Fancy PCA</strong></li></ul><p>Fancy PCA首先对所有训练数据的R,G,B像素值进行主成分分析（PCA）操作，得到对应的特征向量和特征值,然后根据特征向量和特征值可以计算一组随机值，将其作为扰动加到原像素值中即可．</p><ul><li>监督式数据扩充</li></ul><p>借助图像标记信息的新型数据扩充方式．首先根据元数据训练一个分类的初始模型，利用该模型对每张生成对应的特征图或热力图．这张图可指示图像区域与场景标记之间的相关概率，之后根据此概率映射回原图选择较强相关的图像区域作为扣取的图像块．适用于高层予以图像分类任务．</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> numpy</div><div class="line"><span class="keyword">import</span> torch</div><div class="line"><span class="keyword">from</span> torchvision.transforms <span class="keyword">import</span> *</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomErasing</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, probability=<span class="number">0.5</span>, sl=<span class="number">0.02</span>, sh=<span class="number">0.4</span>,  r1 = <span class="number">0.3</span>, mean=[<span class="number">0.4914</span>, <span class="number">0.4822</span>, <span class="number">0.4465</span>])</span>:</span></div><div class="line">        self.probability = probability</div><div class="line">        self.sl = sl</div><div class="line">        self.sh = sh</div><div class="line">        self.r1 = r1</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, img)</span>:</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> random.uniform(<span class="number">0</span>, <span class="number">1</span>) &gt; self.probability:</div><div class="line">            <span class="keyword">return</span> img</div><div class="line"></div><div class="line">        <span class="keyword">for</span> attempt <span class="keyword">in</span> range(<span class="number">100</span>):</div><div class="line">            area = img.size()[<span class="number">1</span>] * img.size()[<span class="number">2</span>]</div><div class="line">       </div><div class="line">            target_area = random.uniform(self.sl, self.sh) * area</div><div class="line">            aspect_ratio = random.uniform(self.r1, <span class="number">1</span>/self.r1)</div><div class="line"></div><div class="line">            h = int(round(math.sqrt(target_area * aspect_ratio)))</div><div class="line">            w = int(round(math.sqrt(target_area / aspect_ratio)))</div><div class="line"></div><div class="line">            <span class="keyword">if</span> w &lt;= img.size()[<span class="number">2</span>] <span class="keyword">and</span> h &lt;= img.size()[<span class="number">1</span>]:</div><div class="line">                x1 = random.randint(<span class="number">0</span>, img.size()[<span class="number">1</span>] - h)</div><div class="line">                y1 = random.randint(<span class="number">0</span>, img.size()[<span class="number">2</span>] - w)</div><div class="line">                <span class="keyword">if</span> img.size()[<span class="number">0</span>] == <span class="number">3</span>:</div><div class="line">                    img[<span class="number">0</span>, x1:x1+h, y1:y1+w] = self.mean[<span class="number">0</span>]</div><div class="line">                    img[<span class="number">1</span>, x1:x1+h, y1:y1+w] = self.mean[<span class="number">1</span>]</div><div class="line">                    img[<span class="number">2</span>, x1:x1+h, y1:y1+w] = self.mean[<span class="number">2</span>]</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    img[<span class="number">0</span>, x1:x1+h, y1:y1+w] = self.mean[<span class="number">0</span>]</div><div class="line">                <span class="keyword">return</span> img</div><div class="line">        <span class="keyword">return</span> img</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据扩充&quot;&gt;&lt;a href=&quot;#数据扩充&quot; class=&quot;headerlink&quot; title=&quot;数据扩充&quot;&gt;&lt;/a&gt;数据扩充&lt;/h3&gt;&lt;p&gt;深度卷积网络自身拥有强大的表达能力，网络本身更需要大量的数据来驱动模型训练，否则极有可能陷入过拟合的窘境．实际中，并不是所有数据集都拥有海量样本．因此，在实践中数据扩充是非常有必要的．有效的数据扩充不仅能扩充训练样本数量，还能增加训练样本额多样性，一方面可以避免过拟合，另一方面提升模型的性能．&lt;/p&gt;
    
    </summary>
    
      <category term="论文" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="论文，数据扩充" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%89%A9%E5%85%85/"/>
    
  </entry>
  
  <entry>
    <title>Sort_Algorithms</title>
    <link href="http://yoursite.com/2017/12/26/Sort-Algorithms/"/>
    <id>http://yoursite.com/2017/12/26/Sort-Algorithms/</id>
    <published>2017-12-26T11:20:38.000Z</published>
    <updated>2017-12-30T02:01:04.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　查找和排序是算法的入门知识，因为实现代码较短，应用较常见．面试中经常会问到排序算法及相关的问题．一般在面试中最常考的是快速排序和归并排序，并且要求现场写出这两种排序的代码．对这两种排序的代码一定要信手拈来才行。还有插入排序、冒泡排序、堆排序、基数排序、桶排序等。面试官对于这些排序可能会要求比较各自的优劣、各种算法的思想及其使用场景。还有要会分析算法的时间和空间复杂度。通常查找和排序算法的考察是面试的开始，如果这些问题回答不好，估计面试官都没有继续面试下去的兴趣都没了。所以想开个好头就要把常见的排序算法思想及其特点要熟练掌握，有必要时要熟练写出代码。接下来我们就分析一下常见的排序算法及其使用场景。</p><a id="more"></a><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>　　冒泡排序是最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此二得名．举个例子：对5,3,8,6,4这个无序序列进行冒泡排序．首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6,3和4无需交换。5和3交换，变成3,5,4,8,6,3.这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列依次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为<strong>O(n^2)</strong>。</p><p>C++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> data[<span class="number">1000</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_sort</span><span class="params">(<span class="keyword">int</span> *d, <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;n; k++)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i＜n; i++)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">if</span>(d[i]&lt;d[i<span class="number">-1</span>])</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">int</span> temp = d[i];</div><div class="line">        d[i] = d[i<span class="number">-1</span>];</div><div class="line">        d[i<span class="number">-1</span>] = temp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</div><div class="line">  &#123;</div><div class="line">    data[i] = rand();</div><div class="line">  &#125;</div><div class="line">  Bubble_sort(data, <span class="number">1000</span>);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, data[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>java实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble_sort</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Bubble_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length = <span class="number">0</span>)</div><div class="line">      <span class="keyword">return</span> ; </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr.length; j++)</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</div><div class="line">        &#123;</div><div class="line">          <span class="keyword">int</span> temp = arr[j];</div><div class="line">          arr[j] = arr[j+<span class="number">1</span>];</div><div class="line">          arr[j+<span class="number">1</span>] = temp;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的思想和冒泡排序有些类似，都是在一次排序后吧最小的元素放在最前面．但是过程不同，冒泡排序是通过相邻的比较和交换，选择排序是通过对整体的选择．举个例子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，依次排序后就编程3,5,8,6,4.对剩下的序列一次进行选择和交换，最终会得到一个有序序列．选择排序可以看作是冒泡排序的优化，其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数．选择排序的时间复杂度为<strong>O(n^2)</strong>。</p><p>C++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT_COUNT 10000;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, k, d[ELEMENT_COUNT];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">int</span> x = d[r];</div><div class="line">  <span class="keyword">int</span> j = l<span class="number">-1</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=r; i++)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span>(d[i]&lt;=x)</div><div class="line">    &#123;</div><div class="line">      j++;</div><div class="line">      <span class="keyword">int</span> temp = d[i];</div><div class="line">      d[i] = d[j];</div><div class="line">      d[j] = temp;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> j+<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</div><div class="line">  <span class="keyword">while</span>(l&lt;r)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">int</span> par = partition(l, r);</div><div class="line">    <span class="keyword">if</span>(par &lt; k)</div><div class="line">    &#123;</div><div class="line">      l = par;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(par&gt;k)</div><div class="line">    &#123;</div><div class="line">      r = par<span class="number">-2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> d[par<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> d[l];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">inr <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> ktg = select(k);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, kth);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>java实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Select_sort</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Select_sort</span><span class="params">(<span class="keyword">int</span>[], arr)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length = <span class="number">0</span>)</div><div class="line">      <span class="keyword">return</span> ; </div><div class="line">    <span class="keyword">int</span> minIndex = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)  <span class="comment">//只需要比较n-1次</span></div><div class="line">    &#123;</div><div class="line">      minIndex = i;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++)  </div><div class="line">      &#123;                          <span class="comment">//从i+1开始比较，因为minIndex默认为i了，i就没必要比了。</span></div><div class="line">        <span class="keyword">if</span>(arr[j]&lt;arr[minIndex])</div><div class="line">        &#123;</div><div class="line">          minIndex = j;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(minIndex != i)　　　<span class="comment">//如果minIndex不为i，说明找到了更小的值，交换之。</span></div><div class="line">      &#123;</div><div class="line">        <span class="keyword">int</span> temp = arr[i];</div><div class="line">        arr[i] = arr[minIndex];</div><div class="line">        arr[minIndex] = temp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序表示通过交换位置而是通过比较找到合适的位置插入元素来达到怕徐的目的．举个例子：对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一位数的位置是正确的，然后3要插到5前面，把5后移一位，变成3,5,8,6,4.然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序。简单插入排序的时间复杂度也是<strong>O(n^2)</strong>。</p><p>C++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT_COUNT 10000;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, d[ELEMENT_COUNT];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insertion_sort</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">if</span>(d[j]&gt;d[j+<span class="number">1</span>])</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">int</span> temp = d[j];</div><div class="line">        d[j] = d[j+<span class="number">1</span>];</div><div class="line">        d[j+<span class="number">1</span>] = temp;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span></div><div class="line">      &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d[i]);</div><div class="line">  &#125;</div><div class="line">  Insertion_sort();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i0; i&lt;n; i++)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, d[i])</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span> ;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>java实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion_sort</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Insertion_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span></div><div class="line"><span class="function">  </span>&#123;                              <span class="comment">//假设第一个数位置时正确的；要往后移，必须要假设第一个。</span></div><div class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</div><div class="line">      <span class="keyword">return</span> ; </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.lengt; i++)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">int</span> j = i;</div><div class="line">      <span class="keyword">int</span> target = arr[i];   <span class="comment">//待插入的</span></div><div class="line">      <span class="comment">//后移</span></div><div class="line">      <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; target &lt; arr[j-<span class="number">1</span>])</div><div class="line">      &#123;</div><div class="line">        arr[j] = arr[j-<span class="number">1</span>];</div><div class="line">        j--;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="comment">//插入</span></div><div class="line">      arr[j] = target;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>在实际应用中，快速排序是表现最好的排序算法．快速排序思想来自于冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换大数和小数，这样一来不仅吧小数冒泡到上面同时也把大数沉到下面．</p><p>举个例子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。</p><ul><li>5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。</li><li>5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。</li><li>5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。</li><li>4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。</li></ul><p>上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。</p><p>快速排序是不稳定的，其时间平均时间复杂度是<strong>O(nlgn)</strong>。</p><p>C++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ELEMENT_COUNT 1000000</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> d[MAX_ELEMENT_COUNT];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qucik_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">if</span>(l&lt;r)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">int</span> x = d[r];</div><div class="line">    <span class="keyword">int</span> j= l<span class="number">-1</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=r; i++)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">if</span>(d[i]&lt;=x)</div><div class="line">      &#123;</div><div class="line">        j++;</div><div class="line">        <span class="keyword">int</span> temp = d[i];</div><div class="line">        d[i] = d[j];</div><div class="line">        d[j] = temp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    Qucik_sort(l, j<span class="number">-1</span>);</div><div class="line">    Qucik_sort(j+<span class="number">1</span>, r)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_ELEMENT_COUNT; i++)</div><div class="line">&#123;</div><div class="line">d[i] = rand();</div><div class="line">&#125;</div><div class="line"></div><div class="line">Qucik_sort(<span class="number">0</span>, MAX_ELEMENT_COUNT - <span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_ELEMENT_COUNT; i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, d[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>java实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick_sort</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment"> * 从left到right排序数组array</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></div><div class="line"><span class="comment"> */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">int</span> pivotkey = arr[left];</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(left&lt;right)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[right]&gt;=pivotkey)</div><div class="line">        right--;</div><div class="line">      arr[left] = arr[right]; <span class="comment">//把小的移动到左边</span></div><div class="line">      <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[left]&lt;=pivotkey)</div><div class="line">        left++;</div><div class="line">      arr[right] = arr[left]; <span class="comment">//把大的移动到右边</span></div><div class="line">    &#125;</div><div class="line">    arr[left] = pivotkey; <span class="comment">//最后把pivot赋值到中间</span></div><div class="line">    <span class="keyword">return</span> left;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">     * 递归划分子序列</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></div><div class="line"><span class="comment">     */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">if</span>(left &gt;= right)</div><div class="line">      <span class="keyword">return</span> ;</div><div class="line">    <span class="keyword">int</span> pivotPos = partition(arr, left, right);</div><div class="line">    quick_sort(arr, left, pivotPos-<span class="number">1</span>);</div><div class="line">    quick_sort(arr, pivotPos+<span class="number">1</span>, right);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</div><div class="line">      <span class="keyword">return</span> ;</div><div class="line">    quick_sort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  　　</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是借助堆来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。</p><p>　　首先，实现堆排序需要解决两个问题：</p><pre><code>  　　1. 如何由一个无序序列键成一个堆？  　　2. 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？</code></pre><p>　　第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。</p><p>　　第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。</p><p>　　从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举个栗子：</p><p>49,38,65,97,76,13,27,49序列的堆排序建初始堆和调整的过程如下：</p><p><img src="http://images2015.cnblogs.com/blog/735119/201603/735119-20160305133553205-2143614528.png" alt="堆"></p><p><img src="http://images2015.cnblogs.com/blog/735119/201603/735119-20160305133644815-347392695.png" alt="堆去"></p><p>C++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_HEAP_SIZE 10000;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> n, H[MAX_HEAP_SIZE], heapsize;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heapify</span><span class="params">(<span class="keyword">int</span> i)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">int</span> smallest = i;</div><div class="line">  <span class="keyword">int</span> lch = i &lt;&lt;<span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> rch = lch+<span class="number">1</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">if</span>(lch &lt;= heapsize &amp;&amp; H[smallest]&gt;H[lch])</div><div class="line">  &#123;</div><div class="line">    smallest = lch;</div><div class="line">  &#125;</div><div class="line">   <span class="keyword">if</span>(rch &lt;= heapsize &amp;&amp; H[smallest]&gt;H[rch])</div><div class="line">  &#123;</div><div class="line">    smallest = rch;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(smallest != i )</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">int</span> temp = H[smallest];</div><div class="line">    H[smallest] = H[i];</div><div class="line">    H[i] = temp;</div><div class="line">    min_heapify(smallest);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = heapsize &gt;&gt;<span class="number">1</span>; i&gt;=<span class="number">1</span>; i--)</div><div class="line">  &#123;</div><div class="line">    min_heapify(i)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">extract_min</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">int</span> res = H[<span class="number">1</span>];</div><div class="line">  H[<span class="number">1</span>] = H[heapsize--];</div><div class="line">  min_heapify(<span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">heapsize = n;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;H[i]);</div><div class="line">&#125;</div><div class="line">build_heap();</div><div class="line"><span class="keyword">while</span> (heapsize &gt; <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, extract_min());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>java实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> &#123;</span></div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 堆筛选，除了start之外，start~end均满足大顶堆的定义。</span></div><div class="line"><span class="comment">     * 调整之后start~end称为一个大顶堆。</span></div><div class="line"><span class="comment">     * @param arr 待调整数组</span></div><div class="line"><span class="comment">     * @param start 起始指针</span></div><div class="line"><span class="comment">     * @param end 结束指针</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = arr[start];</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*start+<span class="number">1</span>; i&lt;=end; i*=<span class="number">2</span>) &#123;</div><div class="line">            <span class="comment">//左右孩子的节点分别为2*i+1,2*i+2</span></div><div class="line">            </div><div class="line">            <span class="comment">//选择出左右孩子较小的下标</span></div><div class="line">            <span class="keyword">if</span>(i &lt; end &amp;&amp; arr[i] &lt; arr[i+<span class="number">1</span>]) &#123;</div><div class="line">                i ++; </div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(temp &gt;= arr[i]) &#123;</div><div class="line">                <span class="keyword">break</span>; <span class="comment">//已经为大顶堆，=保持稳定性。</span></div><div class="line">            &#125;</div><div class="line">            arr[start] = arr[i]; <span class="comment">//将子节点上移</span></div><div class="line">            start = i; <span class="comment">//下一轮筛选</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        arr[start] = temp; <span class="comment">//插入正确的位置</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(arr == null || arr.length == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> ;</div><div class="line">        </div><div class="line">        <span class="comment">//建立大顶堆</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">            heapAdjust(arr, i, arr.length<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">            swap(arr, <span class="number">0</span>, i);</div><div class="line">            heapAdjust(arr, <span class="number">0</span>, i<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = arr[i];</div><div class="line">        arr[i] = arr[j];</div><div class="line">        arr[j] = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。希尔排序就利用了这个特点。基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。</p><p>举个例子：</p><p><img src="http://images2015.cnblogs.com/blog/735119/201603/735119-20160305135104830-1351755091.png" alt="希尔"></p><p>从上述排序过程可见，希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。</p><p>　　希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到<strong>O(n^1.3)</strong>。</p><p>C++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT_COUNT 100000</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, d[ELEMENT_COUNT];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shell_sort</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> gc = n&gt;&gt;<span class="number">1</span>; gc&gt;=<span class="number">1</span>; gc&gt;&gt;=<span class="number">1</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s&lt;gc; s++)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i-gc; j&gt;=<span class="number">0</span> &amp;&amp; d[j]&gt;d[j+gc]; j-= gc)</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">int</span> temp = d[j];</div><div class="line">        d[j] = d[j+gc];</div><div class="line">        d[j+gc] = temp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d[i]);</div><div class="line">&#125;</div><div class="line">Shell_sort();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, d[i]);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>java实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell_sort</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> d)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=d; i&lt;arr.length; i++)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">int</span> j = i-d;</div><div class="line">      <span class="keyword">int</span> temp = arr[i];   <span class="comment">//记录要插入的数据</span></div><div class="line">      <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;temp)  <span class="comment">//从后向前，找到比其小的数的位置 </span></div><div class="line">      &#123;</div><div class="line">        arr[j+d] = arr[j];  <span class="comment">//向后挪动 </span></div><div class="line">        j -= d;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(j != i-d)  <span class="comment">//存在比其小的数</span></div><div class="line">        arr[j+d] = temp;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> ;</div><div class="line">    <span class="keyword">int</span> d = arr.length / <span class="number">2</span>;</div><div class="line">    <span class="keyword">while</span>(d&gt;=<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">      shell_sort(arr, d);</div><div class="line">      d /= <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是另外一种不同的排序方法，因为归并排序使用了递归分治的思想，所以理解起来比较容易．其基本思想是，先递归划分子问题，然后合并结果．把待排序列看成由两个有序的子序列，然后合并两个子序列．然后再把子序列看成由两个有序序列．．．两两合并，四四合并．最终形成有序序列．空间复杂度为O(n)，时间复杂度为O(nlogn)。</p><p>举个例子：</p><p><img src="http://images2015.cnblogs.com/blog/735119/201603/735119-20160305141645721-842642889.png" alt="归并排序"></p><p>C++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2000000000</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ELEMENT_COUNT 100000</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> d[MAX_ELEMENT_COUNT];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> al[MAX_ELEMENT_COUNT], ar[MAX_ELEMENT_COUNT];</div><div class="line"><span class="keyword">int</span> il, ir;</div><div class="line"></div><div class="line"><span class="comment">// Copy the data to the temporary array al &amp; ar.</span></div><div class="line"><span class="keyword">for</span> (il = l; il &lt;= m; il++)</div><div class="line">&#123;</div><div class="line">al[il] = d[il];</div><div class="line">&#125;</div><div class="line">al[m + <span class="number">1</span>] = INF;</div><div class="line"><span class="keyword">for</span> (ir = m + <span class="number">1</span>; ir &lt;= r; ir++)</div><div class="line">&#123;</div><div class="line">ar[ir] = d[ir];</div><div class="line">&#125;</div><div class="line">ar[r + <span class="number">1</span>] = INF;</div><div class="line"></div><div class="line"><span class="comment">// Merge al &amp; ar into array d.</span></div><div class="line">il = l;</div><div class="line">ir = m + <span class="number">1</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (al[il] &lt; ar[ir])</div><div class="line">&#123;</div><div class="line">d[i] = al[il++];</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">d[i] = ar[ir++];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">if</span> (l &lt; r)</div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</div><div class="line">merge_sort(l, mid);</div><div class="line">merge_sort(mid + <span class="number">1</span>, r);</div><div class="line">merge(l, mid, r);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_ELEMENT_COUNT; i++)</div><div class="line">&#123;</div><div class="line">d[i] = rand();</div><div class="line">&#125;</div><div class="line"></div><div class="line">merge_sort(<span class="number">0</span>, MAX_ELEMENT_COUNT - <span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_ELEMENT_COUNT; i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, d[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>java实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge_sort</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    mSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 递归分治</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排数组</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> left 左指针</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> right 右指针</span></div><div class="line"><span class="comment">     */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">if</span>(left&gt;=right)</div><div class="line">      <span class="keyword">return</span> ;</div><div class="line">    <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</div><div class="line">    </div><div class="line">    mSort(arr, left, mid);  <span class="comment">//递归排序左边</span></div><div class="line">    mSort(arr, mid+<span class="number">1</span>, right); <span class="comment">//递归排序右边</span></div><div class="line">    merge(arr, left, mid, right);  <span class="comment">//合并</span></div><div class="line">  &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 合并两个有序数组</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待合并数组</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> left 左指针</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> mid 中间指针</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> right 右指针</span></div><div class="line"><span class="comment">     */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">int</span> [] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>]; <span class="comment">//中间数组</span></div><div class="line">    </div><div class="line">    <span class="keyword">int</span> i = left;</div><div class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">if</span>(arr[i]&lt;=arr[i])</div><div class="line">      &#123;</div><div class="line">        temp[k++] = arr[i++];</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span></div><div class="line">      &#123;</div><div class="line">        temp[k++] = arr[j++];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i&lt;=mid)</div><div class="line">    &#123;</div><div class="line">      temp[k++] = arr[i++];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(j&lt;=right)</div><div class="line">    &#123;</div><div class="line">      temp[k++] = arr[j++];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;temp.length; p++)</div><div class="line">    &#123;</div><div class="line">      arr[left+p] = temp[p];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>　　如果在面试中有面试官要求你写一个O(n)复杂度的排序算法，这时候需要有一个前提条件，就是<strong>待排序的数要满足一定范围的整数，而且计数排序需要比较多的辅助空间</strong>．其基本思想是，用待排序的数作为计数数组的下标，统计每个数字的个数．然后依次输出即可得到有序序列．</p><p>java实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Count_sort</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> )</div><div class="line">      <span class="keyword">return</span> ;</div><div class="line">    <span class="keyword">int</span> max = max(arr);</div><div class="line">    </div><div class="line">    <span class="keyword">int</span>[] count  = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</div><div class="line">    Arrays.fill(count, <span class="number">0</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)</div><div class="line">    &#123;</div><div class="line">      count[arr[i]]++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=max; i++)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;count[i]; j++)</div><div class="line">      &#123;</div><div class="line">        arr[k++] = i;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> els : arr)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">if</span>(ele &gt; max)</div><div class="line">        max = ele;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　查找和排序是算法的入门知识，因为实现代码较短，应用较常见．面试中经常会问到排序算法及相关的问题．一般在面试中最常考的是快速排序和归并排序，并且要求现场写出这两种排序的代码．对这两种排序的代码一定要信手拈来才行。还有插入排序、冒泡排序、堆排序、基数排序、桶排序等。面试官对于这些排序可能会要求比较各自的优劣、各种算法的思想及其使用场景。还有要会分析算法的时间和空间复杂度。通常查找和排序算法的考察是面试的开始，如果这些问题回答不好，估计面试官都没有继续面试下去的兴趣都没了。所以想开个好头就要把常见的排序算法思想及其特点要熟练掌握，有必要时要熟练写出代码。接下来我们就分析一下常见的排序算法及其使用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程，排序" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://yoursite.com/2017/12/21/operating-system/"/>
    <id>http://yoursite.com/2017/12/21/operating-system/</id>
    <published>2017-12-21T12:32:34.000Z</published>
    <updated>2018-01-03T13:28:45.330Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作系统导论"><a href="#操作系统导论" class="headerlink" title="操作系统导论"></a>操作系统导论</h3><p>　　操作系统是管理和控制计算机硬件和软件资源的计算机程序．计算机系统大致可以分为四个组成部分：计算机硬件、操作系统、系统程序与应用程序和用户．计算机系统的组成部分包括硬件、软件和数据．操作系统是一直运行在计算机上的程序（通常称为内核kernel）．</p><p><strong>操作系统基本特征：</strong></p><ul><li>并发：同一段时间内多个程序执行</li><li>共享：系统中的资源可以被内存中多个并发执行的进线程共同使用  </li><li>虚拟：通过分时复用以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个  </li><li>异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进  </li></ul><a id="more"></a><h4 id="计算机系统组织"><a href="#计算机系统组织" class="headerlink" title="计算机系统组织"></a>计算机系统组织</h4><p>　　现在通用计算机系统有一个或多个cpu和若干设备控制器通过共同的总线相连而成，该总线提供了对共享内存的访问．每个设备控制器负责一种特定类型的设备（磁盘驱动器、音频设备、视频显示器），cpu与设备控制器可以并发工作，并竞争内存周期．</p><p>　　当启动计算机时，它需要一个初始化程序．该初始化程序通常位于ROM或EEPROM中，称为计算机硬件中的固件．他初始化系统中的cpu寄存器、设备控制器和内存内容．</p><p>　　计算机程序必须在内存（或随机访问内存RAM）中以便于运行．通过地特定内存地址执行一系列load或store指令来实现交互．指令load将内存中的子移到cpu的寄存器，指令store将寄存器的内容移到内存．存储设备层次：寄存器，高速缓存、驻村、电子磁盘、磁盘、光盘、磁带．</p><h4 id="计算机系统体系结构"><a href="#计算机系统体系结构" class="headerlink" title="计算机系统体系结构"></a>计算机系统体系结构</h4><p>　　单处理系统（只要一个人同cpu）、多处理系统（增加吞吐量、规模经济、可靠性）、集群系统．</p><h4 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h4><p>　　操作系统具有多道程序处理能力，多道程序设计通过组织作业是cpu总有一个作业可执行，从而提高了cpu的利用率．分时系统是多道程序设计的延伸，分时操作系统允许许多用户同时共享计算机．</p><h4 id="操作系统操作"><a href="#操作系统操作" class="headerlink" title="操作系统操作"></a>操作系统操作</h4><p>　　双重模式操作：用户模式和监督程序模式．</p><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><p>　　处于执行中的程序称为进程，进程需要一定的资源（cpu时间、内存、文件、I/O设备）以完成其任务．程序本身并不是进程，程序是被动的实体，如同储存在磁盘上的内容，进程是一个活动的实体．进程是系统工作的单元，操作系统负责下述与进程管理相关的活动：</p><blockquote><p>创建和删除用户进程和系统进程</p><p>挂起和重启进程</p><p>提供进同步机制</p><p>提供进程通信机制</p><p>提供死锁处理机制　　</p></blockquote><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>　操作系统负责下列有关内存管理的活动：</p><blockquote><p>记录内存的那部分在使用及被谁使用</p><p>当有内存空间时，决定奶写进程可以装入内存</p><p>根据需要分配和释放内存空间</p></blockquote><h4 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h4><p>　文件系统管理，操作系统负责下列有关文件管理的活动：</p><blockquote><p>创建和删除文件</p><p>创建和删除目录来组织文件</p><p>提供操作文件和目录的原语</p><p>将文件映射到二级存储上</p><p>在稳定存储介质上备份文件</p></blockquote><p>　操作系统负责系列有关硬盘管理的活动：</p><blockquote><p>空闲空间管理</p><p>存储空间分配</p><p>硬盘调度</p></blockquote><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>　　信息通常保存在内存中，当他使用时，他会被临时复制到赶快的存储系统－高速缓存．当需要特定的信息时，首先检查他是否在高速缓存红，如果是，可直接使用高速缓存的信息，否则使用位于内存的信息，同事将其复制到高速缓存一片下次使用．索引寄存器为内存提供了高速缓存．</p><h4 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I/O系统"></a>I/O系统</h4><p>　　操作系统的目的之一在于对用户隐藏具体硬件设备的特性．I/O子系统摆阔如下几个部分：</p><blockquote><p>一个包括缓存、高速缓存和假脱机的内存管理部分</p><p>通用设备驱动器接口</p><p>特定硬件设备的驱动程序</p></blockquote><h3 id="操作系统结构-1"><a href="#操作系统结构-1" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><ul><li>用户界面：命令行界面、图形用户界面、</li><li>程序执行：系统必须将程序装入内存中并运行程序</li><li>I/O操作：操作系统必须提供I/O操作的方法</li><li>文件系统操作：</li><li>通信：进程之间的信息交换</li><li>错误检测：</li><li>资源分配：</li><li>统计:</li><li>保护和安全</li></ul><h4 id="系统调用类型"><a href="#系统调用类型" class="headerlink" title="系统调用类型"></a>系统调用类型</h4><p>　　系统调用大致分为五类：进程控制、文件管理、设备管理、信息维护和通信．</p><h3 id="进程管理-1"><a href="#进程管理-1" class="headerlink" title="进程管理"></a>进程管理</h3><p>　　处于执行中的程序称为进程，进程需要一定的资源（cpu时间、内存、文件、I/O设备）以完成其任务．程序本身并不是进程，程序是被动的实体，如同储存在磁盘上的内容，进程是一个活动的实体．进程是系统工作的单元．</p><p>　　<strong>进程状态：</strong></p><ul><li><p>新的：进程正在被创建</p></li><li><p>运行：指令正在被执行</p></li><li><p>等待：进程等待某个事件的发生</p></li><li><p>就绪：进程等待分配处理器</p></li><li><p>终止：进程完成执行</p><p><strong>进程控制块：（PCB）</strong></p></li><li><p>进程状态：前述状态</p></li><li><p>程序计数器：表示进程要执行的下个指令的地址</p></li><li><p>CPU寄存器：包括累加器、索引寄存器、堆栈指针、通用寄存器和其他条件码信息寄存器</p></li><li><p>CPU调度信息：进程优先级、调度队列的指正和其他调度参数</p></li><li><p>内存管理信息：基址和界限寄存器的值顿号页表或段表</p></li><li><p>记账信息：CPU事件、实际使用时间、时间界限、记账数据、作业或进程数量</p></li><li><p>I/O状态信息：分配给进程的I/O设备列表、打开的文件列表</p></li></ul><h4 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h4><p>　　进程创建：创建进程称为父进程，新进程称为子进程，新进程可以再创建其他进程，形成进程树．</p><p>　　大多数操作系统根据唯一的进程标示符(pid)来识别进程，pid通常是一个整数值．在进程创建时，除了得到各种物理和罗技资源外，初始化数据由父进传递给子进程．</p><p>　　当进程创建新进程是，有两种执行可能：</p><ul><li>父进程与子进程并发执行</li><li>父进程等待，直到某个或者去全部子进程执行完</li></ul><p>　　新进程的地址空间也有两种可能：</p><ul><li>子进程是父进程的复制品</li><li>子进程装入另外一个程序</li></ul><h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><p>　　当进程完成执行最后的语句后用exit()请求操作系统删除自身时，进程终止．进程可以返回状态值到父进程，所有进程资源会被操作系统释放．</p><p>　　父进程终止子进程的原因：</p><ul><li>子进程使用了超过他所分配到的一些资源</li><li>分配给子进程的任务已经不再需要</li><li>父进程退出</li></ul><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><p>　　操作系统内并发执行的进程可以是独立进程或协作进程．协作进程需要进程间通信机制来允许进程相互交换数据与信息．进程间通信有两种基本模式：共享内存、消息传递．</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>　　线程是CPU使用的基本单元，它有线程ID、陈旭计数器都闹寄存器集合和堆栈组成．它与属于同于进程的其他线程共享代码段、数据段和其他操作系统资源．单线程、多线程．</p><p>　　多线程编程优点：</p><ul><li>响应度高：即使部分阻塞或者执行叫冗长的操作，陈旭仍然继续执行</li><li>资源共享：现成默认共享他们所属进程的内存和资源</li><li>经济：进程创建所需要的内存和资源的分配比较昂贵</li><li>多处理器体系结构的利用：充分使用多处理器体系结构，以便每个进程能并行运行在不同的处理器</li></ul><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><blockquote><p>多对一模型：将许多用户线程映射到一个内核线程．</p><p>一对一模型：将每个用户线程映射到一个内核线程．</p><p>多对多模型：多路复用许多用户线程到同样数量或更小数量的内核线程上．</p></blockquote><p>现线程是进程内的控制流．多线程进程在同一地址被包括多个不同的控制流．</p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>　　每当服务器收到请求，他就创建一个独立线程以处理请求．虽然创建一个独立线程显然要比传建一个独立进程好，但是多线程服务器存在一些潜在的问题：（１）处理请求之前用以创建线程的时间，以及线程在完成工作后就要被丢弃这一事实；（２）如果允许所有并发请求都通过新线程来处理，那么将无法限制在系统中并发执行的线程的数量．无限制的线程会耗尽系统资源，如CPU时间和内存．</p><p>　　<strong>线程池</strong>是解决这个问题的一种方法，主要思想是：<strong>在进程开始时创建一定数量的线程，并放入池中等待工作．当服务器收到请求时，他会唤醒池红的一个线程，并将要处理的请求传递给它．一旦线程完成任务，他会返回到池中再等待工作．如果池中没有可以使用的线程，那么服务器会一直等待到有空线程为止．</strong>线程池的优点如下：</p><ul><li>通常用现有线程处理请求要比等待创建新的线程要快．</li><li>线程池限制了在任何时候可用线程的数量．</li></ul><h4 id="调度程序激活"><a href="#调度程序激活" class="headerlink" title="调度程序激活"></a>调度程序激活</h4><p>　　一种解决用户线程库与内核间通信的方法被称为调度器激活．工作方式：内核提供一组虚拟处理器给应用程序，应用程序可调度用户线程到一个可用的虚拟处理器上．</p><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><blockquote><p>进程是系统分配资源的单位，每一个进程对应一个活动的程序，当进程激活时，操作系统将系统的资源（内存、I/O和CPU等分配给它，使它执行）．</p><p>线程是CPU分配时间的单位，每一个线程对应于它在进程中的一个函数，也就是内存中的代码段，多个线程执行是CPU会根据他们的优先级分配时间，使它们完成自己的功能．</p></blockquote><ul><li>线程是比进程更小的能独立运行的单位，通常一个进程都有若干个线程，至少也需要一个线程．</li></ul><blockquote><p>调度：线程是调度和分派的基本单位，进程是资源拥有的单位．</p><p>并发性：进程之间可以并发执行，在一个线程中的多个线程之间也可以并发执行．</p><p>拥有资源：进程是拥有资源的一个独立单元，线程自己不拥有系统单元可以访问其隶属进程资源</p><p>系统开销：创建和撤销进程时，系统需要为之分配或回收资源，OS所付出的开销显著大于在创建或撤销线程时的开销；进程切换的开销也远大于线程切换的开销．</p></blockquote><ul><li>进程是指在系统中正在运行的一个应用程序；</li><li>线程是系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元。</li></ul><h3 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h3><p>　　CPU调度是多道程序操作系统的基础，在进程之间切换CPU,操作系统可以提高计算机的吞吐率．</p><p>　　CPU调度决策发生情景：</p><ul><li>当一个进程从运行状态切换到等待状态．</li><li>当一个进程从运行状态切换到就绪状态．</li><li>当一个进程从等待状态切换到就绪状态．</li><li>当一个进程终止时．</li></ul><h4 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h4><ul><li>CPU使用率：需要使CPU尽可能忙．</li><li>吞吐量：测量工作量的方法称为吞吐量，它指一个单元内所完成进程的数量．</li><li>周转时间：进程提交到进程完成的时间段．</li><li>等待时间：就绪队列中等待所花费的时间之和．</li><li>响应时间：从提交请求到产生第一想要的时间．</li></ul><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p><strong>单处理器系统CPU调度</strong></p><blockquote><p>先到先服务调度：先请求CPU的进程先分配到CPU，平均等待时间较长．</p><p>最短作业优先调度算法：将每个进程与下一个CPU区间段相关联．当CPU为空闲时，他会付给具有最短CPU区间的进程．</p><p>优先级调度：每一个进程都有一个优先级与其关联，具有最好优先级的进程会分配到CPU.</p><p>轮转法调度：为分时系统设计，类似于先到先服务调度，但是增加了抢占以切换进程．</p><p>多级队列调度：将就绪队列分成多个独立队列．根据进程的属性，如内存大小、进程优先级、一个进程被永久的分配到一个队列，每个队列有自己的调度算法．</p><p>多级反馈队列调度：允许进程在队列之间移动，根据不同CPU区间的特点以区分进程，如果进程使用过多CPU时间，他会被转移到更低优先级队列．</p></blockquote><p><strong>多处理器调度方法</strong></p><ul><li>非对称多处理：让一个处理器处理所有的调度决定、I/O处理以及其他系统活动，其他处理器只执行用户代码．</li><li>对称多处理：每个处理器自我调度，调度通过每个处理器检查共同就绪队列并选择一个进程来执行．</li></ul><p>　负载平衡设法将工作服在平均分配到对称多处理系统的所有处理器上．</p><h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>　　用户线程和内核线程的区别之一在于他们是如何被调度的．</p><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>　　协作进程是可以与在系统内执行的其他进程互相影响的进程．互相协作的进程可以直接共享逻辑地址空间（代码和数据），或者只通过文件或消息来共享数据．</p><h4 id="临界区问题"><a href="#临界区问题" class="headerlink" title="临界区问题"></a>临界区问题</h4><p>　　每个进程有一个代码段称为临界区，在该区中进程可能改变共同变量、更新一个表、写一个文件等．当一个进程进入临界区，没有其他进程可悲允许在临界区执行．</p><p>　　临界区满足三项要求：互斥、前进、有限等待．</p><p>　　处理操作系统内的临界区问题：抢占内核和非抢占内核．抢占内核更适合实时编程，因为它允许实时进程抢占处于内核模式运行的其他进程．抢占内核的相应更快，因为处于内核模式的进程在释放CPU之前不会运行过久．</p><h4 id="硬件同步"><a href="#硬件同步" class="headerlink" title="硬件同步"></a>硬件同步</h4><p>　　临界区的问题都需要一个简单的工具：锁．通过要求临界区用锁来防护，就可以避免竞争条件，即一个进程在进入临界区之前必须得到锁，而在其退出临界区时释放锁．</p><h4 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h4><ul><li>有限缓存问题</li><li>读者－写者问题</li><li>哲学家进餐问题</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>　　在多道程序环境下，多个进程可能竞争一定数量的资源．某个进程申请资源，如果这时资源不可用，那么该进程进入等待状态．若谷神奇的资源被其他等待进程占用，那么该等待进程有可能再也无法改变其状态．这种情况称为<strong>死锁(deadclock)</strong>.</p><h4 id="死锁特征"><a href="#死锁特征" class="headerlink" title="死锁特征"></a>死锁特征</h4><p>　<strong>　必要条件</strong></p><ul><li>互斥：至少一个资源必须处于非共享模式，即一次只有一个进程使用．如果了一个进程申请该资源，那么申请进程必须等到该资源被释放为止．</li><li>占有并等待：一个进程必须占有至少一个资源，并等待另一资源，二该资源为其他进程所占有．</li><li>非抢占：资源不能被抢占，即资源只能在进程完成任务后自动释放．</li><li>循环等待：有一组等待进程{p0,p1,…,pn}，p0等待的资源为p1占有，p1等待的资源为p2占有，．．．，pn等待的资源为p0占有．</li></ul><p>　上述四个条件必须全部满足才会出现死锁．循环等待条件意味着占有并等待条件，这样4个条件并不</p><p>完全独立．</p><h4 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h4><ul><li>使用协议以预防或避免死锁，确保系统不会进入死锁状态．</li><li>可允许系统进入死锁状态，然后检测它，并加以恢复．</li><li>可忽视这个问题，认为死锁不可能在系统内发生．</li></ul><p>为了确保思索不会发生，系统可采用死锁预防或死锁避免方案．</p><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p><strong>互斥</strong></p><p>对于非共享资源，必须要有互斥条件．例如：一台打印机不能同事为多个进程所共享．共享资源不要求互斥访问，一次不会死锁．</p><p><strong>占有并等待</strong></p><p>当一个进程申请一个资源时，它不能占有其他资源．一种可以使用的协议时每个进程在执行前申请并获得所以资源．另一种协议允许进程在没有资源时才可以申请资源．这两种协议的主要缺点：第一，资源利用率可能比较低，因为许多资源可能已分配，但是长时间没有被使用．第二，可能发生饥饿，一个进程如需要多个常用资源，可能会永久等待，因为其所需要的资源中至少有一个已分配给其他进程．</p><p><strong>非抢占</strong></p><p>如果一个进程占有资源并申请了一个不能立即分配的资源，那么其现已分配的资源都可能被强占．换句话说，这些资源都被隐式地释放了．如果一个进程申请一些资源，那么首先检查它们是否可用．如果可用，那么就分配它们；如果不可用，那么检查这些资源是否已分配给其他等待额外资源的进程．</p><p><strong>循环等待</strong></p><p>对所有资源类型进行完全排序，且要求每个进程按递增顺序来申请资源．</p><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>获得以后如何申请资源的附加信息，每次申请要求系统考虑现有可用资源、现已分配给每个进程的资源和每个进程将来申请与释放的资源，以决定当前申请是否满足或必须等待，从而避免死锁发生的可能性</p><p><strong>安全状态</strong></p><p>如果系统能按某个顺序诶每个进程分配资源（不超过其最大值）并能避免死锁，那么系统状态就是安全的．准确的说，如果存在一个安全写，那么系统处于安全状态．</p><ul><li><strong>资源分配图算法</strong> 　每种资源类型只有一个实例</li><li><strong>银行家算法</strong>　每种资源类型有多个实例</li></ul><h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><p>允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大 ．</p><h4 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h4><p>与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大．</p><h3 id="内存管理方式-段式页式和段页式"><a href="#内存管理方式-段式页式和段页式" class="headerlink" title="内存管理方式-段式页式和段页式"></a>内存管理方式-段式页式和段页式</h3><p>　　由于连续内存分配方式(单一连续分配，固定分区分配，动态分区分配，动态重定位分区分配)导致的内存利用率偏低以及内存碎片的问题，进而引出离散的内存分配方式。离散内存分配可以从OS的内存管理角度引出页式(离散分配的基本单位是页)管理，也可以从程序编制角度引出段式(离散分配的基本单位是段)管理。</p><h4 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h4><p>   　 基本分页存储管理中不具备页面置换功能(即没有实现虚拟内存的功能)，因此需要整个程序的所有页面都装入内存之后才可以运行。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个<strong>页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射</strong>。由于页表也是存储在内存中的，因此和不适用分页管理的存储方式相比，访问分页系统中内存数据需要两次的内存访问(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。<br>　　为了<strong>减少两次访问内存导致的效率影响，分页管理中引入了快表(或者联想寄存器)机制</strong>，包含快表机制的内存管理中，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中(可能存在快表换出算法)。<br>　　在某些<strong>计算机中如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间。为了解决这个问题，可以采用两级页表或者多级页表的方法</strong>，其中外层页表一次性调入内存且连续存放，内层页表离散存放。相应的访问内存页表的时候需要一次地址变换，访问逻辑地址对应的物理地址的时候也需要一次地址变换，而且一共需要访问内存3次才可以读取一次数据。</p><h4 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h4><p>　　分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。<br>　　分段内存管理当中，地址是二维的，一维是段号，一维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。段表中的每一个表项记录了该段在内存中的起始地址和该段的长度。段表可以放在内存中也可以放在寄存器中。<br>　　访问内存的时候根据段号和段表项的长度计算当前访问段在段表中的位置，然后访问段表，得到该段的物理地址，根据该物理地址以及段内偏移量就可以得到需要访问的内存。由于也是两次内存访问，所以分段管理中同样引入了联想寄存器。</p><h4 id="分页和分段对比"><a href="#分页和分段对比" class="headerlink" title="分页和分段对比"></a>分页和分段对比</h4><ul><li>页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；</li><li>段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制 </li><li>页的大小是固定的，由系统决定；</li><li>段的大小是不确定的，由用户决定 </li><li>页地址空间是一维的；</li><li>段地址空间是二维的</li></ul><h4 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h4><p>　　先将用户程序分为若干个段，然后再把每个段分成若干个页，并且为每一个段赋予一个段名称。这样在段页式管理中，一个内存地址就由段号，段内页号以及页内地址三个部分组成。<br>　　段页式内存访问：系统中设置了一个段表寄存器，存放段表的起始地址和段表的长度。地址变换时，根据给定的段号（还需要将段号和寄存器中的段表长度进行比较防止越界）以及寄存器中的段表起始地址，就可以得到该段对应的段表项，从段表项中得到该段对应的页表的起始地址，然后利用逻辑地址中的段内页号从页表中找到页表项，从该页表项中的物理块地址以及逻辑地址中的页内地址拼接出物理地址，最后用这个物理地址访问得到所需数据。由于访问一个数据需要三次内存访问，所以段页式管理中也引入了高速缓冲寄存器。</p><h3 id="虚拟内存及页面置换算法"><a href="#虚拟内存及页面置换算法" class="headerlink" title="虚拟内存及页面置换算法"></a>虚拟内存及页面置换算法</h3><p>　　如果存在一个程序，所需内存空间超过了计算机可以提供的实际内存，那么由于该程序无法装入内存所以也就无法运行。单纯的增加物理内存只能解决一部分问题，但是仍然会出现无法装入单个或者无法同时装入多个程序的问题。但是可以从逻辑的角度扩充内存容量，即可解决上述两种问题。</p><p>　　<strong>虚拟存储器就是具有请求调入功能和置换功能，可以从逻辑上对内存容量加以扩充的一种存储器系统。虚拟存储器都是建立在离散内存管理的基础上．</strong></p><p>虚拟存储器的特征：</p><ul><li>多次性：一个作业可以分多次被调入内存。多次性是虚拟存储特有的属性 ．</li><li>对换性：作业运行过程中存在换进换出的过程(换出暂时不用的数据换入需要的数据) ．</li><li>虚拟性：虚拟性体现在其从逻辑上扩充了内存的容量(可以运行实际内存需求比物理内存大的应用程序)。虚拟性是虚拟存储器的最重要特征也是其最终目标。虚拟性建立在多次性和对换性的基础上行，多次性和对换性又建立在离散分配的基础上．</li></ul><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ul><li>最佳置换算法：只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。</li><li>先进先出置换算法：简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面.</li><li>最近最久未使用算法LRU：算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现).</li><li>时钟算法clock(也被称为是最近未使用算法NRU)：页面设置一个访问为，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面.</li><li>改进型Clock算法：在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问为何修改位都是0的页面，其次是访问位为0修改位为1的页面。</li><li>最少使用算法LFU：设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。存在问题是该访问寄存器并不能真正反映当前页面访问次数，因为访问速度比较快，所以在更新寄存器的时间间隔内访问1次和访问100次都是一样的。另外，LFU和LRU是很类似的，支持硬件也是一样的，但是区分两者的关键在于一个以时间为标准，一个以次数为标准(例如对于寄存器 pa 001111 和pb 111000，两个页面，如果采用LRU，那么被淘汰的是pa，如果采用LFU那么被淘汰的是pb)。</li><li>页面缓冲算法PBA：置换的时候，页面无论是否被修改过，都不被置换到磁盘，而是先暂留在内存中的页面链表(已修改页面链表和未修改页面链表，也可以不区分)里面，当其再次被访问的时候可以直接从这些链表中取出而不必进行磁盘IO，当链表中已修改也难数目达到一定数量之后，进行依次写磁盘操作(相当于将多次IO合并为一次).</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;操作系统导论&quot;&gt;&lt;a href=&quot;#操作系统导论&quot; class=&quot;headerlink&quot; title=&quot;操作系统导论&quot;&gt;&lt;/a&gt;操作系统导论&lt;/h3&gt;&lt;p&gt;　　操作系统是管理和控制计算机硬件和软件资源的计算机程序．计算机系统大致可以分为四个组成部分：计算机硬件、操作系统、系统程序与应用程序和用户．计算机系统的组成部分包括硬件、软件和数据．操作系统是一直运行在计算机上的程序（通常称为内核kernel）．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作系统基本特征：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发：同一段时间内多个程序执行&lt;/li&gt;
&lt;li&gt;共享：系统中的资源可以被内存中多个并发执行的进线程共同使用  &lt;/li&gt;
&lt;li&gt;虚拟：通过分时复用以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个  &lt;/li&gt;
&lt;li&gt;异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读，操作系统" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>weight normalization</title>
    <link href="http://yoursite.com/2017/12/20/normalization/"/>
    <id>http://yoursite.com/2017/12/20/normalization/</id>
    <published>2017-12-20T10:49:25.000Z</published>
    <updated>2018-01-03T14:14:04.486Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>Weight normalization: a reparameterization of the weight vectors in a neural network that decouples the length of those weight vectors from their direction. Weight normalization does not introduce any dependencies between the training sets in a minibatch. It can be applied to RNN, DQN and GAN. It is a useful way to improve the conditioning of the optimization problem and speed up convergence of stochastic gradient descent.</p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>The practical success of first-order gradient based optimization is highly dependent on the curvature of the objective that is optimized. If the condition number of the Hessian matrix of the bojective at the optimum is low, the problem is said to exhibit pathological curvature, and first-order gradient descent will have trouble making progress . </p><a id="more"></a><h3 id="Weight-normalization"><a href="#Weight-normalization" class="headerlink" title="Weight normalization"></a>Weight normalization</h3><p>For an elementwise nonlinearity:</p><p><img src="../img/nonlinearity.png" alt="nonlinearity"></p><p>After associating  a loss function to one or more neuron outputs, such a neural netword is commonly trained by stochastic gradient descent in the parameters <strong>w</strong>, <strong>b</strong> of each neuron. In order to speef up the convergence of this optimization procedure, reparameterize each weight vector <strong>w</strong> in terms of a <strong>parameter vector v</strong> and a <strong>scalar parameter g</strong> and to o perform stochastic gradient descent with respect to those parameters instead.</p><p><img src="../img/weight_norm.png" alt="weight_norm"></p><p>||v|| denotes the Euclidean norm of <strong>v</strong>, fixing the  Euclidean norm of the weight vector <strong>w</strong>: we now have ||w|| = <strong>g</strong>, independent of the parameters  <strong>v</strong> . By decoupling the norm of the weight vector ( <strong>g</strong>) from the direction of the weight vector (<strong>v</strong>/||<strong>v</strong>||), we speed up convergence of our stochastic gradient descent optimization.</p><h4 id="Gradients"><a href="#Gradients" class="headerlink" title="Gradients"></a>Gradients</h4><p>Use standard stochastic gradient descent methods to obtain the gradient of a loss function L with respect to the new parameters <strong>v, g</strong> :</p><p><img src="../img/gradient.png" alt="gradient"></p><p><img src="../img/gradient_g.png" alt="gradient_g"></p><p><img src="../img/gradient_v.png" alt="gradient_v"></p><p><img src="../img/gradient_al.png" alt="gradient_al"></p><p> Weight normalization accomplishes two things:  it scales the weight gradient by **g/||v||＊＊,and it project the gradient away from the current weight vector.</p><p>Due to projecting away from <strong>w</strong>, the norm of <strong>v</strong> grows monotonically with the number of weight<br>updates when learning a neural network with weight normalization using standard gradient descent without momentum: </p><p><img src="../img/gradient_update.png" alt="gradient_update"></p><p>if <strong>||&amp;v||/||v||= c</strong>:</p><p><img src="../img/gradient_new_v.png" alt="gradient_new_v"></p><p>The rate of increase will depend on the the variance of the weight gradient. If our gradients are noisy, c will be high and the norm of v will quickly increase, which in turn will decrease the scaling factor  <strong>g/||v||</strong>; If the norm of the gradients is small, we get <strong>sqrt(1+ c*c)</strong> approximately equal to 1.</p><h3 id="pytorch-weight-norm"><a href="#pytorch-weight-norm" class="headerlink" title="pytorch weight_norm"></a>pytorch weight_norm</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch.utils.hooks <span class="keyword">as</span> hooks</div><div class="line"><span class="keyword">from</span> torch.nn.parameter <span class="keyword">import</span> Parameter</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeightNorm</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, dim)</span>:</span></div><div class="line">        self.name =name</div><div class="line">        self.dim = dim</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">computer_weight</span><span class="params">(self, module)</span>:</span></div><div class="line">        g = getattr(module, self.name+<span class="string">'_g'</span>)</div><div class="line">        v = getattr(module, self.name+<span class="string">'_v'</span>)</div><div class="line">        <span class="keyword">return</span> (g/self.norm(v))*v</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">norm</span><span class="params">(self, p)</span>:</span></div><div class="line">        <span class="string">"""Computes the norm over all dimensions except dim"""</span></div><div class="line">        <span class="keyword">if</span> self.dim <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> p.norm()</div><div class="line">        <span class="keyword">if</span> self.dim != <span class="number">0</span>:</div><div class="line">            p = p.transpose(<span class="number">0</span>, self.dim)</div><div class="line">        output_size = (p.size(<span class="number">0</span>),)+(<span class="number">1</span>,)*(p.dim()<span class="number">-1</span>)  <span class="comment"># delete dim dimension</span></div><div class="line">        p = p.contiguous().view(p.size(<span class="number">0</span>), <span class="number">-1</span>).norm(dim=<span class="number">1</span>).view(*output_size)</div><div class="line">        <span class="keyword">if</span> self.dim != <span class="number">0</span>:</div><div class="line">            p = p.transpose(<span class="number">0</span>, self.dim)</div><div class="line">        <span class="keyword">return</span> p</div><div class="line"></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span><span class="params">(modula, name, dim)</span>:</span></div><div class="line">        fn = WeightNorm(name, dim)</div><div class="line"></div><div class="line">        weight = getattr(module, name)</div><div class="line"></div><div class="line">        <span class="comment"># remove w from parameter list</span></div><div class="line">        <span class="keyword">del</span> module._parameters[name]</div><div class="line"></div><div class="line">        <span class="comment"># add g and v as new parameters and express w as g/||v|| * v</span></div><div class="line">        module.register_parameter(name + <span class="string">'_g'</span>, Parameter(fn.norm(weight).data))</div><div class="line">        module.register_parameter(name + <span class="string">'_v'</span>, Parameter(weight.data))</div><div class="line">        setattr(module, name, fn.computer_weight(module))</div><div class="line"></div><div class="line">        handle = hooks.RemovableHandle(module._forward_pre_hooks)</div><div class="line">        module._forward_pre_hooks[handle.id] = fn</div><div class="line">        fn.handle = handle</div><div class="line"></div><div class="line">        <span class="keyword">return</span>  fn</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, module, inputs)</span>:</span></div><div class="line">        setattr(module, self.name, self.computer_weight(module))</div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line"><span class="string">   example</span></div><div class="line"><span class="string">'''</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight_norm</span><span class="params">(module, name=<span class="string">'weight'</span>, dim=<span class="number">0</span>)</span>:</span></div><div class="line"></div><div class="line">    WeightNorm.apply(module, name, dim)</div><div class="line">    <span class="keyword">return</span> module</div><div class="line"></div><div class="line"><span class="string">''' </span></div><div class="line"><span class="string">    &gt;&gt;&gt; import torch.nn as nn</span></div><div class="line"><span class="string">    &gt;&gt;&gt; m = weight_norm(nn.Linear(20, 40), name='weight')</span></div><div class="line"><span class="string">        Linear (20 -&gt; 40)</span></div><div class="line"><span class="string">    &gt;&gt;&gt; m.weight_g.size()</span></div><div class="line"><span class="string">        torch.Size([40, 1])</span></div><div class="line"><span class="string">    &gt;&gt;&gt; m.weight_v.size()</span></div><div class="line"><span class="string">        torch.Size([40, 20])</span></div><div class="line"><span class="string">'''</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;Weight normalization: a reparameterization of the weight vectors in a neural network that decouples the length of those weight vectors from their direction. Weight normalization does not introduce any dependencies between the training sets in a minibatch. It can be applied to RNN, DQN and GAN. It is a useful way to improve the conditioning of the optimization problem and speed up convergence of stochastic gradient descent.&lt;/p&gt;
&lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;The practical success of first-order gradient based optimization is highly dependent on the curvature of the objective that is optimized. If the condition number of the Hessian matrix of the bojective at the optimum is low, the problem is said to exhibit pathological curvature, and first-order gradient descent will have trouble making progress . &lt;/p&gt;
    
    </summary>
    
      <category term="论文" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="论文，deep learning" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%EF%BC%8Cdeep-learning/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode</title>
    <link href="http://yoursite.com/2017/12/18/leetcode/"/>
    <id>http://yoursite.com/2017/12/18/leetcode/</id>
    <published>2017-12-18T14:00:54.000Z</published>
    <updated>2017-12-18T14:34:11.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h2><h3 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h3><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Given nums = [2, 7, 11, 15], target = 9,</div><div class="line"></div><div class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line">return [0, 1].</div></pre></td></tr></table></figure><a id="more"></a><p><strong>思路</strong></p><p>题意是让你从给定的数组中找到两个元素的和为指定值的两个索引，<strong>利用HashMap作为存储，键为目标值减去当前元素值，索引为值</strong>，比如<code>i = 0</code>时，此时首先要判断<code>nums[0] = 2</code>是否在map中，如果不存在，那么插入键值对<code>key = 9 - 2 = 7, value = 0</code>，之后当<code>i = 1</code>时，此时判断<code>nums[1] = 7</code>已存在于map中，那么取出该<code>value = 0</code>作为第一个返回值，当前<code>i</code>作为第二个返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">int</span> len = nums.length;　　　　<span class="comment">//数组长度</span></div><div class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="comment">//新建HashMap</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;len; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;　　　　<span class="comment">//遍历数组中的元素是否在HashMap中</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(nums[i]),i&#125;;</div><div class="line">            &#125;</div><div class="line">            map.put(target - nums[i],i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a>26. Remove Duplicates from Sorted Array</h3><p>Given a sorted array, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="external"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p>For example,<br>Given input array <em>nums</em> = <code>[1,1,2]</code>,</p><p>Your function should return length = <code>2</code>, with the first two elements of <em>nums</em> being <code>1</code> and <code>2</code> respectively. It doesn’t matter what you leave beyond the new length.</p><p><strong>思路</strong></p><p>题意是让你从一个有序的数组中移除重复的元素，并返回之后数组的长度。我的思路是：首先判断如果数组长度等于0的话直接返回原长度即可，否则的话遍历一遍数组，用一个<code>index</code>变量指向尾部，如果后面的元素和前面的元素不同，就让<code>index</code>变量加1，最后返回<code>index</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = nums.size();    <span class="comment">//输出数组长度</span></div><div class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> len;</div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;　　　　　　 <span class="comment">//index</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;　　　　<span class="comment">//遍历数组</span></div><div class="line">            <span class="keyword">if</span>(nums[index]!=nums[i])&#123;　　</div><div class="line">                nums[++index] = nums[i];  <span class="comment">//判断后面的元素是否和前面的相同</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> index+<span class="number">1</span>;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a>27. Remove Element</h3><p>Given an array and a value, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="external"><strong>in-place</strong></a> and return the new length.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Given nums = [3,2,2,3], val = 3,</div><div class="line"></div><div class="line">Your function should return length=2, with the first two elements of nums being 2.</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是移除数组中值等于<code>val</code>的元素，并返回之后数组的长度，并且题目中指定空间复杂度为O(1)，我的思路是用<code>index</code>标记尾部，遍历该数组时当索引元素不等于<code>val</code>时，<code>index</code>加一，尾部指向当前元素，最后返回<code>index</code>即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i]!= val)&#123;</div><div class="line">                nums[index++]=nums[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> index;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a>33. Search in Rotated Sorted Array</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p><p><strong>思路</strong></p><p>题意是让你从一个旋转过后的递增序列中寻找给定值，找到返回索引，找不到返回-1，我们在下面这组数据中寻找规律。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1 2 4 5 6 7 0</div><div class="line">2 4 5 6 7 0 1</div><div class="line">4 5 6 7 0 1 2</div><div class="line">5 6 7 0 1 2 4</div><div class="line">6 7 0 1 2 4 5</div><div class="line">7 0 1 2 4 5 6</div></pre></td></tr></table></figure><p>由于是旋转一次，所以肯定有一半及以上的序列仍然是具有递增性质的，我们观察到如果中间的数比左面的数大的话，那么左半部分序列是递增的，否则右半部分就是递增的，那么我们就可以确定给定值是否在递增序列中，从而决定取舍哪半边。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right = nums.size();</div><div class="line">        <span class="keyword">while</span>(left != right)&#123;</div><div class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</div><div class="line">            <span class="keyword">if</span>(nums[left]&lt;=nums[mid])&#123;</div><div class="line">                <span class="keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;=nums[mid])&#123;</div><div class="line">                    right = mid;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    left = mid+<span class="number">1</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[right<span class="number">-1</span>])&#123;</div><div class="line">                    left = mid+<span class="number">1</span>;</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    right = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h3><p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">For example, given array S = [-1, 0, 1, 2, -1, -4],</div><div class="line"></div><div class="line">A solution set is:</div><div class="line">[</div><div class="line">  [-1, 0, 1],</div><div class="line">  [-1, -1, 2]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是让你从数组中找出所有三个和为0的元素构成的非重复序列，这样的话我们可以把数组先做下排序，然后遍历这个排序数组，用两个指针分别指向当前元素的下一个和数组尾部，判断三者和与0的大小来移动两个指针，其中细节操作就是注意去重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i&lt;nums.length-<span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>, right = nums.length-<span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</div><div class="line">                <span class="keyword">int</span> sum = nums[i]+nums[left]+nums[right];</div><div class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</div><div class="line">                    list.add(Arrays.asList(nums[i],nums[left++],nums[right--]));</div><div class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left-<span class="number">1</span>]) ++left;</div><div class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>]) --right;</div><div class="line">                    </div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span> ) ++left;</div><div class="line">                <span class="keyword">else</span> --right;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(nums[i] == nums[++i] &amp;&amp; i&lt;nums.length -<span class="number">2</span>);</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16. 3Sum Closest"></a>16. 3Sum Closest</h3><p>Given an array <em>S</em> of <em>n</em> integers, find three integers in <em>S</em> such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.</div><div class="line"></div><div class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是让我们求最接近给定值的三数之和，是在之前那道3Sum三数之和的基础上又增加了些许难度，那么这道题让我们返回这个最接近于给定值的值，即我们要保证当前三数和跟给定值之间的差的绝对值最小，所以我们需要定义一个变量Ａ用来记录差的绝对值，然后我们还是要先将数组排个序，然后开始遍历数组，思路跟那道三数之和很相似，都是先确定一个数，然后用两个指针left和right来滑动寻找另外两个数，每确定两个数，我们求出此三数之和，然后算和给定值的差的绝对值存在newＡ中，然后和Ａ比较并更新Ａ和结果closest即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> closest = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>];</div><div class="line">        <span class="keyword">int</span> A = <span class="built_in">abs</span>(closest-target);</div><div class="line">        sort(nums.begin(),nums.end());</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-2</span>; i++)&#123;</div><div class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>, right = nums.size()<span class="number">-1</span>;</div><div class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</div><div class="line">                <span class="keyword">int</span> sum = nums[i]+nums[left]+nums[right];</div><div class="line">                <span class="keyword">int</span> newA = <span class="built_in">abs</span>(sum-target);</div><div class="line">                <span class="keyword">if</span>(A&gt;newA)&#123;</div><div class="line">                    A = newA;</div><div class="line">                    closest = sum;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(sum&lt;target) ++left;</div><div class="line">                <span class="keyword">else</span> --right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> closest;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a>53. Maximum Subarray</h3><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p><p>For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br>the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.</p><p><strong>思路</strong></p><p>题意是求数组中子数组的最大和，利用动态规划的方法去求解。当部分序列和大于0的话就一直加下一个元素，并和当前最大值进行比较，如果出现部分序列小于０，那就需要从当前元素算起。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = nums.size(), init = nums[<span class="number">0</span>], max = init;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</div><div class="line">            init = nums[i]+(init&gt;<span class="number">0</span> ? init:<span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span>(init&gt;max) max = init;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38. Count and Say"></a>38. Count and Say</h3><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.     1</div><div class="line">2.     11</div><div class="line">3.     21</div><div class="line">4.     1211</div><div class="line">5.     111221</div></pre></td></tr></table></figure><p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2</code>, then <code>one 1&quot;</code> or <code>1211</code>.</p><p>Given an integer <em>n</em>, generate the <em>n</em>th term of the count-and-say sequence.</p><p>Note: Each term of the sequence of integers will be represented as a string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 1</div><div class="line">Output: &quot;1&quot;</div></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 4</div><div class="line">Output: &quot;1211&quot;</div></pre></td></tr></table></figure><h3 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h3><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>思想</strong></p><p>题意是用一个新链表来合并两个已排序的链表，那我们只需要从头开始比较已排序的两个链表，新链表指针每次指向值小的节点，依次比较下去，最后，当其中一个链表到达了末尾，我们只需要把新链表指针指向另一个没有到末尾的链表此时的指针即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * public class ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</div><div class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode tmp = head;</div><div class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</div><div class="line">                tmp.next = l1;</div><div class="line">                l1 = l1.next;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                tmp.next = l2;</div><div class="line">                l2 = l2.next;</div><div class="line">            &#125;</div><div class="line">            tmp = tmp.next;</div><div class="line">        &#125;</div><div class="line">        tmp.next = l1 !=<span class="keyword">null</span> ? l1:l2;</div><div class="line">        <span class="keyword">return</span> head.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h3><p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and <em>n</em> is at least 2.</p><p><strong>思路</strong></p><p>木桶的容积取决于短板的高度。首先计算最左边（left）和最右边（right）组成的木桶的面积，并把它设置为maxArea。在left&lt;right的情况下，首先判断height[left]和height[right]值的大小，若height[left]&lt;height[right]，则height取值向右边移动，同时计算每移动一步后新的Area的面积并与maxArea做比较，得出新的最大面积；反之，则height取值向左边移动，重复上一步操作。最终得到最大的区域积。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right =height.size()<span class="number">-1</span>; </div><div class="line">        <span class="keyword">int</span> maxArea = (right-left)*min(height[left],height[right]);</div><div class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</div><div class="line">            <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</div><div class="line">                left++;</div><div class="line">                <span class="keyword">int</span> Area1 = (right-left)*min(height[left],height[right]);</div><div class="line">                <span class="keyword">if</span>(Area1&gt;maxArea)&#123;</div><div class="line">                    maxArea = Area1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                right--;</div><div class="line">                <span class="keyword">int</span> Area2 = (right-left)*min(height[left],height[right]);</div><div class="line">                <span class="keyword">if</span>(Area2&gt;maxArea)&#123;</div><div class="line">                    maxArea = Area2;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxArea;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h3><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p><strong>思路</strong></p><p>题意是编写一个函数来查找字符串数组中最长的公共前缀字符串。利用纵向扫描，对每一个位置比较所以字符串，直到遇到一个不匹配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(strs.empty()) <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx&lt;strs[<span class="number">0</span>].size(); idx++)&#123;  <span class="comment">//纵向扫描数组</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;strs.size(); i++)&#123;</div><div class="line">                <span class="keyword">if</span>(strs[i][idx] != strs[<span class="number">0</span>][idx]) <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>,idx);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//strs = ['make fun','make love','main idea'];</span></div><div class="line"><span class="comment">//strs[0] = 'make fun' thus idx (0~8);</span></div><div class="line"><span class="comment">//strs.size() = 3; </span></div><div class="line"><span class="comment">//strs[i][idx],strs[0][idx]中，保持idx不变，比较纵列是否相同。</span></div><div class="line"><span class="comment">//strs[0].substr(0,idx)　substr(截取开始位置,截取长度)。</span></div></pre></td></tr></table></figure><h3 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a>9. Palindrome Number</h3><p>Determine whether an integer is a palindrome. Do this without extra space.</p><p><strong>Some hints:</strong></p><p>Could negative integers be palindromes? (ie, -1)</p><p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p><p>You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?</p><p>There is a more generic way of solving this problem.</p><p><strong>思路</strong></p><p>题意是判断一个有符号整型数是否是回文，也就是逆序过来的整数和原整数相同，首先负数肯定不是，接下来我们直接算出他的回文数，然后和给定值比较即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">int</span> s = x, reverse = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(s&gt;<span class="number">0</span>)&#123;</div><div class="line">            reverse = reverse*<span class="number">10</span>+s%<span class="number">10</span>;</div><div class="line">            s/=<span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> x == reverse;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//reverse = 1      reverse = 12      reverse=123      reverse=1234</span></div><div class="line"><span class="comment">//reverse = 12344  reverse = 123443  reverse=1234432  reverse=12344321</span></div></pre></td></tr></table></figure><h3 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35. Search Insert Position"></a>35. Search Insert Position</h3><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [1,3,5,6], 5</div><div class="line">Output: 2</div></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [1,3,5,6], 2</div><div class="line">Output: 1</div></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [1,3,5,6], 7</div><div class="line">Output: 4</div></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [1,3,5,6], 0</div><div class="line">Output: 0</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是给定一个有序数组和一个目标值，如果找到目标，则返回索引。如果没有，则返回按顺序插入的索引。解题思路：首先遍历数组，若当前数字大于或等于目标值，则返回当前坐标，如果遍历结束了，说明目标值比数组中任何一个数都要大，则返回数组长度n即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i]&gt;=target) <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums.size();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48.  Rotate Image"></a>48.  Rotate Image</h3><p>You are given an <em>n</em> x <em>n</em> 2D matrix representing an image.</p><p>Rotate the image by 90 degrees (clockwise).</p><p><strong>Note:</strong><br>You have to rotate the image <strong>in-place</strong>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Given input matrix = </div><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [4,5,6],</div><div class="line">  [7,8,9]</div><div class="line">],</div><div class="line"></div><div class="line">rotate the input matrix in-place such that it becomes:</div><div class="line">[</div><div class="line">  [7,4,1],</div><div class="line">  [8,5,2],</div><div class="line">  [9,6,3]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Given input matrix =</div><div class="line">[</div><div class="line">  [ 5, 1, 9,11],</div><div class="line">  [ 2, 4, 8,10],</div><div class="line">  [13, 3, 6, 7],</div><div class="line">  [15,14,12,16]</div><div class="line">], </div><div class="line"></div><div class="line">rotate the input matrix in-place such that it becomes:</div><div class="line">[</div><div class="line">  [15,13, 2, 5],</div><div class="line">  [14, 3, 4, 1],</div><div class="line">  [12, 6, 8, 9],</div><div class="line">  [16, 7,10,11]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是给定一个n*n个2维矩阵来表示一个图。在原矩阵上旋转图形90°。主要思路是，首先沿着矩阵副对角线翻转一次，然后沿着水平线翻转一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i, j, temp;</div><div class="line">        <span class="keyword">int</span> n = matrix.size();</div><div class="line">        # 沿着矩阵副对角线翻转</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n-i; ++j)&#123;</div><div class="line">                temp = matrix[i][j];</div><div class="line">                matrix[i][j] = matrix[n-j<span class="number">-1</span>][n-i<span class="number">-1</span>];</div><div class="line">                matrix[n-j<span class="number">-1</span>][n-i<span class="number">-1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        # 沿着水平线翻转</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n/<span class="number">2</span>; ++i)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</div><div class="line">                temp = matrix[i][j];</div><div class="line">                matrix[i][j] = matrix[n-i<span class="number">-1</span>][j];</div><div class="line">                matrix[n-i<span class="number">-1</span>][j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="34-Search-for-a-Range"><a href="#34-Search-for-a-Range" class="headerlink" title="34. Search for a Range"></a>34. Search for a Range</h3><p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p><p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p><p>If the target is not found in the array, return <code>[-1, -1]</code>.</p><p>For example,<br>Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>return <code>[3, 4]</code>.</p><p><strong>思路</strong></p><p>题意是给定按升序排序的整数数组，找到给定目标值的开始和结束位置。其中算法的运行时复杂度必须按照O（log n）的顺序。如果在数组中找不到目标，则返回[-1，-1]。首先，建立二元结果数组Ａ，左边left,右边right。二分法求左边界：当中点小于target，left移向中点，否则right移向中点；先判断左边，再判断右边是否等于target，如果是，赋值给Ａ[0]。二分法求右边界：当中点大于target，right移向中点，否则left移向中点；先判断右边，再判断左边是否等于target，如果是，赋值给Ａ[1]。返回Ａ。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">int</span>[] A = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right = n-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(nums[left]&lt;nums[right])&#123;</div><div class="line">            <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid]&lt;target) left = mid+<span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target) right = mid-<span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">if</span>(nums[left]&lt;target) left++;</div><div class="line">                <span class="keyword">if</span>(nums[right]&gt;target) right--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(nums[left] == target)&#123;</div><div class="line">            A[<span class="number">0</span>] = left;</div><div class="line">            A[<span class="number">1</span>] = right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> A;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66. Plus One"></a>66. Plus One</h3><p>Given a non-negative integer represented as a <strong>non-empty</strong> array of digits, plus one to the integer.</p><p>You may assume the integer do not contain any leading zero, except the number 0 itself.</p><p>The digits are stored such that the most significant digit is at the head of the list.</p><p><strong>思路</strong></p><p>题意是给定一个数组表示非负整数，其高位在数组的前面，对这个整数加1。使用大数加法，遍历数组的每一位，同时处理进位，如果最后还有进位，则在数组最前面插入１即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</div><div class="line">        <span class="keyword">int</span> c = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> n = digits.size();</div><div class="line">      　＃ 遍历数组的每一位</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</div><div class="line">            <span class="keyword">int</span> a = digits[i]+c;</div><div class="line">            digits[i] = a % <span class="number">10</span>;</div><div class="line">          　<span class="comment">// 做进位处理</span></div><div class="line">            c = a/<span class="number">10</span>; </div><div class="line">            <span class="comment">// 用于判断最后是否还有进位，值为０或１．</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(c == <span class="number">1</span>)&#123;</div><div class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</div><div class="line">            <span class="comment">// 在数组最前面插入１．</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> digits;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h3><p>Say you have an array for which the $i^{th}$ element is the price of a given stock on day <em>i</em>.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: [7, 1, 5, 3, 6, 4]</div><div class="line">Output: 5</div><div class="line"></div><div class="line">max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</div></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: [7, 6, 4, 3, 1]</div><div class="line">Output: 0</div><div class="line"></div><div class="line">In this case, no transaction is done, i.e. max profit = 0.</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是假设有一个数组，数组中的元素是第i天给定股票的价格，如果最多只能完成最多一笔交易（买入或者卖出一股股票），设计一个算法来找到最大的利润值。首先初始化利润值为０，假定当前的最小值cur_min为数组中的第一个数值，遍历当前数组，取初始化利润值与prices[i]-cur_min中较大值作为新的profit，取cur_min和prices[i]中较小的值作为新的cur_min，迭代最终得到最大的profit。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = prices.size();</div><div class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>; <span class="comment">// 初始化利润值.</span></div><div class="line">        <span class="keyword">int</span> cur_min = prices[<span class="number">0</span>];  <span class="comment">// 当前的最小股票值</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">            profit = max(profit, prices[i]-cur_min);</div><div class="line">            cur_min = min(cur_min, prices[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> profit;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h3><p>Say you have an array for which the $i^{th}$ element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><p><strong>思路</strong></p><p>题意是设计一个算法来找到最大的利润，可以根据需要完成尽可能多的交易（即多次买入和卖出一次股票）。但是不可以同时进行多笔交易（即您必须在再次购买之前出售股票）。因为买一次接着卖一次，所以只要计算买卖一次的利润值，对利润值大于０的进行求和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = prices.size();</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++)&#123;</div><div class="line">            <span class="keyword">int</span> profit = prices[i]-prices[i<span class="number">-1</span>];</div><div class="line">            <span class="keyword">if</span>(profit&gt;<span class="number">0</span>) sum += profit;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118.  Pascal’s Triangle"></a>118.  Pascal’s Triangle</h3><p>Given <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p><p>For example, given <em>numRows</em> = 5,<br>Return</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">     [1],</div><div class="line">    [1,1],</div><div class="line">   [1,2,1],</div><div class="line">  [1,3,3,1],</div><div class="line"> [1,4,6,4,1]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是生成帕斯卡三角形，我们可以发现，从第三行开始，该行中的值等于上一行的左上角和右上角之和，利用这个规律进行求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="comment">//在vector&lt;vector&lt;int&gt;&gt;中，因为vector是一个容器，最外层的vector容器中放着更小的             vector，而里层的vector里面放的是int型的数字。所以我们首先要对里层的vector容器赋           值，然后再把里层的vector作为元素插入到外层的vector中。</span></div><div class="line">        <span class="keyword">if</span>(numRows == <span class="number">0</span>) <span class="keyword">return</span> result; </div><div class="line">        result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">1</span>));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=numRows; i++)&#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; current(i,<span class="number">1</span>);  <span class="comment">//本行</span></div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pre = result[i<span class="number">-2</span>]; <span class="comment">//　上一行</span></div><div class="line">            </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i<span class="number">-1</span>; j++)&#123;</div><div class="line">                current[j] = pre[j<span class="number">-1</span>]+pre[j];　<span class="comment">//左上角和右上角之和</span></div><div class="line">            &#125;</div><div class="line">            result.push_back(current);　<span class="comment">//在vector类中作用为在vector尾部加入一个数据</span></div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="119. Pascal’s Triangle II"></a>119. Pascal’s Triangle II</h3><p>Given an index <em>k</em>, return the $k^th$ row of the Pascal’s triangle.</p><p>For example, given <em>k</em> = 3, Return <code>[1,3,3,1]</code>.</p><p><strong>思路</strong></p><p>题意是生成帕斯卡三角形中的某一列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=rowIndex; i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;<span class="number">0</span>; j--)&#123;</div><div class="line">                <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j<span class="number">-1</span>]+<span class="built_in">array</span>[j];</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">array</span>.push_back(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">array</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h3><p>Given a <strong>set</strong> of candidate numbers (<strong>C</strong>) <strong>(without duplicates)</strong> and a target number (<strong>T</strong>), find all unique combinations in <strong>C</strong> where the candidate numbers sums to <strong>T</strong>.</p><p>The <strong>same</strong> repeated number may be chosen from <strong>C</strong> unlimited number of times.</p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>For example, given candidate set <code>[2, 3, 6, 7]</code> and target <code>7</code>,<br>A solution set is: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [7],</div><div class="line">  [2, 2, 3]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意：给定一个正数集合和一个目标数，求出所有的子集合，使子集的和为target，要求子集合递增排列，且不包含重复的子集合，子集合中的数字可以重复。我们需要写一个递归函数，在这个函数中需要添加三个变量，result记录最终的结果，path记录中间的一个解，start记录当前递归到的下标。调用递归函数时，target要减去当前数组的数，为了减小计算量，进行相应的剪枝处理，即大于target,就减去。数组中的那个值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</div><div class="line">        sort(candidates.begin(), candidates.end());</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result; <span class="comment">//final result</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;   <span class="comment">// path result</span></div><div class="line">        combsum(candidates, path, result, target, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combsum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;     <span class="comment">// find the suitable solution</span></div><div class="line">            result.push_back(path);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;candidates.size(); i++)&#123;</div><div class="line">            <span class="keyword">if</span>(target&lt;candidates[i]) <span class="keyword">return</span> ;   <span class="comment">//pruning</span></div><div class="line">            </div><div class="line">            path.push_back(candidates[i]);</div><div class="line">            combsum(candidates, path, result, target-candidates[i],i);</div><div class="line">            path.pop_back();    </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a>40. Combination Sum II</h3><p>Given a collection of candidate numbers (<strong>C</strong>) and a target number (<strong>T</strong>), find all unique combinations in <strong>C</strong> where the candidate numbers sums to <strong>T</strong>.</p><p>Each number in <strong>C</strong> may only be used <strong>once</strong> in the combination.</p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>For example, given candidate set <code>[10, 1, 2, 7, 6, 1, 5]</code> and target <code>8</code>,<br>A solution set is: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [1, 7],</div><div class="line">  [1, 2, 5],</div><div class="line">  [2, 6],</div><div class="line">  [1, 1, 6]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意：给定一个正数集合和一个目标数，求出所有的子集合，使子集的和为target，要求子集合递增排列，且不包含重复的子集合，子集合中的数字也不可以重复。与上一个题目差不多，需要加一个判断，如果上一轮循环已经使用candidates[i]，本次循环就不能再选candidates[i]，确保candidates[i]最多循环一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</div><div class="line">        sort(candidates.begin(), candidates.end());</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</div><div class="line">        combsum(candidates, path, result, target, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combsum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</div><div class="line">            result.push_back(path);</div><div class="line">            <span class="keyword">return</span> ;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> previous = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;candidates.size(); i++)&#123;</div><div class="line">            <span class="comment">// if previous loop has used candidates[i], </span></div><div class="line">            <span class="comment">// in this loop candidates[i] can not be used</span></div><div class="line">            <span class="keyword">if</span>(previous == candidates[i]) <span class="keyword">continue</span>;    </div><div class="line">            <span class="keyword">if</span>(target&lt;candidates[i]) <span class="keyword">return</span> ;  <span class="comment">//pruning</span></div><div class="line">            </div><div class="line">            previous = candidates[i];</div><div class="line">            </div><div class="line">            path.push_back(candidates[i]);</div><div class="line">            combsum(candidates, path, result, target-candidates[i], i+<span class="number">1</span>);</div><div class="line">            path.pop_back();</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode&quot;&gt;&lt;a href=&quot;#Leetcode&quot; class=&quot;headerlink&quot; title=&quot;Leetcode&quot;&gt;&lt;/a&gt;Leetcode&lt;/h2&gt;&lt;h3 id=&quot;1-Two-Sum&quot;&gt;&lt;a href=&quot;#1-Two-Sum&quot; class=&quot;headerlink&quot; title=&quot;1. Two Sum&quot;&gt;&lt;/a&gt;1. Two Sum&lt;/h3&gt;&lt;p&gt;Given an array of integers, return &lt;strong&gt;indices&lt;/strong&gt; of the two numbers such that they add up to a specific target.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have &lt;strong&gt;exactly&lt;/strong&gt; one solution, and you may not use the &lt;em&gt;same&lt;/em&gt; element twice.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Given nums = [2, 7, 11, 15], target = 9,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Because nums[0] + nums[1] = 2 + 7 = 9,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;return [0, 1].&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程，Leetcode" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%EF%BC%8CLeetcode/"/>
    
  </entry>
  
  <entry>
    <title>词向量</title>
    <link href="http://yoursite.com/2017/12/17/word-embedding/"/>
    <id>http://yoursite.com/2017/12/17/word-embedding/</id>
    <published>2017-12-17T12:04:30.000Z</published>
    <updated>2018-01-03T14:17:43.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自然语言处理－词向量"><a href="#自然语言处理－词向量" class="headerlink" title="自然语言处理－词向量"></a>自然语言处理－词向量</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在计算机视觉中，作为输入的图片可以直接数值化。在语言识别中，作为输入的语音也可以直接数值化。而在自然语言处理中，我们无法将文字直接数值化，为了能够让计算机处理文字，我们需要将文字映射到一个数值空间。由于词是组成语义的基本单位，所以对词的表述就显得尤为重要，我们把词的数值（表征）表示为<strong>Word Representation</strong>，一般来说，词向量经常指<strong>Word Embedding</strong>，也称<strong>Distributed Word Representation</strong>。</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>从<strong>Word Representation</strong>的发展过程引入<strong>Word Embedding</strong>，先从简单的SVD介绍开始，再到NNLM,word2vec等词向量模型。</p><h3 id="one-hot编码"><a href="#one-hot编码" class="headerlink" title="one-hot编码"></a>one-hot编码</h3><p>one-hot编码也称独热编码，这是一种简单的词表征方式，每个词使用一个$R^{|V|}$的向量表示，$|V|$表示词表的大小。</p><script type="math/tex; mode=display">w^{address}=\begin{bmatrix}1\\0\\0\\\vdots\\0\end{bmatrix},w^{home}=\begin{bmatrix}0\\1\\0\\\vdots\\0\end{bmatrix},w^{at}=\begin{bmatrix}0\\0\\1\\\vdots\\0\end{bmatrix}</script><p>使用one-hot编码的词向量之间是相互独立的，因为对于每个词$(w^{i})^{T}w^j = 0$，这种编码方式并没有编码不同词之间的语义相似性。</p><a id="more"></a><h3 id="基于矩阵分解的词表征"><a href="#基于矩阵分解的词表征" class="headerlink" title="基于矩阵分解的词表征"></a>基于矩阵分解的词表征</h3><h4 id="词–文档矩阵-Word-Document-Matrix"><a href="#词–文档矩阵-Word-Document-Matrix" class="headerlink" title="词–文档矩阵(Word-Document Matrix)"></a>词–文档矩阵(Word-Document Matrix)</h4><p>如果我们有大量的文档，我们用一个矩阵来存储所有文档的词频信息。矩阵的行向量代表词，列向量代表文档，每个元素代表词在文档中出现的频数，比如我们现在有两篇文档：</p><p>$I \quad love \quad NLP \\ I \quad love \quad deep \quad learningI$</p><p>经过统计次数，我们可以得到以下矩阵：</p><script type="math/tex; mode=display">\boldsymbol{X} = \begin{array}{c}&\tiny{d_1}&\tiny{d_2}\\\begin{array}{c}\tiny{I} \\\tiny{love} \\\tiny{NLP} \\\tiny{deep} \\\tiny{learning} \\\end{array}\left.\right[&\begin{array}{c}1 \\ 1 \\ 1 \\ 0 \\ 0\end{array}&\begin{array}{c}1 \\ 1 \\ 0 \\ 1 \\ 1\end{array}&\left.\right]\end{array}</script><p>如果两个文档有相似的主题，那么两个文档的列向量会趋于有相似类型的词数量。该模型主要用于衡量文档主题的相似性。</p><h4 id="基于窗口的词共现矩阵-Window-based-Co-occurrence-Matrix"><a href="#基于窗口的词共现矩阵-Window-based-Co-occurrence-Matrix" class="headerlink" title="基于窗口的词共现矩阵(Window based Co-occurrence Matrix)"></a>基于窗口的词共现矩阵(Window based Co-occurrence Matrix)</h4><p>给定一个词，计算在一个限定大小的窗口中出现的其他词的次数。我们将这些计数放在一个矩阵中，矩阵的行表示词，列也是词。假如窗口大小为1，我们需要计算当前词左右两边的两个词。比如,我们两个句子：</p><p>$I \quad love \quad NLP \\ I \quad love \quad deep \quad learningI$</p><p>窗口长度为１，我们得到的矩阵为：</p><script type="math/tex; mode=display">\boldsymbol{X} = \begin{array}{c}&\tiny{I}&\tiny{love}&\tiny{NLP}&\tiny{deep}&\tiny{learning}\\\begin{array}{c}\tiny{I} \\\tiny{love} \\\tiny{NLP} \\\tiny{deep} \\\tiny{learning} \\\end{array}\left.\right[&\begin{array}{c}0 \\ 2 \\ 0 \\ 0 \\ 0\end{array}&\begin{array}{c}2 \\ 0 \\ 1 \\ 1 \\ 0\end{array}&\begin{array}{c}0 \\ 1 \\ 0 \\ 0 \\ 0\end{array}&\begin{array}{c}0 \\ 1 \\ 0 \\ 0 \\ 1\end{array}&\begin{array}{c}0 \\ 0 \\ 0 \\ 1 \\ 0\end{array}&\left.\right]\end{array}</script><p>以看到矩阵是对称矩阵，可以行或者列作为词表征。这个矩阵的意义在于假如两个词有相似的context则偏向于有相似的意思，也就是说相似的词有相似的词表征。</p><h4 id="SVD-Singular-Value-Decomposition"><a href="#SVD-Singular-Value-Decomposition" class="headerlink" title="SVD(Singular Value Decomposition)"></a>SVD(Singular Value Decomposition)</h4><p><strong>SVD，奇异值矩阵分解</strong>。对于任意一个矩阵$X$都可以做奇异值分解：</p><script type="math/tex; mode=display">\boldsymbol{X}_{m\times n}=\boldsymbol{U}_{m\times m}\boldsymbol{S}_{m\times n}\boldsymbol{V}^T_{n\times n}</script><p>其中$U$和$V$都是正交矩阵，$S$只有对角元素：</p><script type="math/tex; mode=display">\boldsymbol{S} = \begin{bmatrix}\boldsymbol{S}_1 & \boldsymbol{O}\\\boldsymbol{O} & \boldsymbol{O}\\\end{bmatrix}，\boldsymbol{S}_1=\begin{bmatrix}\sigma_1 &0&\dots&0\\0&\sigma_2 &&\vdots\\\vdots&&\ddots&0\\0&\dots&0&\sigma_r\end{bmatrix}</script><p>其中$\sigma_1…\sigma_r$是矩阵$X$的奇异值。</p><h4 id="LSA-Latent-Semantic-Analysis"><a href="#LSA-Latent-Semantic-Analysis" class="headerlink" title="LSA(Latent Semantic Analysis)"></a>LSA(Latent Semantic Analysis)</h4><p>上述描述的两种矩阵中，都存在一个明显的问题－当出现大量的文档和词的时候，我们得到的矩阵会十分庞大，而且会出现矩阵稀疏问题。后来，有人为了提高相似度的计算准确度，提出了对矩阵进行SVD分解，可以得到更好的词表征。这种方法称为<strong>LSA，潜在语义分析</strong>。LSA是为了研究词表征，另外还有类似的研究文档表征的方法叫<strong>LSI(Latent Semantic Index)</strong>。 我们通过计数统计得到了词-文档矩阵或者词共现矩阵$X$，然后对矩阵$X$使用SVD，取最大的$k$个奇异值，由于每个奇异值对应于$U$的列，因此得到$\hat{\boldsymbol{U}}_{n\times k}$，每一行代表一个词表征，因此可以得到$k$维的词表征。</p><p>优点：降低矩阵稀疏度　减少噪声</p><p>缺点：有新词或新的语料出现，矩阵需要重新计算　矩阵维度高　</p><p>　　　矩阵过于稀疏，很多词无法共现　会出现过高或过低的词频</p><p><strong>Word Embedding</strong> 出现解决了上述问题。</p><h3 id="基于迭代的词表征-词向量"><a href="#基于迭代的词表征-词向量" class="headerlink" title="基于迭代的词表征(词向量)"></a>基于迭代的词表征(词向量)</h3><p>迭代的词表征得到的是一个稠密的向量，与矩阵分解不同的是，词向量是通过迭代训练模型得到。</p><h4 id="NNLM"><a href="#NNLM" class="headerlink" title="NNLM"></a>NNLM</h4><p>这个<a href="http://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf" target="_blank" rel="external">模型</a>是由Bengio大神于2003年发表，可以说是Neural Language Model的开山之作。本来作者的主要目的是建立语言模型，结果发现了词向量这种副产品，由此引发了后人对词向量的火热研究。</p><p>模型使用了一个简单的前向神经网络，如下图所示： </p><p><img src="../img/language_model_bengio.jpg" alt="language_model_bengio"></p><p>该模型通过上下文来预测下一个单词，图中所示的输入为上文的各个词$w_i$，然后将他们的词向量$C(w_i)$连接起来，输出是每个词的概率$P(w_t|content)$，虚线表示的是词向量层和输出层的直接连接。</p><h4 id="Word2vec"><a href="#Word2vec" class="headerlink" title="Ｗord2vec"></a>Ｗord2vec</h4><p>Ｗord2vec这个工具，是Tomas Mikolov在Google的时候开发的用来训练词向量的工具。Ｗord2vec这个工具中有两个模型（CBOW、Skip-Gram），还有两种加速训练的trick（层次Softmax、负采样），下面分别一一讲述。</p><ul><li>$w$表示词</li><li>$x$表示one-hot编码</li><li>$u$和$v$表示词向量</li><li>$x(w)$表示one-hot编码中对应词$w$位置的值，取值为0或1，只有一个位置上的值为1。</li></ul><h5 id="CBOW-Continuous-Bag-of-word-Model"><a href="#CBOW-Continuous-Bag-of-word-Model" class="headerlink" title="CBOW(Continuous Bag-of-word Model)"></a>CBOW(Continuous Bag-of-word Model)</h5><p>模型的网络结构如下：</p><p><img src="../img/cbow.jpg" alt="cbow"></p><p><strong>说明</strong>: </p><p>模型中存在两套词向量。</p><p>一套称为Input词向量，用矩阵$V_{|V|\times d}=(v_1,\dots,v_{|V|})$表示，|V|指的是词表大小，ｄ指词向量维度</p><p>一套称为Output词向量，用矩阵$U_{|V|\times d}=(v_1,\dots,v_{|V|})$表示</p><p><strong>建模过程</strong></p><ul><li><p>确定一个窗口大小m</p></li><li><p>选定目标词位置t。得到该位置的上下文：</p><script type="math/tex; mode=display">(w^{(t−m)},...,w^{(t−1)},w^{(t+1)},...,w^{(t+m)})</script></li><li><p>得到上下文各个词的one-hot表示：</p><script type="math/tex; mode=display">(x^{(t−m)},...,x^{(t−1)},x^{(t+1)},...,x^{(t+m)})</script></li><li><p>使用矩阵$V$，计算$v = Vx$得到上下文的词向量（对于图中的<strong>INPUT层</strong>）</p><script type="math/tex; mode=display">(v^{(t−m)},...,v^{(t−1)},v^{(t+1)},...,v^{(t+m)})</script></li><li><p>将上下文的词向量相加或者平均，得到。<strong>（对应图中的PROJECTION层）</strong>： </p><script type="math/tex; mode=display">\hat{v} = \dfrac{v^{(t−m)}+\dots+v^{(t−1)}+v^{(t+1)}+\dots+v^{(t+m)}}{2m}</script></li><li><p>使用矩阵$U$，计算目的词的概率分布<strong>（对应图中的OUTPUT层）</strong>:</p><script type="math/tex; mode=display">P(w \mid w^{(t−m)},...,w^{(t−1)},w^{(t+1)},...,w^{(t+m)})=\text{softmax}(U\hat{v})=\dfrac{e^{u\hat{v}}}{\sum\limits_{u_i\in U}{e^{u_i\hat{v}}}}</script></li><li><p>使用负对数似然（又称交叉熵）损失函数$J$：</p><script type="math/tex; mode=display"><Empty \space Math \space Block></script><script type="math/tex; mode=display">\begin{align*}    J &= -\sum_{w} x^t(w)\log P(w \mid w^{(t−m)},...,w^{(t−1)},w^{(t+1)},...,w^{(t+m)})\\    &= -\log P(w^t \mid w^{(t−m)},...,w^{(t−1)},w^{(t+1)},...,w^{(t+m)})    \end{align*}</script></li></ul><p><strong>训练过程</strong></p><ul><li><p>选取batch的大小n</p></li><li><p>使用SGD训练，对于每个训练样本的损失函数$J_i$，构造batch的损失函数：</p><script type="math/tex; mode=display">J_{batch} = \sum_i^n J_i</script></li><li><p>每一轮迭代更新$U$和$V$</p></li></ul><h5 id="Skip-Gram-Continuous-Skip-gram-Model"><a href="#Skip-Gram-Continuous-Skip-gram-Model" class="headerlink" title="Skip-Gram(Continuous Skip-gram Model)"></a>Skip-Gram(Continuous Skip-gram Model)</h5><p>既然可以用上下文来预测目标词，反过来也能用目标词来预测上下文，Skip-Gram因此应运而生。</p><p><img src="../img/Skip-Gram.jpg" alt="Skip-Gram"></p><p>与CBOW一样，模型中存在两套词向量$U$和$V$。</p><p><strong>建模过程</strong></p><ul><li><p>确定Context的窗口大小$m$。</p></li><li><p>选取一个目标词$w^t$，然后在目标词的Context中的选择一个词$w^c$，组成训练样本： </p><script type="math/tex; mode=display">(w^t, w^c)</script></li><li><p>得到训练样本one-hot表示为：$(x^t,x^c)$</p></li><li><p>使用矩阵$V$，得到目标词的词向量<strong>（对应图中INPUT层）</strong>：$v^t = c^tV$</p></li><li><p>由于只有一个词，所以不需要相加或者平均，直接复制到下一层<strong>（对应PROJECTION层）</strong>： $\hat{v} = v^t$</p></li><li><p>使用矩阵$U$，计算上下文中的词的概率分布<strong>（对应图中的OUTPUT层）</strong>： </p><script type="math/tex; mode=display">P(w \mid w^t) = \text{softmax}(U\hat{v}) = \dfrac{e^{u\hat{v}}}{\sum\limits_{u_i\in U}{e^{u_i\hat{v}}}}</script></li><li><p>使用负对数似然（又称交叉熵）损失函数$J$：</p><script type="math/tex; mode=display">J = -\sum_{w} x^c(w)\log P(w \mid w^t) = -\log P(w^c \mid w^t)</script></li></ul><p><strong>训练过程</strong></p><ul><li><p>选取batch的大小n</p></li><li><p>使用SGD训练，对于每个训练样本的损失函数$J_i$，构造batch的损失函数：</p><script type="math/tex; mode=display">J_{batch} = \sum_i^n J_i</script></li><li><p>每一轮迭代更新$U$和$V$</p></li></ul><h5 id="加速技巧"><a href="#加速技巧" class="headerlink" title="加速技巧"></a>加速技巧</h5><p>Word2vec的训练是无监督的，我们只需要分好词，在训练的时候像有监督一样进行梯度下降。因此，在训练模型的时候，我们需要同时更新$U$和$V$。</p><p>从公式可以看出，每次迭代只需要更新矩阵中的少量向量（Skip-Gram中是一个）。然而如果我们使用简单的Softmax，我们就要每次都更新整个$U$，假如词表大小到达千万级以上，可想而知这是多么耗时。因此，我们需要一些Trick来加速训练。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自然语言处理－词向量&quot;&gt;&lt;a href=&quot;#自然语言处理－词向量&quot; class=&quot;headerlink&quot; title=&quot;自然语言处理－词向量&quot;&gt;&lt;/a&gt;自然语言处理－词向量&lt;/h2&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在计算机视觉中，作为输入的图片可以直接数值化。在语言识别中，作为输入的语音也可以直接数值化。而在自然语言处理中，我们无法将文字直接数值化，为了能够让计算机处理文字，我们需要将文字映射到一个数值空间。由于词是组成语义的基本单位，所以对词的表述就显得尤为重要，我们把词的数值（表征）表示为&lt;strong&gt;Word Representation&lt;/strong&gt;，一般来说，词向量经常指&lt;strong&gt;Word Embedding&lt;/strong&gt;，也称&lt;strong&gt;Distributed Word Representation&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;从&lt;strong&gt;Word Representation&lt;/strong&gt;的发展过程引入&lt;strong&gt;Word Embedding&lt;/strong&gt;，先从简单的SVD介绍开始，再到NNLM,word2vec等词向量模型。&lt;/p&gt;
&lt;h3 id=&quot;one-hot编码&quot;&gt;&lt;a href=&quot;#one-hot编码&quot; class=&quot;headerlink&quot; title=&quot;one-hot编码&quot;&gt;&lt;/a&gt;one-hot编码&lt;/h3&gt;&lt;p&gt;one-hot编码也称独热编码，这是一种简单的词表征方式，每个词使用一个$R^{|V|}$的向量表示，$|V|$表示词表的大小。&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
w^{address}=\begin{bmatrix}
1\\0\\0\\\vdots\\0
\end{bmatrix},w^{home}=\begin{bmatrix}
0\\1\\0\\\vdots\\0
\end{bmatrix},w^{at}=\begin{bmatrix}
0\\0\\1\\\vdots\\0
\end{bmatrix}&lt;/script&gt;&lt;p&gt;使用one-hot编码的词向量之间是相互独立的，因为对于每个词$(w^{i})^{T}w^j = 0$，这种编码方式并没有编码不同词之间的语义相似性。&lt;/p&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="word_embedding" scheme="http://yoursite.com/tags/word-embedding/"/>
    
  </entry>
  
  <entry>
    <title>王家卫电影台词</title>
    <link href="http://yoursite.com/2017/12/17/Wong/"/>
    <id>http://yoursite.com/2017/12/17/Wong/</id>
    <published>2017-12-17T09:05:26.000Z</published>
    <updated>2017-12-21T12:35:01.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="东邪西毒"><a href="#东邪西毒" class="headerlink" title="东邪西毒"></a>东邪西毒</h2><p>从小我就懂得保护自己，我知道要想不被人拒绝，最好的办法就是先拒绝别人。<br>我曾经听人说过，当你不可以再拥有的时候。你唯一可以做的，就是让自己不要忘记。<br>你越想忘记一个人时，其实你越会记得他。人的烦恼就是记性太好，如果可以把所有事都忘掉，以后每一日都是个新开始，你说多好。<br>每个人都会经过这个阶段，见到一座山，就想知道山后面是什么。我很想告诉他，可能翻过山后面，你会发现没什么特别。回望之下，可能会觉得这一边更好。<br>多年之后，我有个绰号叫西毒，任何人都可以变得狠毒，只要你尝试过什么叫做嫉妒。<br>其实“醉生梦死”只不过是她跟我开的一个玩笑，你越想知道自己是不是忘记的时候，你反而记得更清楚。我曾经听人说过，当你不能够再拥有，你唯一可以做的，就是令自己不要忘记。<br>知不知道饮酒和饮水有什么区别？酒越饮越暖，水越喝越寒。</p><a id="more"></a><p>有些人是离开之后，才会发现离开了的人才是自己的最爱。<br>每个人都会坚持自己的信念，在别人来看是浪费时间，她却觉得很重要。<br>不久前，我遇上一个人，送给我一坛酒，她说那叫“醉生梦死”，喝了之后，可以叫你忘掉以前做过的任何事。我很奇怪，为什么会有这样的酒。她说人最大的烦恼，就是记性太好，如果什么都可以忘掉，以后的每一天将会是一个新的开始，那你说这有多开心。<br>虽然我很喜欢她，但是我不想让她知道，因为我明白得不到的东西永远是最好的。每次她凝望着那小孩子，我知道她心里其实在想另一个人。我很妒忌欧阳峰，我很想知道被人喜欢的感觉是怎样的，结果我伤害了很多人。<br>有些事情你越想忘记，就会记得越牢。当有些事情你无法得到时，你惟一能做的，就是不要忘记。<br>以前我认为那句话很重要 因为我觉得有些话说出来就是一生一世 现在想一想 说不说也没有什么分别 有些事会变的。<br>以前也这么想，但是看着他一天天长大，我知道他早晚会离开我。现在我觉得什么都无所谓啦。以前我认为那句话很重要，因为我觉得有些话说出来就是一生一世，现在想一想，说不说也没有什么分别，有些事会变的。我一直以为是我自己赢了，直到有一天看着镜子，才知道自己输了，在我最美好的时候，我最喜欢的人都不在我身边。如果能重新开始那该多好啊！<br>我曾经问过自己，你最喜欢的女人是不是我，现在我已经不想再知道啦。如果有一天我忍不住问起，你一定要骗我，就算你心里有多么不愿意，也不要告诉我你最喜欢的人不是我。<br>我知道那个人不会再来，可是我还是再等。我在门口坐了两天两夜，看着天空在不断的变化，我才发现原来我到这里这么久，却从来没有看清楚这片天空。<br>告诉你，你这样看着我，可是非常有危险的。因为你随时可能爱上我。<br>每个人都会坚持自己的信念，在别人来看是浪费时间，她却觉得很重要。</p><h2 id="春光乍泄"><a href="#春光乍泄" class="headerlink" title="春光乍泄"></a>春光乍泄</h2><p>一直以为我跟何宝荣不一样，原来寂寞的时候，所有的人都一样。<br>我终于来到瀑布，我突然想起何宝荣，我觉得好难过，我始终认为站在这儿的应该是两个人。<br>一个人可以假装开心，但声音就装不了，仔细一听就知道了。<br>跟他接近得多了，我什么也听不到，只听见自己的心在跳，不知他可有听到？<br>我终于明白，他为什么那么开心在外面走来走去，是因为他知道自己有个地方让他回去。<br>很多事情我都没有告诉何宝荣，我并不希望他赶快好起来，他受伤的那段日子，是我们最快乐的时光。<br>愈是期待愈是美丽来让这夜春光代替难道要等青春全枯萎 至得到一切<br>黎耀辉，不如我们由头来过吧。</p><h2 id="重庆森林"><a href="#重庆森林" class="headerlink" title="重庆森林"></a>重庆森林</h2><p>我和她接近的时候，我们之间的距离只有0.01公分，我对她一无所知，57个小时之后，我爱上了她。<br>每天你都有机会和很多人擦身而过，而你或者对他们一无所知，不过也许有一天他会变成你的朋友或是知己， 我是一个警察，我的名字叫何志武，编号223。<br>每个人都有失恋的时候，而每一次我失恋呢，我就会去跑步，因为跑步可以将你身体里面的水分蒸发掉，而让我不那么容易流泪，我怎么可以流泪呢？在阿美的心中里面，我可是一个很酷的男人。<br> 从分手的那一天开始，我每天买一罐5月1号到期的凤梨罐头，因为凤梨是阿美最爱吃的东西，而5月1号是我的生日。 我告诉我自己，当我买满30罐的时候， 她如果还不回来，这段感情就会过期。<br>不知道从什么时候开始，在什么东西上面都有个日期，秋刀鱼会过期，肉罐头会过期，连保鲜纸都会过期，我开始怀疑，在这个世界上，还有什么东西是不会过期的？<br>在1994年的5月1号，有一个女人跟我讲了一声“生日快乐”，因为这一句话，我会一直记住这个女人。如果记忆也是一个罐头的话，我希望这罐罐头不会过期；如果一定要加一个日子的话，我希望她是一万年。<br>其实了解一个人并不代表什么，人是会变的，今天他喜欢凤梨，明天他可以喜欢别的。<br>不知道什么时候开始，我变成一个很小心的人，每次我穿雨衣的时候，我都会戴太阳眼镜，你永远都不会知道什么时候会下雨，什么时候出太阳。<br>我没有想到她说的休息就是真正的休息，整个晚上我看了两套粤语长片，吃了四次厨师沙拉。当天差不多快亮的时候，我知道我该走了。在我要走的时候，我帮她脱了鞋子。我记得我妈说过，如果女人穿着高跟鞋睡觉，第二天会脚肿。她昨天晚上一定是走了很长的路，象她这样漂亮的女人，高跟鞋应该是要很干净的才对。<br>有时候，耳朵比眼睛还重要，很多东西用耳朵听比用眼睛看好，一个人可以假装开心，但声音就装不了，仔细一听就知道了。<br>不知道是我忘了关水龙头，还是房子越来越有感情。我一直以为它是最坚强的，没想到它哭得最厉害。一个人哭，你只需要给他一包纸巾，可是一个房子哭，你可要做多很多功夫。<br>那天下午我做了个梦，我到了他的家，走出那房子的时候，我以为我会醒来，谁知道，原来有些梦是永远不会醒的。<br>看着它哭的时候，我很开心，因为它外表好像改变了，可是它的本质没有变，它依然是一条感情丰富的毛巾。<br>也对，宵夜都有那么多选择，何况男朋友。</p><h2 id="花样年华"><a href="#花样年华" class="headerlink" title="花样年华"></a>花样年华</h2><p>那是一种难堪的相对。她一直低着头，给他一个接近的机会。他没有勇气接近，她掉转头，走了……<br> 我从来没有想到，婚姻会这么复杂。还以为一个人，做的好就行了。可是两个人在一起，单是自己做的好是不够的。<br>其实我跟你一样。只是我不去想。又不是我的错，为什么老是问自己做错什么，何必浪费时间呢。我不想这样下去。<br>如果我有一张船票，你，会不会跟我走？<br>那些消失了的岁月，仿佛隔着一块积着灰尘的玻璃，看得到，抓不着。他一直在怀念着过去的一切。如果他能冲破那块积着灰尘的玻璃，他会走回早已消失的岁月。<br>本来我也这么想，所以不怕别人说什么，我相信自己不会跟他们一样，可是原来我会。<br>以前的人，心中如果有什么不可告人的秘密，他们会跑到山上，找一棵树，在树上挖一个洞，然后把秘密全说进去，再用泥巴把洞封上，那秘密就会永远留在那棵树里，没有人会知道。<br>如果我有一张船票，你，会不会跟我走？</p><h2 id="阿飞正传"><a href="#阿飞正传" class="headerlink" title="阿飞正传"></a>阿飞正传</h2><p>我听别人说这世界上有一种鸟是没有脚的，它只能够一直的飞呀飞呀，飞累了就在风里面睡觉，这种鸟一辈子只能下地一次，那一次就是它死亡的时候。<br>十六号，四月十六号。一九六零年四月十六号下午三点之前的一分钟你和我在一起，因为你我会记住这一分钟。从现在开始我们就是一分钟的朋友，这是事实，你改变不了，因为已经过去了。我明天会再来。<br>我以前以为一分钟很快就会过去，其实是可以很长的。有一天有个人指着手表跟我说，他说会因为那一分钟而永远记住我，那时候我觉得很动听……但现在我看着时钟，我就告诉自己，我要从这一分钟开始忘掉这个人。</p><h2 id="堕落天使"><a href="#堕落天使" class="headerlink" title="堕落天使"></a>堕落天使</h2><p>当你年轻时，以为什么都有答案，可是老了的时候，你可能又觉得其实人生并没有所谓的答案。每天你都有机会和很多人擦身而过，有些人可能会变成你的朋友或者是知己，所以我从来没有放弃任何跟人磨擦的机会。有时候搞得自己头破血流，管他呢！开心就行了。<br>跟一个人合作久了，你的习惯或多或少会受他的影响。虽然我很熟悉这种香水，可是我怎么也不习惯从别的女人身上闻到。<br>做拍档，除了要了解她外，还要给机会让她了解你。<br>有些人是不适合太接近的，知道得太多反而没有兴趣。我是一个很现实的人，我知道怎样可以让自己更加快乐。</p><h2 id="一代宗师"><a href="#一代宗师" class="headerlink" title="一代宗师"></a>一代宗师</h2><p>念念不忘，必有回响。<br>叶里藏花一度，梦里踏雪几回。<br>人生如棋，落子无悔。<br>有时候我昨天遇到一个人，感觉他非常有意思，印象深刻。但后来就再也碰不上了，人生就是这样。</p><script type="math/tex; mode=display">从此只有眼前路，没有身后身。</script><p>我在最好的时候碰到你,是我的运气。可惜我没时间了。想想,说人生无悔,都是赌气的话。人生若无悔,那该多无趣啊。我心里有过你。可我也只能到喜欢为止了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;东邪西毒&quot;&gt;&lt;a href=&quot;#东邪西毒&quot; class=&quot;headerlink&quot; title=&quot;东邪西毒&quot;&gt;&lt;/a&gt;东邪西毒&lt;/h2&gt;&lt;p&gt;从小我就懂得保护自己，我知道要想不被人拒绝，最好的办法就是先拒绝别人。&lt;br&gt;我曾经听人说过，当你不可以再拥有的时候。你唯一可以做的，就是让自己不要忘记。&lt;br&gt;你越想忘记一个人时，其实你越会记得他。人的烦恼就是记性太好，如果可以把所有事都忘掉，以后每一日都是个新开始，你说多好。&lt;br&gt;每个人都会经过这个阶段，见到一座山，就想知道山后面是什么。我很想告诉他，可能翻过山后面，你会发现没什么特别。回望之下，可能会觉得这一边更好。&lt;br&gt;多年之后，我有个绰号叫西毒，任何人都可以变得狠毒，只要你尝试过什么叫做嫉妒。&lt;br&gt;其实“醉生梦死”只不过是她跟我开的一个玩笑，你越想知道自己是不是忘记的时候，你反而记得更清楚。我曾经听人说过，当你不能够再拥有，你唯一可以做的，就是令自己不要忘记。&lt;br&gt;知不知道饮酒和饮水有什么区别？酒越饮越暖，水越喝越寒。&lt;/p&gt;
    
    </summary>
    
      <category term="影音" scheme="http://yoursite.com/categories/%E5%BD%B1%E9%9F%B3/"/>
    
    
      <category term="影音" scheme="http://yoursite.com/tags/%E5%BD%B1%E9%9F%B3/"/>
    
      <category term="书名" scheme="http://yoursite.com/tags/%E4%B9%A6%E5%90%8D/"/>
    
  </entry>
  
</feed>
