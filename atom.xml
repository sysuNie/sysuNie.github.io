<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sysuNie</title>
  
  <subtitle>Morning, Noon, Night.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-28T08:35:25.748Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JiKang Nie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>concrete_NLP</title>
    <link href="http://yoursite.com/2018/01/28/concrete-NLP/"/>
    <id>http://yoursite.com/2018/01/28/concrete-NLP/</id>
    <published>2018-01-28T06:27:00.000Z</published>
    <updated>2018-01-28T08:35:25.748Z</updated>
    
    <content type="html"><![CDATA[<p>虽然存在丰富的精细和抽象的NLP技术，但集群和分类应始终作为处理这类数据时使用的第一种技术。 除了在生产中最容易扩展之外，它们的易用性可以迅速帮助企业解决一系列应用问题：</p><ul><li>如何自动区分不同类别的句子？</li><li>如何找到一个数据集中最相似的句子？</li><li>如何提取一个丰富而简洁的表示，然后可以用于一系列其他任务？</li><li>如何快速找到这些任务是否可以在你的数据集上？</li></ul><p>这篇文章的作用是提供一个简单方式的寻找句子表示，以便将它们分类或组合在一起。</p><h3 id="收集数据"><a href="#收集数据" class="headerlink" title="收集数据"></a>收集数据</h3><h4 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h4><p>每个机器学习问题都是从数据开始，例如电子邮件、帖子或推文。文本信息常见来源包括：</p><ul><li>产品评论（来自亚马逊，Yelp和各种原因商店）</li><li>用户发布的内容（推文，facebook帖子，stackOverflow问题）</li><li>故障排除（客户请求，聊天记录）</li></ul><p>本文我们使用的是由 <a href="https://www.crowdflower.com/data-for-everyone/" target="_blank" rel="external">Crowdflower</a>提供的名为“社交媒体中出现的灾难”数据集，其中：</p><p>投稿人查看了超过10000条推文，包括“着火”，“隔离”和“混乱”等各种检索，然后看推文是否是指灾难事件（排除掉用单词或电影评论的笑话， 一些非灾难性的）。</p><p>我们将尝试正确预测关于灾难的推文。 这是一个非常相关的问题，因为：</p><ul><li>任何试图从噪音中获得信号的人都可以采取行动（比如在这种情况下的警察部门）</li><li>这是棘手的，因为依赖于关键字比在大多数情况下像垃圾邮件更难</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding( <span class="string">"utf-8"</span> )</div><div class="line"><span class="keyword">import</span> keras</div><div class="line"><span class="keyword">import</span> nltk</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> codecs</div></pre></td></tr></table></figure><h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h3><p>让我们确保我们的推文只有我们想要的字符。 我们删除’＃’字符，但保留’＃’后的单词，因为它们可能是相关的（例如：#disaster）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">input_file = codecs.open(<span class="string">"socialmedia_relevant_cols.csv"</span>, <span class="string">"r"</span>,encoding=<span class="string">'utf-8'</span>, errors=<span class="string">'replace'</span>)</div><div class="line">output_file = open(<span class="string">"socialmedia_relevant_cols_clean.csv"</span>, <span class="string">"w"</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sanitize_characters</span><span class="params">(raw, clean)</span>:</span>    </div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> input_file:</div><div class="line">        out = line</div><div class="line">        output_file.write(line)</div><div class="line">sanitize_characters(input_file, output_file)</div></pre></td></tr></table></figure><h4 id="检查数据"><a href="#检查数据" class="headerlink" title="检查数据"></a>检查数据</h4><p>它看起来很稳固，但我们并不需要网址，我们希望我们的文字都是小写字母（Hello和HELLO对我们的任务来说非常相似）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">questions = pd.read_csv(<span class="string">"socialmedia_relevant_cols_clean.csv"</span>)</div><div class="line">questions.columns=[<span class="string">'text'</span>, <span class="string">'choose_one'</span>, <span class="string">'class_label'</span>]</div><div class="line">questions.head()</div></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">text</th><th style="text-align:center">choose_one</th><th style="text-align:center">class_label</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">Just happened a terrible car crash</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">Our Deeds are the Reason of this #earthquake M…</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Heard about #earthquake is different cities, s…</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">there is a forest fire at spot pond, geese are…</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Forest fire near La Ronge Sask. Canada</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">questions.tail()</div></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">text</th><th style="text-align:center">choose_one</th><th style="text-align:center">class_label</th></tr></thead><tbody><tr><td style="text-align:center">10871</td><td style="text-align:center">M1.94 [01:04 UTC]?5km S of Volcano Hawaii. htt…</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">10872</td><td style="text-align:center">Police investigating after an e-bike collided …</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">10873</td><td style="text-align:center">The Latest: More Homes Razed by Northern Calif…</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">10874</td><td style="text-align:center">MEG issues Hazardous Weather Outlook (HWO)</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">10875</td><td style="text-align:center">CityofCalgary has activated its Muni</td><td style="text-align:center">NaN</td><td style="text-align:center">NaN</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">questions.describe()</div></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">class_label</th></tr></thead><tbody><tr><td style="text-align:center">count</td><td style="text-align:center">10875.000000</td></tr><tr><td style="text-align:center">mean</td><td style="text-align:center">0.432552</td></tr><tr><td style="text-align:center">std</td><td style="text-align:center">0.498414</td></tr><tr><td style="text-align:center">min</td><td style="text-align:center">0.000000</td></tr><tr><td style="text-align:center">25%</td><td style="text-align:center">0.000000</td></tr><tr><td style="text-align:center">50%</td><td style="text-align:center">0.000000</td></tr><tr><td style="text-align:center">75%</td><td style="text-align:center">1.000000</td></tr><tr><td style="text-align:center">max</td><td style="text-align:center">2.000000</td></tr></tbody></table></div><p>让我们使用一些正则表达式来清理不必要的数据，并将其保存回csv文件供将来使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">standardize_text</span><span class="params">(ques, text_field)</span>:</span></div><div class="line">    ques[text_field] = ques[text_field].str.replace(<span class="string">r"http\S+"</span>, <span class="string">""</span>)</div><div class="line">    ques[text_field] = ques[text_field].str.replace(<span class="string">r"http"</span>, <span class="string">""</span>)</div><div class="line">    ques[text_field] = ques[text_field].str.replace(<span class="string">r"@\S+"</span>, <span class="string">""</span>)</div><div class="line">    ques[text_field] = ques[text_field].str.replace(<span class="string">r"[^A-Za-z0-9(),!?@\'\`\"\_\n]"</span>, <span class="string">" "</span>)</div><div class="line">    ques[text_field] = ques[text_field].str.replace(<span class="string">r"@"</span>, <span class="string">"at"</span>)</div><div class="line">    ques[text_field] = ques[text_field].str.lower()</div><div class="line">    <span class="keyword">return</span> ques</div><div class="line">questions = standardize_text(questions, <span class="string">"text"</span>)</div><div class="line">questions.to_csv(<span class="string">"clean_data.csv"</span>)</div><div class="line">questions.head()</div></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">text</th><th style="text-align:center">choose_one</th><th style="text-align:center">class_label</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">just happened a terrible car crash</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">our deeds are the reason of this  earthquake m…</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">heard about  earthquake is different cities, s…</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">there is a forest fire at spot pond, geese are…</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">forest fire near la ronge sask  canada</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clean_questions = pd.read_csv(<span class="string">"clean_data.csv"</span>)</div><div class="line">clean_questions.tail()</div></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">text</th><th style="text-align:center">choose_one</th><th style="text-align:center">class_label</th></tr></thead><tbody><tr><td style="text-align:center">10871</td><td style="text-align:center">m1 94  01 04 utc ?5km s of volcano hawaii</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">10872</td><td style="text-align:center">police investigating after an e bike collided …</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">10873</td><td style="text-align:center">the latest  more homes razed by northern calif…</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">10874</td><td style="text-align:center">meg issues hazardous weather outlook (hwo)</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">10875</td><td style="text-align:center">cityofcalgary has activated its muni</td><td style="text-align:center">NaN</td><td style="text-align:center">NaN</td></tr></tbody></table></div><h3 id="数据概述"><a href="#数据概述" class="headerlink" title="数据概述"></a>数据概述</h3><p>让我们来看看我们的class_label</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clean_questions.groupby(<span class="string">"class_label"</span>).count()</div></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Unnamed: 0</th><th style="text-align:center">text</th><th style="text-align:center">choose_one</th></tr></thead><tbody><tr><td style="text-align:center">class_label</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">0.0</td><td style="text-align:center">6187</td><td style="text-align:center">6187</td><td style="text-align:center">6187</td></tr><tr><td style="text-align:center">1.0</td><td style="text-align:center">4672</td><td style="text-align:center">4672</td><td style="text-align:center">4672</td></tr><tr><td style="text-align:center">2.0</td><td style="text-align:center">16</td><td style="text-align:center">16</td><td style="text-align:center">16</td></tr></tbody></table></div><p>我们可以看到我们的类非常平衡，对“不相关的”类稍加过度抽样。</p><p><strong>我们的数据很干净，现在需要做好准备</strong></p><p>现在我们的输入数据是更合理的，让我们以我们的模型可以理解的方式来改变我们的输入数据。</p><p>这意味着：</p><ul><li>将句子标记为单独的单词列表</li><li>创建训练集好测试集</li><li>仔细检查我们的数据来验证结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> nltk.tokenize <span class="keyword">import</span> RegexpTokenizer</div><div class="line">tokenizer = RegexpTokenizer(<span class="string">r'\w+'</span>)</div><div class="line">clean_questions[<span class="string">"tokens"</span>] = clean_questions[<span class="string">"text"</span>].apply(tokenizer.tokenize)</div><div class="line">clean_questions.head()</div></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Unnamed: 0</th><th style="text-align:center">text</th><th style="text-align:center">choose_one</th><th style="text-align:center">class_label</th><th>tokens</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">just happened a terrible car crash</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td><td>[just, happened, a, terrible, car, crash]</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">our deeds are the reason of this  earthquake m…</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td><td>[our, deeds, are, the, reason, of, this, earth…</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">heard about  earthquake is different cities, s…</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td><td>[heard, about, earthquake, is, different, citi…</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">there is a forest fire at spot pond, geese are…</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td><td>[there, is, a, forest, fire, at, spot, pond, g…</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">forest fire near la ronge sask  canada</td><td style="text-align:center">Relevant</td><td style="text-align:center">1.0</td><td>[forest, fire, near, la, ronge, sask, canada]</td></tr></tbody></table></div><h4 id="深入挖掘数据"><a href="#深入挖掘数据" class="headerlink" title="深入挖掘数据"></a>深入挖掘数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> keras.preprocessing.text <span class="keyword">import</span> Tokenizer</div><div class="line"><span class="keyword">from</span> keras.preprocessing.sequence <span class="keyword">import</span> pad_sequences</div><div class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> to_categorical</div><div class="line">all_words = [word <span class="keyword">for</span> tokens <span class="keyword">in</span> clean_questions[<span class="string">'tokens'</span>] <span class="keyword">for</span> word <span class="keyword">in</span> tokens]</div><div class="line">sentence_lengths = [len(tokens) <span class="keyword">for</span> tokens <span class="keyword">in</span> clean_questions[<span class="string">"tokens"</span>]]</div><div class="line">VOCAB = sorted(list(set(all_words)))</div><div class="line">print(<span class="string">"%s words total, with a vocabulary size of %s"</span> % (len(all_words), len(VOCAB)))</div><div class="line">print(<span class="string">"Max sentence length is %s"</span> % max(sentence_lengths))</div></pre></td></tr></table></figure><blockquote><p>154721 words total, with a vocabulary size of 18102<br>Max sentence length is 34</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>)) </div><div class="line">plt.xlabel(<span class="string">'Sentence length'</span>)</div><div class="line">plt.ylabel(<span class="string">'Number of sentences'</span>)</div><div class="line">plt.hist(sentence_lengths)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAm4AAAJQCAYAAAA32OjOAAAABHNCSVQICAgIfAhkiAAAAAlwSFlz%0AAAALEgAACxIB0t1+/AAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDIuMS4wLCBo%0AdHRwOi8vbWF0cGxvdGxpYi5vcmcvpW3flQAAIABJREFUeJzt3X/U7XVd5/3XW0ArdQYYz7AYxA66%0AqHtRU+iczB/lUE2KMiPlbf5YTZG5Bp2wobvue83RqXBynKEfWmPLKEpGXMuRzMxImJAYxXuaO+VA%0A+AOQOCEGhIBRCnmHg77nj/09tTnnXNfZB86+9vXhejzWuta19+faP97nu3by7Lv3d3+ruwMAwOb3%0AqFUPAADAYoQbAMAghBsAwCCEGwDAIIQbAMAghBsAwCCEGwDAIIQbAMAghBsAwCAOX/UAy/CEJzyh%0At2/fvuoxAAAO6Oqrr/5cd29b5LaPyHDbvn17du3ateoxAAAOqKo+s+htvVUKADAI4QYAMAjhBgAw%0ACOEGADCIpYVbVR1fVR+squur6rqqOntaf31V3V5V104/L5i7z2urandV3VhVz5tbP3Va211VO5c1%0AMwDAZrbMo0ofSPIT3X1NVT0+ydVVdfn0t1/s7l+Yv3FVnZTkZUm+Ick/SvIHVfV105/fmuS7k9yW%0A5Kqquri7r1/i7AAAm87Swq2770hyx3T53qq6Iclx69zl9CQXdff9ST5dVbuTPH362+7uvjlJquqi%0A6bbCDQDYUjbkM25VtT3JU5N8ZFp6TVV9vKouqKqjprXjktw6d7fbprW11vd+jjOraldV7br77rsP%0A8b8AAGD1lh5uVfW4JL+d5Me6+wtJzkvylCQnZ7ZH7k2H4nm6+/zu3tHdO7ZtW+jLhwEAhrLUMydU%0A1RGZRds7u/u9SdLdd879/deTvH+6enuS4+fu/sRpLeusAwBsGcs8qrSSvC3JDd395rn1Y+du9r1J%0APjldvjjJy6rqMVV1QpITk3w0yVVJTqyqE6rq0ZkdwHDxsuYGANislrnH7dlJfiDJJ6rq2mntdUle%0AXlUnJ+kktyR5VZJ093VV9e7MDjp4IMlZ3f3lJKmq1yS5LMlhSS7o7uuWODcAwKZU3b3qGQ65HTt2%0AtJPMAwAjqKqru3vHIrd15gQAgEEINwCAQQg3AIBBCDcAgEEINwCAQQg3AIBBCDcAgEEINwCAQQg3%0AAIBBCDcAgEEINwCAQSzzJPPAw7B95yWrHuGQueXc01Y9AsAjgj1uAACDEG4AAIMQbgAAgxBuAACD%0AEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBu%0AAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAA%0AgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQ%0AbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4A%0AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACD%0AEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBu%0AAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAA%0AgxBuAACDEG4AAINYWrhV1fFV9cGqur6qrquqs6f1o6vq8qq6afp91LReVfWWqtpdVR+vqqfNPdYZ%0A0+1vqqozljUzAMBmtsw9bg8k+YnuPinJM5KcVVUnJdmZ5IruPjHJFdP1JHl+khOnnzOTnJfMQi/J%0AOUm+NcnTk5yzJ/YAALaSpYVbd9/R3ddMl+9NckOS45KcnuTC6WYXJvme6fLpSd7RM3+U5MiqOjbJ%0A85Jc3t33dPdfJrk8yanLmhsAYLPakM+4VdX2JE9N8pEkx3T3HdOfPpvkmOnycUlunbvbbdPaWut7%0AP8eZVbWrqnbdfffdh3R+AIDNYOnhVlWPS/LbSX6su78w/7fu7iR9KJ6nu8/v7h3dvWPbtm2H4iEB%0AADaVpYZbVR2RWbS9s7vfOy3fOb0Fmun3XdP67UmOn7v7E6e1tdYBALaUZR5VWkneluSG7n7z3J8u%0ATrLnyNAzkvzu3PoPTkeXPiPJ56e3VC9L8tyqOmo6KOG50xoAwJZy+BIf+9lJfiDJJ6rq2mntdUnO%0ATfLuqnplks8kecn0t0uTvCDJ7iRfTPKKJOnue6rqDUmumm73M919zxLnBgDYlJYWbt39P5LUGn/+%0Arv3cvpOctcZjXZDkgkM3HQDAeJw5AQBgEMINAGAQwg0AYBDCDQBgEMINAGAQwg0AYBDCDQBgEMIN%0AAGAQwg0AYBDCDQBgEMINAGAQwg0AYBDCDQBgEMINAGAQwg0AYBDCDQBgEMINAGAQwg0AYBDCDQBg%0AEMINAGAQwg0AYBDCDQBgEMINAGAQh696AOCRb/vOS1Y9wiFxy7mnrXoEYIuzxw0AYBDCDQBgEMIN%0AAGAQwg0AYBDCDQBgEMINAGAQwg0AYBDCDQBgEMINAGAQwg0AYBDCDQBgEMINAGAQwg0AYBDCDQBg%0AEMINAGAQwg0AYBDCDQBgEMINAGAQwg0AYBDCDQBgEMINAGAQwg0AYBDCDQBgEMINAGAQwg0AYBDC%0ADQBgEMINAGAQh696ADiUtu+8ZNUjAMDS2OMGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEG%0AADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAw%0ACOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjh%0ABgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYA%0AMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADCIA4ZbVT22qh41Xf66qnphVR2xwP0uqKq7quqTc2uv%0Ar6rbq+ra6ecFc397bVXtrqobq+p5c+unTmu7q2rnwf8TAQAeGRbZ4/bhJF9VVccl+UCSH0jy9gXu%0A9/Ykp+5n/Re7++Tp59IkqaqTkrwsyTdM9/mVqjqsqg5L8tYkz09yUpKXT7cFANhyFgm36u4vJnlR%0Akl/p7u/LLLDW1d0fTnLPgnOcnuSi7r6/uz+dZHeSp08/u7v75u7+UpKLptsCAGw5C4VbVT0zyfcn%0AuWRaO+xhPOdrqurj01upR01rxyW5de42t01ra63vb8gzq2pXVe26++67H8Z4AACb0yLh9mNJXpvk%0Ad7r7uqp6cpIPPsTnOy/JU5KcnOSOJG96iI+zj+4+v7t3dPeObdu2HaqHBQDYNA4/0A26+8okV1bV%0A10zXb07ybx7Kk3X3nXsuV9WvJ3n/dPX2JMfP3fSJ01rWWQcA2FIWOar0mVV1fZJPTde/uap+5aE8%0AWVUdO3f1e5PsOeL04iQvq6rHVNUJSU5M8tEkVyU5sapOqKpHZ3YAw8UP5bkBAEZ3wD1uSX4pyfMy%0ABVN3f6yqnnOgO1XVu5KckuQJVXVbknOSnFJVJyfpJLckedX0mNdV1buTXJ/kgSRndfeXp8d5TZLL%0AMvtc3QXdfd3B/AMBAB4pFgm3dPetVTW/9OUF7vPy/Sy/bZ3bvzHJG/ezfmmSSxcYEwDgEW2RcLu1%0Aqp6VpKcv3j07yQ3LHQsAgL0tclTpq5OcldnXcNye2RGhZy1zKAAA9rXIUaWfy+w73AAAWKEDhltV%0AXZjk7O7+q+n6UUne1N0/vOzhADaT7TsvOfCNBnHLuaetegTgIVjkrdJv2hNtSdLdf5nkqcsbCQCA%0A/Vkk3B41d2qqVNXRWfBoVAAADp1FAuxNSf6/qvqtJJXkxdnP13YAALBcixyc8I6qujrJd0xLL+ru%0A65c7FgAAe1v0Lc9PJfnLPbevqid1958tbSoAAPaxyFGlP5rZ6aruzOyMCZXZKau+abmjAQAwb5E9%0Abmcn+fru/otlDwMAwNoWOar01iSfX/YgAACsb5E9bjcn+VBVXZLk/j2L3f3mpU0FAMA+Fgm3P5t+%0AHj39AACwAot8Hci/T5Kq+pru/uLyRwIAYH8O+Bm3qnpmVV2f2VeCpKq+uap+ZemTAQDwIIscnPBL%0ASZ6X5C+SpLs/luQ5yxwKAIB9LRJu6e5b91r68hJmAQBgHYscnHBrVT0rSVfVEZl9r9sNyx0LAIC9%0ALbLH7dVJzkpyXJLbk5yc5EeWORQAAPtaZI/b13f3988vVNWzk/zhckYCAGB/Ftnj9ssLrgEAsERr%0A7nGrqmcmeVaSbVX143N/+ntJDlv2YAAAPNh6b5U+Osnjpts8fm79C0levMyhAADY15rh1t1XJrmy%0Aqt7e3Z/ZwJkAANiPRQ5OeExVnZ9k+/ztu/s7lzUUAAD7WiTcfivJryb5jfjiXQCAlVkk3B7o7vOW%0APgkAAOta5OtAfq+qfqSqjq2qo/f8LH0yAAAeZJE9bmdMv/+fubVO8uRDPw4AAGs5YLh19wkbMQgA%0AAOs74FulVfU1VfWT05GlqaoTq+qfL380AADmLfIZt/+S5EuZnUUhmZ1o/j8sbSIAAPZrkXB7Snf/%0AXJL/lSTd/cUktdSpAADYxyLh9qWq+urMDkhIVT0lyf1LnQoAgH0sclTpOUl+P8nxVfXOJM9O8kPL%0AHAoAgH0tclTp5VV1TZJnZPYW6dnd/bmlTwYAwIMsclTps5P8TXdfkuTIJK+rqq9d+mQAADzIIp9x%0AOy/JF6vqm5P8eJI/TfKOpU4FAMA+Fgm3B7q7k5ye5K3d/dYkj1/uWAAA7G2RgxPurarXJvmXSZ5T%0AVY9KcsRyxwIAYG+L7HF7aWZf//HK7v5skicm+fmlTgUAwD4WOar0s0nePHf9z+IzbgAAG26RPW4A%0AAGwCwg0AYBBrhltVXTH9/tmNGwcAgLWs9xm3Y6vqWUleWFUXZa8Ty3f3NUudDACAB1kv3H46yU9l%0AdhTpm/f6Wyf5zmUNBQDAvtYMt+5+T5L3VNVPdfcbNnAmAAD2Y5GvA3lDVb0wyXOmpQ919/uXOxYA%0AAHtb5CTz/ynJ2Umun37Orqr/uOzBAAB4sEVOeXVakpO7+ytJUlUXJvnjJK9b5mAAADzYot/jduTc%0A5b+/jEEAAFjfInvc/lOSP66qD2b2lSDPSbJzqVMBALCPRQ5OeFdVfSjJt0xL/3Y6fykAABtokT1u%0A6e47kly85FkA2CDbd16y6hEOmVvOPW3VI8CGca5SAIBBCDcAgEGsG25VdVhVfWqjhgEAYG3rhlt3%0AfznJjVX1pA2aBwCANSxycMJRSa6rqo8m+es9i939wqVNBQDAPhYJt59a+hQAABzQIt/jdmVVfW2S%0AE7v7D6rqa5IctvzRAACYt8hJ5v9Vkvck+bVp6bgk71vmUAAA7GuRrwM5K8mzk3whSbr7piT/cJlD%0AAQCwr0XC7f7u/tKeK1V1eJJe3kgAAOzPIuF2ZVW9LslXV9V3J/mtJL+33LEAANjbIuG2M8ndST6R%0A5FVJLk3yk8scCgCAfS1yVOlXqurCJB/J7C3SG7vbW6UAABvsgOFWVacl+dUkf5qkkpxQVa/q7v+2%0A7OEAAPg7i3wB75uSfEd3706SqnpKkkuSCDcAgA20yGfc7t0TbZObk9y7pHkAAFjDmnvcqupF08Vd%0AVXVpkndn9hm370ty1QbMBgDAnPXeKv0Xc5fvTPJPp8t3J/nqpU0EAMB+rRlu3f2KjRwEAID1LXJU%0A6QlJfjTJ9vnbd/cLlzcWAAB7W+So0vcleVtmZ0v4ynLHAQBgLYuE299091uWPgkAAOtaJNz+c1Wd%0Ak+QDSe7fs9jd1yxtKgAA9rFIuP3jJD+Q5Dvzd2+V9nQdAIANski4fV+SJ3f3l5Y9DAAAa1vkzAmf%0ATHLksgcBAGB9i+xxOzLJp6rqqjz4M26+DgQAYAMtEm7nLH0KAAAO6IDh1t1XbsQgAACsb5EzJ9yb%0A2VGkSfLoJEck+evu/nvLHAwAgAdbZI/b4/dcrqpKcnqSZyxzKAAA9rXIUaV/q2fel+R5S5oHAIA1%0ALPJW6Yvmrj4qyY4kf7O0iQAA2K9Fjir9F3OXH0hyS2ZvlwIAsIEW+YzbKzZiEAAA1rdmuFXVT69z%0Av+7uNyxhHgAA1rDeHre/3s/aY5O8Msk/SCLcAAA20Jrh1t1v2nO5qh6f5Owkr0hyUZI3rXU/AACW%0AY93PuFXV0Ul+PMn3J7kwydO6+y83YjAAAB5svc+4/XySFyU5P8k/7u77NmwqNtz2nZesegQA4ADW%0A+wLen0jyj5L8ZJI/r6ovTD/3VtUXNmY8AAD2WO8zbgd1VgUAAJZraXFWVRdU1V1V9cm5taOr6vKq%0Aumn6fdS0XlX1lqraXVUfr6qnzd3njOn2N1XVGcuaFwBgs1vmXrW3Jzl1r7WdSa7o7hOTXDFdT5Ln%0AJzlx+jkzyXnJ3x4ccU6Sb03y9CTn7Ik9AICtZmnh1t0fTnLPXsunZ3Z0aqbf3zO3/o7pJPZ/lOTI%0Aqjo2s5PZX97d90xHs16efWMQAGBL2OjPsR3T3XdMlz+b5Jjp8nFJbp273W3T2lrr+6iqM6tqV1Xt%0Auvvuuw/t1AAAm8DKDkDo7k7Sh/Dxzu/uHd29Y9u2bYfqYQEANo2NDrc7p7dAM/2+a1q/Pcnxc7d7%0A4rS21joAwJaz0eF2cZI9R4aekeR359Z/cDq69BlJPj+9pXpZkudW1VHTQQnPndYAALacdU959XBU%0A1buSnJLkCVV1W2ZHh56b5N1V9cokn0nykunmlyZ5QZLdSb6Y2TlR0933VNUbklw13e5nunvvAx4A%0AALaEpYVbd798jT99135u20nOWuNxLkhywSEcDQBgSM6OAAAwCOEGADAI4QYAMAjhBgAwCOEGADAI%0A4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEG%0AADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAw%0ACOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjh%0ABgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYA%0AMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI%0A4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEG%0AADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAw%0ACOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADCIw1c9wMi2%0A77xk1SMAAFuIPW4AAINYSbhV1S1V9Ymquraqdk1rR1fV5VV10/T7qGm9quotVbW7qj5eVU9bxcwA%0AAKu2yj1u39HdJ3f3jun6ziRXdPeJSa6YrifJ85OcOP2cmeS8DZ8UAGAT2ExvlZ6e5MLp8oVJvmdu%0A/R0980dJjqyqY1cxIADAKq0q3DrJB6rq6qo6c1o7prvvmC5/Nskx0+Xjktw6d9/bpjUAgC1lVUeV%0Aflt3315V/zDJ5VX1qfk/dndXVR/MA04BeGaSPOlJTzp0kwIAbBIr2ePW3bdPv+9K8jtJnp7kzj1v%0AgU6/75pufnuS4+fu/sRpbe/HPL+7d3T3jm3bti1zfACAldjwcKuqx1bV4/dcTvLcJJ9McnGSM6ab%0AnZHkd6fLFyf5weno0mck+fzcW6oAAFvGKt4qPSbJ71TVnuf/r939+1V1VZJ3V9Urk3wmyUum21+a%0A5AVJdif5YpJXbPzIAACrt+Hh1t03J/nm/az/RZLv2s96JzlrA0YDANjUNtPXgQAAsA7hBgAwCCeZ%0AB2Bo23desuoRDplbzj1t1SOwydnjBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEG%0AADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAw%0ACOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjh%0ABgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYA%0AMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI%0A4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEGADAI4QYAMAjhBgAwCOEG%0AADAI4QYAMAjhBgAwCOEGADAI4QYAMIjDVz0AADCzfeclqx7hkLjl3NNWPcIjlj1uAACDEG4AAIMQ%0AbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4A%0AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACDEG4AAIMQbgAAgxBuAACD%0AOHzVAyyqqk5N8p+THJbkN7r73BWPBADsx/adl6x6hEPmlnNPW/UIDzLEHreqOizJW5M8P8lJSV5e%0AVSetdioAgI01RLgleXqS3d19c3d/KclFSU5f8UwAABtqlHA7Lsmtc9dvm9YAALaMYT7jdiBVdWaS%0AM6er91XVjQvc7QlJPre8qR6RbLODZ5sdPNvs4NlmB882O3hbbpvVzz6suy+6vb520QccJdxuT3L8%0A3PUnTmt/q7vPT3L+wTxoVe3q7h0Pf7ytwzY7eLbZwbPNDp5tdvBss4Nnmx2cZWyvUd4qvSrJiVV1%0AQlU9OsnLkly84pkAADbUEHvcuvuBqnpNkssy+zqQC7r7uhWPBQCwoYYItyTp7kuTXHqIH/ag3lol%0AiW32UNhmB882O3i22cGzzQ6ebXZwDvn2qu4+1I8JAMASjPIZNwCALW/LhltVnVpVN1bV7qrauep5%0ARlBVt1TVJ6rq2qratep5NqOquqCq7qqqT86tHV1Vl1fVTdPvo1Y542azxjZ7fVXdPr3Wrq2qF6xy%0Axs2kqo6vqg9W1fVVdV1VnT2te52tYZ1t5nW2hqr6qqr6aFV9bNpm/35aP6GqPjL9t/M3pwMGybrb%0A7O1V9em519nJD+t5tuJbpdMptP4kyXdn9mW+VyV5eXdfv9LBNrmquiXJju7eUt/hczCq6jlJ7kvy%0Aju7+xmnt55Lc093nTv9PwlHd/W9XOedmssY2e32S+7r7F1Y522ZUVccmOba7r6mqxye5Osn3JPmh%0AeJ3t1zrb7CXxOtuvqqokj+3u+6rqiCT/I8nZSX48yXu7+6Kq+tUkH+vu81Y562axzjZ7dZL3d/d7%0ADsXzbNU9bk6hxVJ094eT3LPX8ulJLpwuX5jZfzCYrLHNWEN339Hd10yX701yQ2ZnkvE6W8M624w1%0A9Mx909Ujpp9O8p1J9gSI19mcdbbZIbVVw80ptB6aTvKBqrp6OlMFizmmu++YLn82yTGrHGYgr6mq%0Aj09vpXrbbz+qanuSpyb5SLzOFrLXNku8ztZUVYdV1bVJ7kpyeZI/TfJX3f3AdBP/7dzL3tusu/e8%0Azt44vc5+saoe83CeY6uGGw/Nt3X305I8P8lZ01tcHISefTZh630+4eCdl+QpSU5OckeSN612nM2n%0Aqh6X5LeT/Fh3f2H+b15n+7efbeZ1to7u/nJ3n5zZ2YqenuT/WPFIm97e26yqvjHJazPbdt+S5Ogk%0AD+sjDFs13A54Ci321d23T7/vSvI7mf0fMgd25/QZmz2ftblrxfNset195/Q/gF9J8uvxWnuQ6fMz%0Av53knd393mnZ62wd+9tmXmeL6e6/SvLBJM9McmRV7fkOWP/tXMPcNjt1equ+u/v+JP8lD/N1tlXD%0AzSm0DlJVPXb6UG+q6rFJnpvkk+vfi8nFSc6YLp+R5HdXOMsQ9gTI5Hvjtfa3pg9Avy3JDd395rk/%0AeZ2tYa1t5nW2tqraVlVHTpe/OrOD+W7ILEZePN3M62zOGtvsU3P/D1Vl9pnAh/U625JHlSbJdNj3%0AL+XvTqH1xhWPtKlV1ZMz28uWzM648V9ts31V1buSnJLkCUnuTHJOkvcleXeSJyX5TJKXdLcP40/W%0A2GanZPb2VSe5Jcmr5j6/taVV1bcl+X+TfCLJV6bl12X2mS2vs/1YZ5u9PF5n+1VV35TZwQeHZbaT%0A593d/TPTfwsuyuwtvz9O8i+nPUlb3jrb7L8n2Zakklyb5NVzBzEc/PNs1XADABjNVn2rFABgOMIN%0AAGAQwg0AYBDCDQBgEMINAGAQwg3YVKrq31XVddPpYa6tqm99iI9z8vS1PxuuqrZX1SH/TrCqOqWq%0AnjV3/e1V9eL17gM8shx+4JsAbIyqemaSf57kad19f1U9IcmjH+LDnZxkR5JLD9V8m8ApSe5L8j9X%0APAewIva4AZvJsUk+t+cLPbv7c93950lSVf+kqq6sqqur6rK5byP/UFX9bFV9tKr+pKq+fTojys8k%0Aeem01+6l09k/Lphu98dVdfp0/x+qqvdW1e9X1U1V9XN7hqmqU6vqmqr6WFVdMa3t93HWMp10+uer%0A6qppL+KrpvVTptnfU1Wfqqp3Tt+snqp6wbR2dVW9pareP50c/dVJ/q/p3/Tt01M8p6r+Z1XdbO8b%0APPLZ4wZsJh9I8tNV9SdJ/iDJb3b3ldN5Jn85yendfXdVvTTJG5P88HS/w7v76dNbo+d09z+rqp9O%0AsqO7X5MkVfUfk/z37v7h6bTN7RbFAAAChElEQVQ0H62qP5juf3KSpya5P8mNVfXLSf4ms/NXPqe7%0AP11VR0+3/Xf7e5zu/us1/k2vTPL57v6WqnpMkj+sqg9Mf3tqkm9I8udJ/jDJs6tqV5Jfm3vedyVJ%0Ad99SVb+a5L7u/oXp3/TKzGL32zI7ifXFSd5z8JsdGIVwAzaN7r6vqv5Jkm9P8h1JfrOqdibZleQb%0Ak1w+7ZQ6LMn8qYn2nGj96iTb13j45yZ5YVX939P1r8rs9FBJckV3fz5Jqur6JF+b5KgkH+7uT0+z%0A3XOAx7lhnef9prm9YX8/yYlJvpTko9192/S8106z35fk5j3Pm+RdSc5c47GT5H3TSdKvr6pj1rkd%0A8Agg3IBNpbu/nORDST5UVZ/I7ETWVye5rrufucbd9pwr8ctZ+3/XKsn/2d03PmhxdvDD/LkW13uM%0ANR/nALf/0e6+bK/nPeUgn3ct849RD+H+wEB8xg3YNKrq66vqxLmlkzM7YfqNSbZNBy+kqo6oqm84%0AwMPdm+Txc9cvS/Kjc58je+oB7v9HmX1+7ITp9nveKj3Yx7ksyb+e3u5NVX1dVT12ndvfmOTJ02fa%0AkuSl6/ybgC1GuAGbyeOSXFhV11fVx5OclOT13f2lJC9O8rNV9bEk1yZ51jqPkyQfTHLSnoMTkrwh%0AyRFJPl5V103X19Tdd2f2FuV7p+f8zelPB/U4SX4jyfVJrpm+IuTXss6ete7+/5P8SJLfr6qrM4u1%0Az09//r0k37vXwQnAFlLdveoZAJhTVY+bPu9XSd6a5Kbu/sVVzwWsnj1uAJvPv5oOVrgus4MZfm3F%0A8wCbhD1uAACDsMcNAGAQwg0AYBDCDQBgEMINAGAQwg0AYBDCDQBgEP8b7bG40eozckwAAAAASUVO%0ARK5CYII=%0A" alt=""></p><p>现在我们的数据是干净的，准备好了，让我们进入机器学习部分</p><h3 id="Embeddings"><a href="#Embeddings" class="headerlink" title="Embeddings"></a>Embeddings</h3><p>机器学习中图像可以使用原始像素作为输入，那么NLP可以使用什么？</p><p>为计算机表示文本的一种自然方式是对每个字符进行单独编码，这似乎不足以表示和理解语言。我们的目标是首先为我们的数据集中的每个句子（或推文）创建一个有用的嵌入，然后使用这些嵌入来准确地预测相关类别。</p><p>我们可以从最简单的方法开始，使用一袋文字模型，并在上面应用逻辑回归。一袋单词只是将一个索引与我们词汇表中的每个单词相关联，并且将每个句子嵌入一个0的列表，每个索引中的每个索引对应于该句子中出现的单词。</p><h4 id="Bag-of-Words-Counts"><a href="#Bag-of-Words-Counts" class="headerlink" title="Bag of Words Counts"></a>Bag of Words Counts</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">rom sklearn.model_selection <span class="keyword">import</span> train_test_split</div><div class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer, TfidfVectorizer</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cv</span><span class="params">(data)</span>:</span></div><div class="line">    count_vectorizer = CountVectorizer()</div><div class="line">    emb = count_vectorizer.fit_transform(data)</div><div class="line">    <span class="keyword">return</span> emb, count_vectorizer</div><div class="line">list_corpus = clean_questions[<span class="string">"text"</span>].tolist()</div><div class="line">list_labels = clean_questions[<span class="string">"class_label"</span>].tolist()</div><div class="line">x_train, x_test, y_train, y_test = train_test_split(list_corpus, list_labels, test_size=<span class="number">0.2</span>, random_state=<span class="number">40</span>)</div><div class="line">x_train_count, count_vectorizer = cv(x_train)</div><div class="line">x_test_count = count_vectorizer.transform(x_test)</div></pre></td></tr></table></figure><h4 id="可视化embeddings"><a href="#可视化embeddings" class="headerlink" title="可视化embeddings"></a>可视化embeddings</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA, TruncatedSVD</div><div class="line"><span class="keyword">import</span> matplotlib</div><div class="line"><span class="keyword">import</span> matplotlib.patches <span class="keyword">as</span> patches</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_LSA</span><span class="params">(test_data, test_labels, savepath=<span class="string">"PCA_demo.csv"</span>, plot=True)</span>:</span></div><div class="line">    lsa = TruncatedSVD(n_components=<span class="number">2</span>)</div><div class="line">    lsa.fit(test_data)</div><div class="line">    lsa_scores = lsa.transform(test_data)</div><div class="line">    color_mapper = &#123;label: idx <span class="keyword">for</span> idx, label <span class="keyword">in</span> enumerate(set(test_labels))&#125;</div><div class="line">    color_column = [color_mapper[label] <span class="keyword">for</span> label <span class="keyword">in</span> test_labels]</div><div class="line">    colors = [<span class="string">'orange'</span>, <span class="string">'blue'</span>, <span class="string">'blue'</span>]</div><div class="line">    <span class="keyword">if</span> plot:</div><div class="line">        plt.scatter(lsa_scores[:, <span class="number">0</span>], lsa_scores[:, <span class="number">1</span>], s=<span class="number">8</span>, alpha=<span class="number">.8</span>, c=test_labels,</div><div class="line">                    cmap=matplotlib.colors.ListedColormap(colors))</div><div class="line">        red_patch = patches.Patch(color=<span class="string">'orange'</span>, label=<span class="string">'Irrelevant'</span>)</div><div class="line">        blue_patch = patches.Patch(color=<span class="string">'blue'</span>, label=<span class="string">'Disaster'</span>)</div><div class="line">        plt.legend(handles=[red_patch, blue_patch], prop=&#123;<span class="string">'size'</span>: <span class="number">30</span>&#125;)</div><div class="line"></div><div class="line">fig = plt.figure(figsize=(<span class="number">20</span>, <span class="number">20</span>))          </div><div class="line">plot_LSA(X_train_counts, y_train)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="../img/raw_distribution.png" alt="raw_distribution"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然存在丰富的精细和抽象的NLP技术，但集群和分类应始终作为处理这类数据时使用的第一种技术。 除了在生产中最容易扩展之外，它们的易用性可以迅速帮助企业解决一系列应用问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何自动区分不同类别的句子？&lt;/li&gt;
&lt;li&gt;如何找到一个数据集中最相似的
      
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源，NLP" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90%EF%BC%8CNLP/"/>
    
  </entry>
  
  <entry>
    <title>动态规划与贪婪算法</title>
    <link href="http://yoursite.com/2018/01/28/CuttingRope/"/>
    <id>http://yoursite.com/2018/01/28/CuttingRope/</id>
    <published>2018-01-28T03:18:13.000Z</published>
    <updated>2018-01-28T09:13:17.465Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p><p>能采用动态规划求解的问题的特点：</p><ul><li>最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</li><li>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</li><li>有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</li><li>从上往下分析问题，从下往上求解问题。</li></ul><h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><p>贪心算法是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，只做出在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p><p>解题的一般步骤是：</p><ul><li>建立数学模型来描述问题；</li><li>把求解的问题分成若干个子问题；</li><li>对每一子问题求解，得到子问题的局部最优解；</li><li>把子问题的解局部最优解合成原来解问题的一个解。</li></ul><h3 id="面试题：剪绳子"><a href="#面试题：剪绳子" class="headerlink" title="面试题：剪绳子"></a>面试题：剪绳子</h3><p><strong>题目</strong>：给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p><p><strong>动态规划思路</strong>：首先定义函数f(n)把长度为n的绳子剪成若干段后各段长度乘积的最大值。在剪第一刀的时候，我们有n-1种可能的选择，也就是剪出来的第一段绳子的科能长度分别为1,2,….,n-1。因此我们可以得到f(n)=max(f(i)*f(n-i))，其中0&lt;i&lt;n。</p><p>这是一个从上至下的递归公式。由于递归会有很多重复的子问题，从而有大量不必要的计算。一个更好的办法是按照从下而上的顺序计算，也就是说我们先得到f(2),f(3)，再得到f(4),f(5)，直到得到f(n)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">//==============动态规划============</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution1</span><span class="params">(<span class="keyword">int</span> length)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(length &lt; <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(length == <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(length == <span class="number">3</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span>* products = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> Max = <span class="number">0</span>;</div><div class="line"></div><div class="line">    products[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">    products[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">    products[<span class="number">2</span>] = <span class="number">2</span>;</div><div class="line">    products[<span class="number">3</span>] = <span class="number">3</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">4</span>; n&lt;=length; ++n)</div><div class="line">    &#123;</div><div class="line">        Max = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n/<span class="number">2</span>; ++i)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> product = products[i] * products[n-i];</div><div class="line">            <span class="keyword">if</span>(Max&lt;product)</div><div class="line">                Max = product;</div><div class="line">            products[n] = Max;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Max = products[length];</div><div class="line">    <span class="keyword">delete</span>[] products;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> Max;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>贪婪算法思路</strong>：如果我们按照以下策略来剪绳子，则得到的各段长度的绳子的长度的乘积将最大：当n&gt;=5时，我们尽量多地剪去长度为３的绳子；当剩下的绳子长度为４时，把绳子剪成两段长度为2的绳子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//==============贪婪算法============</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution2</span><span class="params">(<span class="keyword">int</span> length)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(length &lt; <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(length == <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(length == <span class="number">3</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 尽可能多地减去长度为3的绳子段</span></div><div class="line">    <span class="keyword">int</span> timesOf3 = length / <span class="number">3</span>;</div><div class="line"></div><div class="line">  　 <span class="comment">// 当绳子最后剩下的长度为4的时候，不能再剪去长度为3的绳子段。</span></div><div class="line">    <span class="comment">// 此时更好的方法是把绳子剪成长度为2的两段，因为2*2 &gt; 3*1。</span></div><div class="line">    <span class="keyword">if</span>(length - timesOf3*<span class="number">3</span> == <span class="number">1</span>)</div><div class="line">        timesOf3-=<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> timesOf2 = (length - timesOf3 * <span class="number">3</span>)/<span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">3</span>, timesOf3) *(<span class="keyword">long</span> <span class="keyword">int</span>) <span class="built_in">pow</span>(<span class="number">2</span>, timesOf2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> length = <span class="number">58</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;maxProductAfterCutting_solution1(length)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;maxProductAfterCutting_solution2(length)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>发现一个有趣的现象，当n&gt;58时，贪婪算法失效了，大家觉得这是什么原因呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h3&gt;&lt;p&gt;动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子
      
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程，动态规划与贪婪算法" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回溯法</title>
    <link href="http://yoursite.com/2018/01/27/StringPath/"/>
    <id>http://yoursite.com/2018/01/27/StringPath/</id>
    <published>2018-01-27T08:50:20.000Z</published>
    <updated>2018-01-27T12:51:40.380Z</updated>
    
    <content type="html"><![CDATA[<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>回溯法可以看成蛮力法的升级版，主要是在搜索过程中寻找问题的解，当发现已经不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当搜索到某一步时，发现原先选择并不优或达不到目标，就退回一步进行选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为回溯点。</p><p>在包含问题的所有解的解空间树中，按照<strong>深度优先搜索的策略</strong>，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索法）。</p><p>若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p><p>回溯法过程：</p><ul><li>针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</li><li>确定结点的扩展搜索规则。</li><li>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</li></ul><a id="more"></a><h3 id="面试题：矩阵中的路径"><a href="#面试题：矩阵中的路径" class="headerlink" title="面试题：矩阵中的路径"></a>面试题：矩阵中的路径</h3><p><strong>题目</strong>：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><div class="table-container"><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">T</th><th style="text-align:center">G</th></tr></thead><tbody><tr><td style="text-align:center">C</td><td style="text-align:center">F</td><td style="text-align:center">C</td><td style="text-align:center">S</td></tr><tr><td style="text-align:center">J</td><td style="text-align:center">D</td><td style="text-align:center">E</td><td style="text-align:center">H</td></tr></tbody></table></div><p><strong>思路</strong>：由于矩阵的第一行第二个字母’b’的路径’bfce’的第一个字符相等，我们就从这里开始分析。根据题目要求，我们此时有3个选项，分别是向左边到达字母’a’,向右边到达字母’t’，向下到达字母’f’。我们先尝试选项’a’,由于此时不能得到路径’bfce’，因此不得不回到结点’b’尝试下一个选项’t’，同样，经过结点也不能得到路径’bfce’，因此再次回到结点’b’尝试下一个选项’f’。</p><p>在结点’f’我们也有三个选项，向左右都能到达’c’，向下到达子字母‘d’。我们先选择向左到达字母’c’,由于只有一个选择，即向下到达字母’j’。但是无法到达路径’bfce’，我们只好回溯到上一个结点’f’尝试下一个选项，即向右到达结点’c’。</p><p>根据这个规则，一直寻找，知道满足约束条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col,</span></span></div><div class="line"><span class="function"><span class="params">                 <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span>&amp; pathLength, <span class="keyword">bool</span> *visited)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(matrix == <span class="literal">nullptr</span> || rows&lt;<span class="number">1</span> || cols&lt;<span class="number">1</span> || str == <span class="literal">nullptr</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows * cols];</div><div class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, rows*cols);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> pathLength = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;rows; ++row)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;cols; ++col)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(hasPathCore(matrix, rows, cols, row, col, str, pathLength, visited))</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">delete</span>[] visited;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col,</span></span></div><div class="line"><span class="function"><span class="params">                 <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span>&amp; pathLength, <span class="keyword">bool</span> *visited)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(str[pathLength] == <span class="string">'\0'</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> hasPath = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span>(row&gt;=<span class="number">0</span> &amp;&amp; row&lt;rows &amp;&amp; col&gt;=<span class="number">0</span> &amp;&amp; col&lt;cols &amp;&amp; matrix[row*cols+col] == str[pathLength] &amp;&amp; !visited[row*cols+col])</div><div class="line">    &#123;</div><div class="line">        ++pathLength;</div><div class="line"></div><div class="line">        visited[row*cols+col] = <span class="literal">true</span>;</div><div class="line">        hasPath = hasPathCore(matrix, rows, cols, row, col<span class="number">-1</span>,</div><div class="line">                str, pathLength, visited)</div><div class="line">                ||hasPathCore(matrix, rows, cols, row, col+<span class="number">1</span>,</div><div class="line">                str, pathLength, visited)</div><div class="line">                ||hasPathCore(matrix, rows, cols, row<span class="number">-1</span>, col,</div><div class="line">                str, pathLength, visited)</div><div class="line">                ||hasPathCore(matrix, rows, cols, row+<span class="number">1</span>, col,</div><div class="line">                str, pathLength, visited);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(!hasPath)</div><div class="line">        &#123;</div><div class="line">            --pathLength;</div><div class="line">            visited[row*cols+col] = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hasPath;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//===============测试代码=============</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* testName, <span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">bool</span> expected)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(testName != <span class="literal">nullptr</span>)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%s begins: "</span>, testName);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(hasPath(matrix, rows, cols, str) == expected)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Passed.\n"</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Failed.\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ABTG</span></div><div class="line"><span class="comment">//CFCS</span></div><div class="line"><span class="comment">//JDEH</span></div><div class="line"></div><div class="line"><span class="comment">//BFCE</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* matrix = <span class="string">"ABTGCFCSJDEH"</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"BFCE"</span>;</div><div class="line"></div><div class="line">    Test(<span class="string">"Test1"</span>, matrix, <span class="number">3</span>, <span class="number">4</span>, str, <span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ABCE</span></div><div class="line"><span class="comment">//SFCS</span></div><div class="line"><span class="comment">//ADEE</span></div><div class="line"></div><div class="line"><span class="comment">//SEE</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* matrix = <span class="string">"ABCESFCSADEE"</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"SEE"</span>;</div><div class="line"></div><div class="line">    Test(<span class="string">"Test2"</span>, matrix, <span class="number">3</span>, <span class="number">4</span>, str, <span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//AAAA</span></div><div class="line"><span class="comment">//AAAA</span></div><div class="line"><span class="comment">//AAAA</span></div><div class="line"></div><div class="line"><span class="comment">//AAAAAAAAAAAA</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* matrix = <span class="string">"AAAAAAAAAAAA"</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"AAAAAAAAAAAA"</span>;</div><div class="line"></div><div class="line">    Test(<span class="string">"Test3"</span>, (<span class="keyword">const</span> <span class="keyword">char</span>*) matrix, <span class="number">3</span>, <span class="number">4</span>, str, <span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ABCE</span></div><div class="line"><span class="comment">//SFCS</span></div><div class="line"><span class="comment">//ADEE</span></div><div class="line"></div><div class="line"><span class="comment">//SEE</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test4</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* matrix = <span class="string">"ABCESFCSADEE"</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"ABFB"</span>;</div><div class="line"></div><div class="line">    Test(<span class="string">"Test4"</span>, matrix, <span class="number">3</span>, <span class="number">4</span>, str, <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Test1();</div><div class="line">    Test2();</div><div class="line">    Test3();</div><div class="line">    Test4();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="面试题：机器人的运动范围"><a href="#面试题：机器人的运动范围" class="headerlink" title="面试题：机器人的运动范围"></a>面试题：机器人的运动范围</h3><p><strong>题目</strong>：地上有m行n列的方格。一个机器人一个机器人从坐标(0, 0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35, 37)，因为3+5+3+7=18。但它不能进入方格(35, 38)，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>思路</strong>：和上一道题类似，这个方格也可以看做是一个m*n的矩阵。同样在这个矩阵中，除了边界上的格子外，其他格子都有四个相邻的格子。机器人的坐标从(0,0)开始移动。当它准备进入坐标为(i,j)的格子时，通过检查坐标的位数来判断机器人能否进入。如果机器人能够进入坐标为(i, j)的格子，则再判断他能否进入4个相邻的格子(i, j-1),(i-1, j). (i, j+1)和(i+1, j)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span></span>;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(threshold&lt;<span class="number">0</span> || rows&lt;<span class="number">1</span> || cols&lt;<span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows*cols; ++i)</div><div class="line">        visited[i] = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> count = movingCountCore(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</div><div class="line"></div><div class="line">    <span class="keyword">delete</span>[] visited;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(check(threshold, rows, cols, row, col, visited))</div><div class="line">    &#123;</div><div class="line">        visited[row*cols+col] = <span class="literal">true</span>;</div><div class="line"></div><div class="line">        count =<span class="number">1</span>+movingCountCore(threshold, rows, cols,</div><div class="line">              row, col<span class="number">-1</span>, visited)</div><div class="line">              + movingCountCore(threshold, rows, cols,</div><div class="line">              row<span class="number">-1</span>, col, visited)</div><div class="line">              + movingCountCore(threshold, rows, cols,</div><div class="line">              row, col+<span class="number">1</span>, visited)</div><div class="line">              + movingCountCore(threshold, rows, cols,</div><div class="line">              row+<span class="number">1</span>, col, visited);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col,</span></span></div><div class="line"><span class="function"><span class="params">    <span class="keyword">bool</span>* visited)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols</div><div class="line">        &amp;&amp; getSum(row) + getSum(col) &lt;= threshold</div><div class="line">        &amp;&amp; !visited[row* cols + col])</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> number)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(number&gt;<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        sum += number % <span class="number">10</span>;</div><div class="line">        number = number/<span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ====================测试代码====================</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">char</span>* testName, <span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> excepted)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(testName != <span class="literal">nullptr</span>)</div><div class="line">         <span class="built_in">printf</span>(<span class="string">"%s begins: "</span>, testName);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(movingCount(threshold, rows, cols) == excepted)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Test Passed.\n"</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Test Failed.\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方格多行多列</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Test(<span class="string">"Test1"</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">21</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方格多行多列</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Test(<span class="string">"Test2"</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">359</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方格只有一行，机器人只能到达部分方格</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Test(<span class="string">"Test3"</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">29</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方格只有一行，机器人能到达所有方格</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test4</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Test(<span class="string">"Test4"</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方格只有一列，机器人只能到达部分方格</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test5</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Test(<span class="string">"Test5"</span>, <span class="number">15</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">79</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方格只有一列，机器人能到达所有方格</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test6</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Test(<span class="string">"Test6"</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">10</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方格只有一行一列</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test7</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Test(<span class="string">"Test7"</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方格只有一行一列</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test8</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Test(<span class="string">"Test8"</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 机器人不能进入任意一个方格</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Test(<span class="string">"Test9"</span>, <span class="number">-10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    int threshold, rows, cols;</span></div><div class="line"><span class="comment">    cin&gt;&gt;threshold;</span></div><div class="line"><span class="comment">    cin&gt;&gt;rows;</span></div><div class="line"><span class="comment">    cin&gt;&gt;cols;</span></div><div class="line"><span class="comment">    cout&lt;&lt;movingCount(threshold, rows, cols);</span></div><div class="line"><span class="comment">    int n;</span></div><div class="line"><span class="comment">    cin&gt;&gt;n;</span></div><div class="line"><span class="comment">    cout&lt;&lt;getSum(n)&lt;&lt;ends;</span></div><div class="line"><span class="comment">    **/</span></div><div class="line">    Test1();</div><div class="line">    Test2();</div><div class="line">    Test3();</div><div class="line">    Test4();</div><div class="line">    Test5();</div><div class="line">    Test6();</div><div class="line">    Test7();</div><div class="line">    Test8();</div><div class="line">    test9();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;回溯法&quot;&gt;&lt;a href=&quot;#回溯法&quot; class=&quot;headerlink&quot; title=&quot;回溯法&quot;&gt;&lt;/a&gt;回溯法&lt;/h3&gt;&lt;p&gt;回溯法可以看成蛮力法的升级版，主要是在搜索过程中寻找问题的解，当发现已经不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当搜索到某一步时，发现原先选择并不优或达不到目标，就退回一步进行选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为回溯点。&lt;/p&gt;
&lt;p&gt;在包含问题的所有解的解空间树中，按照&lt;strong&gt;深度优先搜索的策略&lt;/strong&gt;，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索法）。&lt;/p&gt;
&lt;p&gt;若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。&lt;/p&gt;
&lt;p&gt;回溯法过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。&lt;/li&gt;
&lt;li&gt;确定结点的扩展搜索规则。&lt;/li&gt;
&lt;li&gt;以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程，回溯法" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%EF%BC%8C%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组的最小数字</title>
    <link href="http://yoursite.com/2018/01/27/MinInOrder/"/>
    <id>http://yoursite.com/2018/01/27/MinInOrder/</id>
    <published>2018-01-27T03:44:35.000Z</published>
    <updated>2018-01-27T04:02:50.128Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面试题：旋转数组的最小数字"><a href="#面试题：旋转数组的最小数字" class="headerlink" title="面试题：旋转数组的最小数字"></a>面试题：旋转数组的最小数字</h3><p><strong>题目</strong>：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1。</p><p><strong>思路</strong>：我们注意到旋转之后的数组实际上可以划分为两个排序的子数组，而且前面的子数组的元素都大于或者等于后面子数组的元素。我们还注意到最小的元素刚好是这两个子数组的分界线。在排序的数组中没我们可以用二分法实现O(logn)的查找。我们用两个指针分别指向数组的第一个元素和最后一个元素，按照旋转规则，第一个元素大于或者等于最后一个元素。</p><p>接着我们可以找到数组中间的元素。如果该中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时数组中最小的元素位于该之间元素的后面。我们可以把第一个指针指向该之间元素，这样就可以缩小寻找范围，移动之后的第一个指针仍然位于前面的递增数组。</p><p>同样，如果该中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时数组中最小的元素位于该之间元素的前面。我们可以把第二个指针指向该之间元素，这样就可以缩小寻找范围，移动之后的第二个指针仍然位于前面的递增数组。</p><p>对于特殊情况，如下面的情况，就需要利用顺序查找。对于数组{0,1,1,1,1}的旋转。</p><a id="more"></a><div class="table-container"><table><thead><tr><th style="text-align:center">１</th><th style="text-align:center">０</th><th style="text-align:center">１</th><th style="text-align:center">１</th><th style="text-align:center">１</th></tr></thead><tbody><tr><td style="text-align:center">p1</td><td style="text-align:center"></td><td style="text-align:center">Mid</td><td style="text-align:center"></td><td style="text-align:center">p2</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">１</th><th style="text-align:center">1</th><th style="text-align:center">１</th><th style="text-align:center">0</th><th style="text-align:center">１</th></tr></thead><tbody><tr><td style="text-align:center">p1</td><td style="text-align:center"></td><td style="text-align:center">Mid</td><td style="text-align:center"></td><td style="text-align:center">p2</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</div><div class="line"></div><div class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> index2 = length<span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> Mid = index1;</div><div class="line">    <span class="keyword">while</span>(numbers[index1] &gt;= numbers[index2])</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 如果index1和index2指向相邻的两个数，</span></div><div class="line">        <span class="comment">// 则index1指向第一个递增子数组的最后一个数字，</span></div><div class="line">        <span class="comment">// index2指向第二个子数组的第一个数字，也就是数组中的最小数字</span></div><div class="line">        <span class="keyword">if</span>(index2 - index1 == <span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//index2指向的是最小的数字</span></div><div class="line">            Mid = index2;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        Mid = (index1 + index2)/<span class="number">2</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 如果下标为index1、index2和indexMid指向的三个数字相等，</span></div><div class="line">        <span class="comment">// 则只能顺序查找</span></div><div class="line">        <span class="keyword">if</span>(numbers[index1] == numbers[index2] &amp;&amp; numbers[index1] == numbers[Mid])</div><div class="line">            <span class="keyword">return</span> MinInOrder(numbers, index1, index2);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(numbers[Mid] &gt;= numbers[index1])</div><div class="line">            index1 = Mid;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[Mid] &lt;= numbers[index2])</div><div class="line">            index2 = Mid;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> numbers[Mid];</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> reslut = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index1+<span class="number">1</span>; i&lt;=index2; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(numbers[reslut]&gt;numbers[i])</div><div class="line">            reslut = numbers[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> reslut;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ====================测试代码====================</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> length, <span class="keyword">int</span> excepted)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        result = Min(numbers, length);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, numbers[i]);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(result == excepted)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"\tPassed.\n"</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"\tFailed.\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(...)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span>)</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Test Passed.\n"</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Test Failed.\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// 典型输入，单调升序的数组的一个旋转</span></div><div class="line">    <span class="keyword">int</span> array1[] = &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</div><div class="line">    Test(array1, <span class="keyword">sizeof</span>(array1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 有重复数字，并且重复的数字刚好的最小的数字</span></div><div class="line">    <span class="keyword">int</span> array2[] = &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</div><div class="line">    Test(array2, <span class="keyword">sizeof</span>(array2) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 有重复数字，但重复的数字不是第一个数字和最后一个数字</span></div><div class="line">    <span class="keyword">int</span> array3[] = &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span> &#125;;</div><div class="line">    Test(array3, <span class="keyword">sizeof</span>(array3) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 有重复的数字，并且重复的数字刚好是第一个数字和最后一个数字</span></div><div class="line">    <span class="keyword">int</span> array4[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</div><div class="line">    Test(array4, <span class="keyword">sizeof</span>(array4) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 单调升序数组，旋转0个元素，也就是单调升序数组本身</span></div><div class="line">    <span class="keyword">int</span> array5[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</div><div class="line">    Test(array5, <span class="keyword">sizeof</span>(array5) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 数组中只有一个数字</span></div><div class="line">    <span class="keyword">int</span> array6[] = &#123; <span class="number">2</span> &#125;;</div><div class="line">    Test(array6, <span class="keyword">sizeof</span>(array6) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 输入nullptr</span></div><div class="line">    Test(<span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;面试题：旋转数组的最小数字&quot;&gt;&lt;a href=&quot;#面试题：旋转数组的最小数字&quot; class=&quot;headerlink&quot; title=&quot;面试题：旋转数组的最小数字&quot;&gt;&lt;/a&gt;面试题：旋转数组的最小数字&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：我们注意到旋转之后的数组实际上可以划分为两个排序的子数组，而且前面的子数组的元素都大于或者等于后面子数组的元素。我们还注意到最小的元素刚好是这两个子数组的分界线。在排序的数组中没我们可以用二分法实现O(logn)的查找。我们用两个指针分别指向数组的第一个元素和最后一个元素，按照旋转规则，第一个元素大于或者等于最后一个元素。&lt;/p&gt;
&lt;p&gt;接着我们可以找到数组中间的元素。如果该中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时数组中最小的元素位于该之间元素的后面。我们可以把第一个指针指向该之间元素，这样就可以缩小寻找范围，移动之后的第一个指针仍然位于前面的递增数组。&lt;/p&gt;
&lt;p&gt;同样，如果该中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时数组中最小的元素位于该之间元素的前面。我们可以把第二个指针指向该之间元素，这样就可以缩小寻找范围，移动之后的第二个指针仍然位于前面的递增数组。&lt;/p&gt;
&lt;p&gt;对于特殊情况，如下面的情况，就需要利用顺序查找。对于数组{0,1,1,1,1}的旋转。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程，数组" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列</title>
    <link href="http://yoursite.com/2018/01/26/Fibonacci/"/>
    <id>http://yoursite.com/2018/01/26/Fibonacci/</id>
    <published>2018-01-26T12:25:00.000Z</published>
    <updated>2018-01-26T12:39:17.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面试题：斐波那契数列"><a href="#面试题：斐波那契数列" class="headerlink" title="面试题：斐波那契数列"></a>面试题：斐波那契数列</h3><p><strong>题目</strong>：写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ====================方法1：递归====================</span></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fibonacci_soultion1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(n&lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> Fibonacci_soultion1(n<span class="number">-1</span>)+Fibonacci_soultion1(n<span class="number">-2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ====================方法2：循环====================</span></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fibonacci_soultion2</span><span class="params">(<span class="keyword">unsigned</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> result[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</div><div class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> result[n];</div><div class="line"></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fibNOne = <span class="number">1</span>;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fibNTwo = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fibN = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</div><div class="line">    &#123;</div><div class="line">        fibN = fibNOne + fibNTwo;</div><div class="line"></div><div class="line">        fibNTwo = fibNOne;</div><div class="line">        fibNOne = fibN;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fibN;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;Fibonacci_soultion1(n)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="comment">// Fibonacci_soultion1(100)  3.495s</span></div><div class="line">    <span class="comment">// Fibonacci_soultion1(100)  3.380s</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通常基于递归实现的代码比基于循环实现的代码要简洁很多，但同时也有显著的缺点，递归由于是调用自身，而函数调用是有时间和空间消耗的：每一次函数调用都需要在内存堆栈中分配空间以保存参数、返回地址及临时变量，而且往堆栈里压入数据和弹出数据都需要时间。这就不难理解例子中递归效率不如循环。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;面试题：斐波那契数列&quot;&gt;&lt;a href=&quot;#面试题：斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;面试题：斐波那契数列&quot;&gt;&lt;/a&gt;面试题：斐波那契数列&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;：写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ====================方法1：递归====================&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Fibonacci_soultion1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n&amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Fibonacci_soultion1(n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)+Fibonacci_soultion1(n&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程，Fibonacci" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%EF%BC%8CFibonacci/"/>
    
  </entry>
  
  <entry>
    <title>替换空格</title>
    <link href="http://yoursite.com/2018/01/24/Replacespace/"/>
    <id>http://yoursite.com/2018/01/24/Replacespace/</id>
    <published>2018-01-24T12:23:45.000Z</published>
    <updated>2018-01-27T04:06:07.545Z</updated>
    
    <content type="html"><![CDATA[<h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p>题目：请实现一个函数，把字符串中的每个空格替换成”%20”。例如输入“We are happy.”，则输出“We%20are%20happy.”。</p><p><strong>思路</strong>: 首先准备两个指针：p1和p2。p1指向原始字符串的末尾，p2指向替换之后的字符串的末尾。接下来我们向前移动p1，逐个把它指向的字符串复制到p2指向的位置，知道遇到第一个空格为止。此时p1向前移动一格，在p2之前插入字符串”%20”，同时p2向前移动三格。</p><div class="table-container"><table><thead><tr><th style="text-align:center">I</th><th style="text-align:center"></th><th style="text-align:center">a</th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">p1(indexofOriginal)</td><td style="text-align:center"></td><td style="text-align:center">p2(indexofNew)</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">a</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">p1</td><td style="text-align:center"></td><td style="text-align:center">p2</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">%</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">a</td></tr><tr><td style="text-align:center">p1,p2</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReplaceBlank</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> length)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> OriginalLength = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> numberofBlank = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(str[i] != <span class="string">'\0'</span>)</div><div class="line">    &#123;</div><div class="line">        ++OriginalLength;</div><div class="line">        <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)</div><div class="line">            ++numberofBlank;</div><div class="line">        ++i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> newLength = OriginalLength + numberofBlank * <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(newLength &gt; length)</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> indexofOriginal = OriginalLength;     <span class="comment">//p1</span></div><div class="line">    <span class="keyword">int</span> indexofNew = newLength;               <span class="comment">//p2</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span>(indexofOriginal &gt;= <span class="number">0</span> &amp;&amp; indexofNew &gt; indexofOriginal)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(str[indexofOriginal] == <span class="string">' '</span>)</div><div class="line">        &#123;</div><div class="line">            str[indexofNew--] = <span class="string">'0'</span>;</div><div class="line">            str[indexofNew--] = <span class="string">'2'</span>;</div><div class="line">            str[indexofNew--] = <span class="string">'%'</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            str[indexofNew--] = str[indexofOriginal];</div><div class="line"></div><div class="line">        --indexofOriginal;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ====================测试代码====================</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">char</span>* testname, <span class="keyword">char</span> str[], <span class="keyword">int</span> length, <span class="keyword">char</span> expected[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(testname != <span class="literal">nullptr</span>)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%s begins: "</span>, testname);</div><div class="line"></div><div class="line">    ReplaceBlank(str, length);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(expected == <span class="literal">nullptr</span> &amp;&amp; str == <span class="literal">nullptr</span>)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Passed. \n"</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(expected == <span class="literal">nullptr</span> &amp;&amp; str != <span class="literal">nullptr</span>)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Failed. \n"</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(str, expected) == <span class="number">0</span>)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Passed. \n"</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Failed. \n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//空格在句子中间</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test1</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> length = <span class="number">50</span>;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> str[length] = <span class="string">"hello world"</span>;</div><div class="line">    Test(<span class="string">"test1"</span>, str, length, <span class="string">"hello%20world"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 空格在句子开头</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> length = <span class="number">50</span>;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> str[length] = <span class="string">" helloworld"</span>;</div><div class="line">    Test(<span class="string">"Test2"</span>, str, length, <span class="string">"%20helloworld"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 空格在句子末尾</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test3</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> length = <span class="number">50</span>;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> str[length] = <span class="string">"helloworld "</span>;</div><div class="line">    Test(<span class="string">"Test3"</span>, str, length, <span class="string">"helloworld%20"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 连续有两个空格</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test4</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> length = <span class="number">50</span>;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> str[length] = <span class="string">"hello  world"</span>;</div><div class="line">    Test(<span class="string">"Test4"</span>, str, length, <span class="string">"hello%20%20world"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 传入nullptr</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test5</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Test(<span class="string">"Test5"</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 传入内容为空的字符串</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test6</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> length = <span class="number">50</span>;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> str[length] = <span class="string">""</span>;</div><div class="line">    Test(<span class="string">"Test6"</span>, str, length, <span class="string">""</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//传入内容为一个空格的字符串</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test7</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> length = <span class="number">50</span>;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> str[length] = <span class="string">" "</span>;</div><div class="line">    Test(<span class="string">"Test7"</span>, str, length, <span class="string">"%20"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 传入的字符串没有空格</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test8</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> length = <span class="number">50</span>;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> str[length] = <span class="string">"helloworld"</span>;</div><div class="line">    Test(<span class="string">"Test8"</span>, str, length, <span class="string">"helloworld"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 传入的字符串全是空格</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test9</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> length = <span class="number">50</span>;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> str[length] = <span class="string">"   "</span>;</div><div class="line">    Test(<span class="string">"Test9"</span>, str, length, <span class="string">"%20%20%20"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Test1();</div><div class="line">    Test2();</div><div class="line">    Test3();</div><div class="line">    Test4();</div><div class="line">    Test5();</div><div class="line">    Test6();</div><div class="line">    Test7();</div><div class="line">    Test8();</div><div class="line">    Test9();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;替换空格&quot;&gt;&lt;a href=&quot;#替换空格&quot; class=&quot;headerlink&quot; title=&quot;替换空格&quot;&gt;&lt;/a&gt;替换空格&lt;/h3&gt;&lt;p&gt;题目：请实现一个函数，把字符串中的每个空格替换成”%20”。例如输入“We are happy.”，则输出“We%20are%20happy.”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;: 首先准备两个指针：p1和p2。p1指向原始字符串的末尾，p2指向替换之后的字符串的末尾。接下来我们向前移动p1，逐个把它指向的字符串复制到p2指向的位置，知道遇到第一个空格为止。此时p1向前移动一格，在p2之前插入字符串”%20”，同时p2向前移动三格。&lt;/p&gt;
&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;I&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;a&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;p1(indexofOriginal)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;p2(indexofNew)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;I&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;a&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;p1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;p2&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;I&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;%&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;2&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;a&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;p1,p2&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程，字符" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%EF%BC%8C%E5%AD%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>深度学习常用数据集介绍</title>
    <link href="http://yoursite.com/2018/01/24/dataset-introduction/"/>
    <id>http://yoursite.com/2018/01/24/dataset-introduction/</id>
    <published>2018-01-24T02:47:23.000Z</published>
    <updated>2018-01-25T12:15:06.442Z</updated>
    
    <content type="html"><![CDATA[<p>深度学习在计算机视觉领域取得了十分重大的突破，许多研究也是如雨后春笋般。而模型的训练离不开数据集的支持，因此有必要对常用的数据集进行了解。接下来主要对计算机视觉和自然语言处理这两个领域的常用数据集进行介绍。</p><h2 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h2><h3 id="MNIST"><a href="#MNIST" class="headerlink" title="MNIST"></a>MNIST</h3><p>MNIST数据集被称为深度学习领域的“Hello World!”，入门必备！它有<strong>60000</strong>个训练样本集和<strong>10000</strong>个测试样本集，每个样本图像的宽高为<strong>28*28</strong>。此数据集是以二进制存储的，不能直接以图像格式查看，不过很容易找到将其转换成图像格式的工具。</p><p>该数据集可在<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="external">http://yann.lecun.com/exdb/mnist/</a> 获取，主要包含以下四部分：</p><blockquote><p><code>train-images-idx3-ubyte.gz:  training set images (9912422 bytes)</code><br><code>train-labels-idx1-ubyte.gz:  training set labels (28881 bytes)</code><br><code>t10k-images-idx3-ubyte.gz:   test set images (1648877 bytes)</code><br><code>t10k-labels-idx1-ubyte.gz:   test set labels (4542 bytes)</code></p></blockquote><a id="more"></a><h3 id="CIFAR"><a href="#CIFAR" class="headerlink" title="CIFAR"></a>CIFAR</h3><h4 id="CIFAR-10"><a href="#CIFAR-10" class="headerlink" title="CIFAR-10"></a>CIFAR-10</h4><p>CIFAR-10包含<strong>10</strong>个类别，<strong>50000</strong>个训练图像，彩色图像大小：<strong>32x32</strong>，<strong>10000</strong>个测试图像。</p><p>该数据集可在<a href="http://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="external">http://www.cs.toronto.edu/~kriz/cifar.html</a> 获取，主要包含以下类别：</p><p><img src="https://upload-images.jianshu.io/upload_images/669323-4c48aff1693a078d?imageMogr2/auto-orient/strip%7CimageView2/2/w/580" alt=""></p><h4 id="CIFAR-100"><a href="#CIFAR-100" class="headerlink" title="CIFAR-100"></a>CIFAR-100</h4><p>CIFAR-100与CIFAR-10类似，包含<strong>100</strong>个类，每类有<strong>600</strong>张图片，其中<strong>500</strong>张用于训练，<strong>100</strong>张用于测试；这<strong>100</strong>个类分组成<strong>20</strong>个超类。图像类别均有明确标注。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Superclass</th><th>Classes</th></tr></thead><tbody><tr><td style="text-align:left">aquatic mammals</td><td>beaver, dolphin, otter, seal, whale</td></tr><tr><td style="text-align:left">fish</td><td>aquarium fish, flatfish, ray, shark, trout</td></tr><tr><td style="text-align:left">flowers</td><td>orchids, poppies, roses, sunflowers, tulips</td></tr><tr><td style="text-align:left">food containers</td><td>bottles, bowls, cans, cups, plates</td></tr><tr><td style="text-align:left">fruit and vegetables</td><td>apples, mushrooms, oranges, pears, sweet peppers</td></tr><tr><td style="text-align:left">household electrical devices</td><td>clock, computer keyboard, lamp, telephone, television</td></tr><tr><td style="text-align:left">household furniture</td><td>bed, chair, couch, table, wardrobe</td></tr><tr><td style="text-align:left">insects</td><td>bee, beetle, butterfly, caterpillar, cockroach</td></tr><tr><td style="text-align:left">large carnivores</td><td>bear, leopard, lion, tiger, wolf</td></tr><tr><td style="text-align:left">large man-made outdoor things</td><td>bridge, castle, house, road, skyscraper</td></tr><tr><td style="text-align:left">large natural outdoor scenes</td><td>cloud, forest, mountain, plain, sea</td></tr><tr><td style="text-align:left">large omnivores and herbivores</td><td>camel, cattle, chimpanzee, elephant, kangaroo</td></tr><tr><td style="text-align:left">medium-sized mammals</td><td>fox, porcupine, possum, raccoon, skunk</td></tr><tr><td style="text-align:left">non-insect invertebrates</td><td>crab, lobster, snail, spider, worm</td></tr><tr><td style="text-align:left">people</td><td>baby, boy, girl, man, woman</td></tr><tr><td style="text-align:left">reptiles</td><td>crocodile, dinosaur, lizard, snake, turtle</td></tr><tr><td style="text-align:left">small mammals</td><td>hamster, mouse, rabbit, shrew, squirrel</td></tr><tr><td style="text-align:left">trees</td><td>maple, oak, palm, pine, willow</td></tr><tr><td style="text-align:left">vehicles 1</td><td>bicycle, bus, motorcycle, pickup truck, train</td></tr><tr><td style="text-align:left">vehicles 2</td><td>lawn-mower, rocket, streetcar, tank, tractor</td></tr></tbody></table></div><h3 id="Imagenet"><a href="#Imagenet" class="headerlink" title="Imagenet"></a>Imagenet</h3><p>MNIST将初学者领进了深度学习领域，而Imagenet数据集对深度学习的浪潮起了巨大的推动作用。深度学习大牛Hinton在2012年发表的论文《ImageNet Classification with Deep Convolutional Neural Networks》在计算机视觉领域带来了一场“革命”，此论文的工作正是基于Imagenet数据集。</p><p><img src="https://upload-images.jianshu.io/upload_images/669323-8155cd4456504709?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><p>Imagenet数据集有<strong>1400多万</strong>幅图片，涵盖<strong>2万</strong>多个类别；其中有超过百万的图片有明确的类别标注和图像中物体位置的标注，具体信息如下：</p><ul><li>Total number of non-empty synsets: 21841</li><li>Total number of images: 14,197,122</li><li>Number of images with bounding box annotations: 1,034,908</li><li>Number of synsets with SIFT features: 1000</li><li>Number of images with SIFT features: 1.2 million</li></ul><p>Imagenet数据集是目前深度学习图像领域应用得非常多的一个领域，关于图像分类、定位、检测等研究工作大多基于此数据集展开。Imagenet数据集文档详细，有专门的团队维护，使用非常方便，在计算机视觉领域研究论文中应用非常广，几乎成为了目前深度学习图像领域算法性能检验的“标准”数据集。</p><h2 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h2><h3 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h3><h4 id="Penn-Treebank-Dataset（PTB）"><a href="#Penn-Treebank-Dataset（PTB）" class="headerlink" title="Penn Treebank Dataset（PTB）"></a>Penn Treebank Dataset（PTB）</h4><p>PTB（Penn Treebank Dataset）文本数据集是语言模型学习中目前最广泛使用的数据集。语言建模(LM)是自然语言处理和自然理解模型任务的一个核心任务，能对句子结构分步进行表示，它展示的不仅是语言的复杂内容，比如语法结构，还能提取语料库可能包含的一定数量信息。PTB是一个较小的数据集，PTB数据集由华尔街日报的文章组成，包含<unk>字符，<strong>929k</strong>个训练tokens，词汇量为<strong>10k</strong>。</unk></p><h4 id="wikitext2"><a href="#wikitext2" class="headerlink" title="wikitext2"></a>wikitext2</h4><p>wikitext2数据集源自维基百科文章，包含2M训练tokens，词汇量为33k。PTB数据集一样wikitext2数据集包含非混洗文档，因此需要模型来捕获句间依赖性才能很好地执行。</p><h4 id="text8-amp-amp-wikitext103"><a href="#text8-amp-amp-wikitext103" class="headerlink" title="text8&amp;&amp;wikitext103"></a>text8&amp;&amp;wikitext103</h4><p>text8数据集包含17M的训练标记，词汇量为44k字；而wikitext103数据集的训练集大小为103M，词汇量为267k字。这是两个中等规模的数据集。</p><h4 id="LAMBADA"><a href="#LAMBADA" class="headerlink" title="LAMBADA"></a>LAMBADA</h4><p>LAMBADA 数据集是从小说中提取的短段落的数据集。$lambada $数据集包含大约200M tokens,词汇量大小为93215。</p><h3 id="文本分类"><a href="#文本分类" class="headerlink" title="文本分类"></a>文本分类</h3><h4 id="IMDB"><a href="#IMDB" class="headerlink" title="IMDB"></a>IMDB</h4><p>这个数据包括3个部分，训练集，测试集和未标记的数据集。训练集和测试集用于训练和测试文本分类模型，未标记的数据集用于训练词向量。IMDB电影数据集含有50000个电影评论，分为正反两类。训练集包中包含25000个正反类评论用于训练，测试集中包含25000个评论用于测试。</p><h4 id="MR"><a href="#MR" class="headerlink" title="MR"></a>MR</h4><p>MR数据集是“电影评论”中的情绪极性数据集。主要包括：</p><ul><li>document-level: polarity dataset v2.0: 1000 positive and 1000 negative processed reviews.</li><li>sentence-level: sentence polarity dataset v1.0: 5331 positive and 5331 negative processed sentences/snippets.</li><li>Sentiment-scale datasets: scale dataset v1.0: a collection of documents whose labels come from a rating scale.</li><li>Subjectivity dataset v1.0: 5000 subjective and 5000 objective processed sentences.</li></ul><h4 id="Google-Snippets"><a href="#Google-Snippets" class="headerlink" title="Google Snippets"></a>Google Snippets</h4><p>Google Snippets数据集包括10060个训练样本和2280个测试样本，分为8个类。平均下来每个snippet有18.07个词。</p><h4 id="TREC"><a href="#TREC" class="headerlink" title="TREC"></a>TREC</h4><p>TREC数据集包括6个不同的问题类型，训练集有5452个标注了的问题，测试集有500个问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深度学习在计算机视觉领域取得了十分重大的突破，许多研究也是如雨后春笋般。而模型的训练离不开数据集的支持，因此有必要对常用的数据集进行了解。接下来主要对计算机视觉和自然语言处理这两个领域的常用数据集进行介绍。&lt;/p&gt;
&lt;h2 id=&quot;计算机视觉&quot;&gt;&lt;a href=&quot;#计算机视觉&quot; class=&quot;headerlink&quot; title=&quot;计算机视觉&quot;&gt;&lt;/a&gt;计算机视觉&lt;/h2&gt;&lt;h3 id=&quot;MNIST&quot;&gt;&lt;a href=&quot;#MNIST&quot; class=&quot;headerlink&quot; title=&quot;MNIST&quot;&gt;&lt;/a&gt;MNIST&lt;/h3&gt;&lt;p&gt;MNIST数据集被称为深度学习领域的“Hello World!”，入门必备！它有&lt;strong&gt;60000&lt;/strong&gt;个训练样本集和&lt;strong&gt;10000&lt;/strong&gt;个测试样本集，每个样本图像的宽高为&lt;strong&gt;28*28&lt;/strong&gt;。此数据集是以二进制存储的，不能直接以图像格式查看，不过很容易找到将其转换成图像格式的工具。&lt;/p&gt;
&lt;p&gt;该数据集可在&lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yann.lecun.com/exdb/mnist/&lt;/a&gt; 获取，主要包含以下四部分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;train-images-idx3-ubyte.gz:  training set images (9912422 bytes)&lt;/code&gt;&lt;br&gt;&lt;code&gt;train-labels-idx1-ubyte.gz:  training set labels (28881 bytes)&lt;/code&gt;&lt;br&gt;&lt;code&gt;t10k-images-idx3-ubyte.gz:   test set images (1648877 bytes)&lt;/code&gt;&lt;br&gt;&lt;code&gt;t10k-labels-idx1-ubyte.gz:   test set labels (4542 bytes)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源，DL数据集" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90%EF%BC%8CDL%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="http://yoursite.com/2018/01/22/findinsortedmatrix/"/>
    <id>http://yoursite.com/2018/01/22/findinsortedmatrix/</id>
    <published>2018-01-22T11:39:25.000Z</published>
    <updated>2018-01-27T04:04:50.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h3><p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>思路</strong>:首先选取数组右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字，则剔除这个数字所在的行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1   2   8   9       1   2   8      1  2</div><div class="line">2   4   9   12      2   4   9      2  4     2  4</div><div class="line">4   7   10  13      4   7   10     4  7     4  7     4  7</div><div class="line">6   8   11  15      6   8   11     7  8     7  8     7  8</div></pre></td></tr></table></figure><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> columns, <span class="keyword">int</span> number)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(matrix != <span class="literal">nullptr</span> &amp;&amp; rows&gt;<span class="number">0</span> &amp;&amp; columns&gt;<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> column = columns<span class="number">-1</span>;</div><div class="line">        <span class="keyword">while</span>(row&lt;rows &amp;&amp; column&gt;=<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(matrix[row*columns + column] == number)</div><div class="line">            &#123;</div><div class="line">                found = <span class="literal">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row*columns + column] &gt; number)</div><div class="line">            &#123;</div><div class="line">                --column;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                ++row;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> found;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ====================测试代码====================</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">char</span>* testname, <span class="keyword">int</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> columns, <span class="keyword">int</span> number, <span class="keyword">bool</span> expected)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(testname != <span class="literal">nullptr</span>)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%s begins: "</span>, testname);</div><div class="line">    <span class="keyword">bool</span> result = Find(matrix, rows, columns, number);</div><div class="line">    <span class="keyword">if</span>(result == expected)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Passed.\n"</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Failed.\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//  1   2   8   9</span></div><div class="line"><span class="comment">//  2   4   9   12</span></div><div class="line"><span class="comment">//  4   7   10  13</span></div><div class="line"><span class="comment">//  6   8   11  15</span></div><div class="line"><span class="comment">// 要查找的数在数组中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> matrix[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>&#125;, &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span>&#125;&#125;;</div><div class="line">    Test(<span class="string">"test1"</span>, (<span class="keyword">int</span>*)matrix, <span class="number">4</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    Test(<span class="string">"test2"</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    test1();</div><div class="line">    test2();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;二维数组中的查找&quot;&gt;&lt;a href=&quot;#二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;二维数组中的查找&quot;&gt;&lt;/a&gt;二维数组中的查找&lt;/h3&gt;&lt;p&gt;题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;:首先选取数组右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字，则剔除这个数字所在的行。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1   2   8   9       1   2   8      1  2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2   4   9   12      2   4   9      2  4     2  4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4   7   10  13      4   7   10     4  7     4  7     4  7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6   8   11  15      6   8   11     7  8     7  8     7  8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程，" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%EF%BC%8C/"/>
    
  </entry>
  
  <entry>
    <title>数组找出重复的数字</title>
    <link href="http://yoursite.com/2018/01/20/findduplicationNoEdit/"/>
    <id>http://yoursite.com/2018/01/20/findduplicationNoEdit/</id>
    <published>2018-01-20T13:17:35.000Z</published>
    <updated>2018-01-27T04:03:46.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面试题：找出数组中重复的数字"><a href="#面试题：找出数组中重复的数字" class="headerlink" title="面试题：找出数组中重复的数字"></a>面试题：找出数组中重复的数字</h3><p>　　题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3。</p><p><strong>思路</strong>：排序一个长度为n的数组需要O(nlogn)的时间，我们选择利用哈希表来解决这个问题。从头到尾顺序扫描数组的每个数字，每扫描到一个数字的时候，都可以用O(1)的时间来判断哈希表里是否包含了该数字。如果哈希表没有这个数字，就把它加入哈希表。如果哈希表已经存在该数字，就找到一个重复数字。这个算法的时间复杂度是O(n),他是以创建一个大小O(n)的哈希表为代价。现在我们重排这个数组，从头到尾依次扫描这个数组。当扫描到下标为i的数组时，首先比较这个数字（用m表示）是不是等于i。如果是，则扫描下一个数字；如果不是，则再拿它和第m个数字进行比较。如果他和地ｍ个数字相等，就找到一个重复的数字；如果他和第m个数字不相等，就把第i个数字和地ｍ个数字作交换，把Ｍ放到属于他的位置。重复比较交换这个过程，知道发现一个重复数字。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">// 参数:</span></div><div class="line"><span class="comment">//        numbers:     一个整数数组</span></div><div class="line"><span class="comment">//        length:      数组的长度</span></div><div class="line"><span class="comment">//        duplication: (输出) 数组中的一个重复的数字</span></div><div class="line"><span class="comment">// 返回值:</span></div><div class="line"><span class="comment">//        true  - 输入有效，并且数组中存在重复的数字</span></div><div class="line"><span class="comment">//        false - 输入无效，或者数组中没有重复的数字</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || length&lt;=<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(numbers[i]&lt;<span class="number">0</span> || numbers[i]&gt; length<span class="number">-1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; ++i)</div><div class="line">     &#123;</div><div class="line">         <span class="keyword">while</span>(numbers[i] != i)</div><div class="line">         &#123;</div><div class="line">             <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])</div><div class="line">             &#123;</div><div class="line">                 *duplication = numbers[i];</div><div class="line">                 <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">             &#125;</div><div class="line"></div><div class="line">             <span class="keyword">int</span> temp = numbers[i];</div><div class="line">             numbers[i] = numbers[temp];</div><div class="line">             numbers[temp] = temp;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ====================测试代码====================</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> length, <span class="keyword">int</span> number)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] == number)</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span>* testName, <span class="keyword">int</span> numbers[], <span class="keyword">int</span> lengthNumbers, <span class="keyword">int</span> expected[], <span class="keyword">int</span> expectedExpected, <span class="keyword">bool</span> validArgument)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s begins: "</span>, testName);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> duplication;</div><div class="line">    <span class="keyword">bool</span> validInput = duplicate(numbers, lengthNumbers, &amp;duplication);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(validArgument == validInput)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(validArgument)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(contains(expected, expectedExpected, duplication))</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Passed.\n"</span>);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="built_in">printf</span>(<span class="string">"FAILED.\n"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="built_in">printf</span>(<span class="string">"Passed.\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"FAILED.\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 重复的数字是数组中最小的数字</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span> &#125;;</div><div class="line">    <span class="keyword">int</span> duplications[] = &#123; <span class="number">1</span> &#125;;</div><div class="line">    test(<span class="string">"test1"</span>, numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), duplications, <span class="keyword">sizeof</span>(duplications) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 重复的数字是数组中最大的数字</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span> &#125;;</div><div class="line">    <span class="keyword">int</span> duplications[] = &#123; <span class="number">4</span> &#125;;</div><div class="line">    test(<span class="string">"test2"</span>, numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), duplications, <span class="keyword">sizeof</span>(duplications) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 数组中存在多个重复的数字</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span> &#125;;</div><div class="line">    <span class="keyword">int</span> duplications[] = &#123; <span class="number">2</span>, <span class="number">4</span> &#125;;</div><div class="line">    test(<span class="string">"test3"</span>, numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), duplications, <span class="keyword">sizeof</span>(duplications) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 数组中不存在重复的数字</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</div><div class="line">    <span class="keyword">int</span> duplications[] = &#123; <span class="number">-1</span> &#125;;</div><div class="line">    test(<span class="string">"test4"</span>, numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), duplications, <span class="keyword">sizeof</span>(duplications) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    test1();</div><div class="line">    test2();</div><div class="line">    test3();</div><div class="line">    test4();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="面试题：不修改数组找出重复的数字"><a href="#面试题：不修改数组找出重复的数字" class="headerlink" title="面试题：不修改数组找出重复的数字"></a>面试题：不修改数组找出重复的数字</h3><p>​        在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或者3。</p><p><strong>思路</strong>：如果没有重复的数字，那么1~n的范围内只有n个数字。有余数组里包含n个数字，所以一定包含了重复的数字。我们把从1~n的数字把中间的数字m分为两部分，前一半为1~m，后一半为m+1~n．如果1~m的数字的数目超过m，那么这一半的区间里一定包含重复数字；否则另外一半m+1~n的区间里一定包含重复的数字。我么可以继续把包含重复的数字的区间一分为二，直到找到一个重复的数字。</p><!-- more --><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* numbers, <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// 参数:</span></div><div class="line"><span class="comment">//        numbers:     一个整数数组</span></div><div class="line"><span class="comment">//        length:      数组的长度</span></div><div class="line"><span class="comment">// 返回值:</span></div><div class="line"><span class="comment">//        正数  - 输入有效，并且数组中存在重复的数字，返回值为重复的数字</span></div><div class="line"><span class="comment">//        负数  - 输入无效，或者数组中没有重复的数字</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDuplication</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* numbers, <span class="keyword">int</span> length)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> end = length <span class="number">-1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(start &lt;= end)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> middle = ((end - start) &gt;&gt; <span class="number">1</span>) + start;</div><div class="line">        <span class="keyword">int</span> count = countRange(numbers, length, start, middle);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(start == end)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(count &gt; <span class="number">1</span>)</div><div class="line">                <span class="keyword">return</span> start;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>((middle-start+<span class="number">1</span>) &lt; count)</div><div class="line">        &#123;</div><div class="line">            end = middle;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            start = middle+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* numbers, <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(numbers[i]&gt;=start &amp;&amp; numbers[i]&lt;=end)</div><div class="line">            ++count;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ====================测试代码====================</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* testName, <span class="keyword">int</span>* numbers, <span class="keyword">int</span> length, <span class="keyword">int</span>* duplications, <span class="keyword">int</span> dupLength)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> result = getDuplication(numbers, length);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dupLength; ++i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(result == duplications[i])</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; testName &lt;&lt; <span class="string">" passed."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; testName &lt;&lt; <span class="string">" FAILED."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 一个重复的数字</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</div><div class="line">    <span class="keyword">int</span> duplications[] = &#123; <span class="number">4</span> &#125;;</div><div class="line">    test(<span class="string">"test1"</span>, numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), duplications, <span class="keyword">sizeof</span>(duplications) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 多个重复的数字</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</div><div class="line">    <span class="keyword">int</span> duplications[] = &#123; <span class="number">2</span>, <span class="number">3</span> &#125;;</div><div class="line">    test(<span class="string">"test2"</span>, numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), duplications, <span class="keyword">sizeof</span>(duplications) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 数组中只有两个数字</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">1</span>, <span class="number">1</span> &#125;;</div><div class="line">    <span class="keyword">int</span> duplications[] = &#123; <span class="number">1</span> &#125;;</div><div class="line">    test(<span class="string">"test3"</span>, numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), duplications, <span class="keyword">sizeof</span>(duplications) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 数组中没有重复的数字</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</div><div class="line">    <span class="keyword">int</span> duplications[] = &#123; <span class="number">1</span> &#125;;</div><div class="line">    test(<span class="string">"test4"</span>, numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), duplications, <span class="keyword">sizeof</span>(duplications) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 无效的输入</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span>* numbers = <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">int</span> duplications[] = &#123; <span class="number">1</span> &#125;;</div><div class="line">    test(<span class="string">"test5"</span>, numbers, <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>), duplications, <span class="keyword">sizeof</span>(duplications) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    test1();</div><div class="line">    test2();</div><div class="line">    test3();</div><div class="line">    test4();</div><div class="line">    test5();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;面试题：找出数组中重复的数字&quot;&gt;&lt;a href=&quot;#面试题：找出数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;面试题：找出数组中重复的数字&quot;&gt;&lt;/a&gt;面试题：找出数组中重复的数字&lt;/h3&gt;&lt;p&gt;　　题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：排序一个长度为n的数组需要O(nlogn)的时间，我们选择利用哈希表来解决这个问题。从头到尾顺序扫描数组的每个数字，每扫描到一个数字的时候，都可以用O(1)的时间来判断哈希表里是否包含了该数字。如果哈希表没有这个数字，就把它加入哈希表。如果哈希表已经存在该数字，就找到一个重复数字。这个算法的时间复杂度是O(n),他是以创建一个大小O(n)的哈希表为代价。现在我们重排这个数组，从头到尾依次扫描这个数组。当扫描到下标为i的数组时，首先比较这个数字（用m表示）是不是等于i。如果是，则扫描下一个数字；如果不是，则再拿它和第m个数字进行比较。如果他和地ｍ个数字相等，就找到一个重复的数字；如果他和第m个数字不相等，就把第i个数字和地ｍ个数字作交换，把Ｍ放到属于他的位置。重复比较交换这个过程，知道发现一个重复数字。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程，数组" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch</title>
    <link href="http://yoursite.com/2018/01/16/torch/"/>
    <id>http://yoursite.com/2018/01/16/torch/</id>
    <published>2018-01-16T05:57:07.000Z</published>
    <updated>2018-01-19T13:25:49.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Torch"><a href="#Torch" class="headerlink" title="Torch"></a>Torch</h3><p><code>torch</code>包含了多维的数据结构以及基于其上的数学运算。它提供了多种实用工具，具有CUDA对应的实现</p><h2 id="张量-Tensors"><a href="#张量-Tensors" class="headerlink" title="张量 Tensors"></a>张量 Tensors</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.is_tensor(obj)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">b = np.random.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">torch.is_tensor(a)</div><div class="line">Out[<span class="number">1</span>]: <span class="keyword">True</span></div><div class="line">torch.is_tensor(b)</div><div class="line">Out[<span class="number">2</span>]: <span class="keyword">False</span></div></pre></td></tr></table></figure><p>判断是否为张量，如果是pytorch张量，则返回True</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.is_storage(obj)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">x = torch.FloatTensor(a)</div><div class="line">y = x.storage()</div><div class="line">torch.is_storage(x)</div><div class="line">Out[<span class="number">1</span>]: <span class="keyword">False</span></div><div class="line">torch.is_storage(y)</div><div class="line">Out[<span class="number">2</span>]: <span class="keyword">True</span></div></pre></td></tr></table></figure><p>判断是否为pytorch Storage，如何是，则返回True</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.numel(input)-&gt;int</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">torch.numel(a)</div><div class="line">Out[<span class="number">1</span>]: <span class="number">12</span></div></pre></td></tr></table></figure><p>返回<code>input</code> 张量中的元素个数　　参数:  input (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="external">Tensor</a>) – 输入张量</p><h2 id="创建操作-Creation-Ops"><a href="#创建操作-Creation-Ops" class="headerlink" title="创建操作 Creation Ops"></a>创建操作 Creation Ops</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.eye(n, m=<span class="keyword">None</span>, out=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>参数: </p><ul><li><code>n</code> (int) – 行数</li><li><code>m</code> (int, 可选) – 列数.如果为None,则默认为<em>n</em> </li><li><code>out</code>  (Tensor,可选) -  输出张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">torch.eye(<span class="number">3</span>)</div><div class="line">Out[<span class="number">1</span>]: [torch.FloatTensor of size <span class="number">3</span>x3]</div><div class="line">    </div><div class="line">torch.eye(<span class="number">3</span>, m=<span class="number">4</span>)</div><div class="line">torch.eye(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">Out[<span class="number">2</span>]:</div><div class="line"><span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div><div class="line"></div><div class="line">torch.eye(<span class="number">3</span>,<span class="number">3</span>,out=torch.LongTensor())</div><div class="line">Out[<span class="number">3</span>]:[torch.LongTensor of size <span class="number">3</span>x4]</div></pre></td></tr></table></figure><p>返回一个2维张量，对角线数字为1，其它位置为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.from_numpy(ndarray) → Tensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line">torch.from_numpy(x)</div><div class="line">Out[<span class="number">1</span>]: [torch.LongTensor of size <span class="number">3</span>]</div><div class="line">x</div><div class="line">Out[<span class="number">13</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div></pre></td></tr></table></figure><p>将<code>numpy.ndarray</code>转换为<code>Tensor</code>。返回的张量tensor和numpy的ndarray共享一个内存空间。修改一个会导致另外一个也被修改。返回的张量不能调整大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.linspace(start, end, steps=<span class="number">100</span>, ut=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><p>参数: </p><ul><li><code>start</code> (float) – 点集的开始值</li><li><code>end</code> (float) – 点集的最终值</li><li><code>steps</code>  (int) -  在<code>start</code>和<code>end</code>之间的采样数</li><li><code>out (Tensor, 可选的)</code> – 结果张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">torch.linspace(<span class="number">1</span>, <span class="number">10</span>, <span class="number">4</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line">  <span class="number">1</span></div><div class="line">  <span class="number">4</span></div><div class="line">  <span class="number">7</span></div><div class="line"> <span class="number">10</span></div><div class="line">[torch.FloatTensor of size <span class="number">4</span>]</div></pre></td></tr></table></figure><p>返回start和end之间长度为<code>steps</code>的一维张量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.ones(*sizes, out=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">m = a.size()</div><div class="line">torch.ones(*m)</div><div class="line">Out[<span class="number">1</span>]:</div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div></pre></td></tr></table></figure><p>返回一个全为1的张量，形状由可变参数<code>sizes</code>定义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.randperm(n, out=<span class="keyword">None</span>) → LongTensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">torch.randperm(<span class="number">3</span>)</div><div class="line">Out[<span class="number">25</span>]: </div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">2</span></div><div class="line"> <span class="number">0</span></div><div class="line">[torch.LongTensor of size <span class="number">3</span>]</div></pre></td></tr></table></figure><p>输入参数<code>n</code>，返回一个从<code>0</code> 到<code>n -1</code>的随机整数排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.arange(start, end, step=<span class="number">1</span>, out=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">torch.arange(<span class="number">1</span>, <span class="number">10</span>, step=<span class="number">4</span>)</div><div class="line">Out[<span class="number">27</span>]: </div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">5</span></div><div class="line"> <span class="number">9</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>]</div></pre></td></tr></table></figure><p>返回一个1维张量，长度为floor((end−start)/step),floor代表向下取整。包含从<code>start</code>到<code>end</code>，以<code>step</code>为步长的一组序列值(默认步长为1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.zeros(*sizes, out=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">m = a.size()</div><div class="line">torch.zeros(*m)</div><div class="line">Out[<span class="number">1</span>]:</div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div></pre></td></tr></table></figure><p>返回一个全0的张量，形状由可变参数<code>sizes</code>定义。</p><h2 id="索引-切片-连接-变异操作"><a href="#索引-切片-连接-变异操作" class="headerlink" title="索引,切片,连接,变异操作"></a>索引,切片,连接,变异操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.cat(seq, dim=0, out=None) → Tensor</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>seq</code>（Tensors的序列） - 可以是相同类型的Tensor的任何python序列。</li><li><code>dim</code>（int，可选） - 张量连接的尺寸</li><li><code>out</code>（Tensor，可选） - 输出参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">torch.cat((a, a, a),<span class="number">0</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line">[torch.FloatTensor of size <span class="number">9</span>x4]</div><div class="line"></div><div class="line">torch.cat((a, a, a),<span class="number">1</span>) &amp; torch.cat((a, a, a),<span class="number">-1</span>)</div><div class="line">Out[<span class="number">2</span>]: </div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x12]</div></pre></td></tr></table></figure><p>在给定维度上对输入的张量序列<code>seq</code> 进行连接操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.chunk(tensor, chunks, dim=<span class="number">0</span>)</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>tensor</code> (Tensor) – 待分块的输入张量</li><li><code>chunks</code> (int) – 分块的个数</li><li><code>dim</code>(int) – 沿着此维度进行分块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">b = torch.randn(<span class="number">3</span>,<span class="number">6</span>)</div><div class="line">torch.chunk(b, <span class="number">3</span>, <span class="number">0</span>)</div><div class="line">Out[<span class="number">46</span>]: </div><div class="line">(</div><div class="line"> <span class="number">-1.2120</span>  <span class="number">0.0617</span>  <span class="number">0.2106</span> <span class="number">-0.3776</span> <span class="number">-2.2615</span>  <span class="number">1.2279</span></div><div class="line"> [torch.FloatTensor of size <span class="number">1</span>x6], </div><div class="line">  <span class="number">0.1425</span>  <span class="number">1.3961</span> <span class="number">-0.6864</span>  <span class="number">0.7581</span>  <span class="number">0.5757</span> <span class="number">-0.7915</span></div><div class="line"> [torch.FloatTensor of size <span class="number">1</span>x6], </div><div class="line">  <span class="number">0.5075</span> <span class="number">-1.8589</span> <span class="number">-0.5447</span> <span class="number">-0.6180</span>  <span class="number">0.2896</span>  <span class="number">0.1451</span></div><div class="line"> [torch.FloatTensor of size <span class="number">1</span>x6])</div><div class="line"></div><div class="line">torch.chunk(b, <span class="number">3</span>, <span class="number">1</span>)</div><div class="line">Out[<span class="number">47</span>]: </div><div class="line">(</div><div class="line"> <span class="number">-1.2120</span>  <span class="number">0.0617</span></div><div class="line">  <span class="number">0.1425</span>  <span class="number">1.3961</span></div><div class="line">  <span class="number">0.5075</span> <span class="number">-1.8589</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>x2], </div><div class="line">  <span class="number">0.2106</span> <span class="number">-0.3776</span></div><div class="line"> <span class="number">-0.6864</span>  <span class="number">0.7581</span></div><div class="line"> <span class="number">-0.5447</span> <span class="number">-0.6180</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>x2], </div><div class="line"> <span class="number">-2.2615</span>  <span class="number">1.2279</span></div><div class="line">  <span class="number">0.5757</span> <span class="number">-0.7915</span></div><div class="line">  <span class="number">0.2896</span>  <span class="number">0.1451</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>x2])</div></pre></td></tr></table></figure><p>将张量沿着给定维度分解成的多个块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.gather(input, dim, index, out=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><p>参数： </p><ul><li><code>input</code>(Tensor) - 源张量</li><li><code>dim</code>(int) - 要索引的轴</li><li><code>index</code>(LongTensor) - 要收集的元素的索引</li><li><code>out</code>(Tensor，可选) - 目的张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">x = torch.FloatTensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</div><div class="line">Out[<span class="number">50</span>]: </div><div class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line"> <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line"> <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x3]</div><div class="line"></div><div class="line">torch.gather(x, <span class="number">0</span>, torch.LongTensor([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]))</div><div class="line">Out[<span class="number">58</span>]: </div><div class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x3]</div><div class="line"></div><div class="line">torch.gather(x, <span class="number">1</span>, torch.LongTensor([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]))</div><div class="line">Out[<span class="number">60</span>]: </div><div class="line"> <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span></div><div class="line"> <span class="number">4</span>  <span class="number">4</span>  <span class="number">4</span></div><div class="line"> <span class="number">7</span>  <span class="number">7</span>  <span class="number">7</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x3]</div><div class="line"></div><div class="line">torch.gather(x, <span class="number">0</span>, torch.LongTensor([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]))</div><div class="line">Out[<span class="number">59</span>]: </div><div class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line"> <span class="number">4</span>  <span class="number">2</span>  <span class="number">6</span></div><div class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x3]</div></pre></td></tr></table></figure><p>沿给定轴<code>dim</code>，将输入索引张量<code>index</code>指定位置的值进行聚合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.index_select(input, dim, index, out=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>input</code> (Tensor) – 输入张量</li><li><code>dim</code> (int) – 索引的轴</li><li><code>index</code> (LongTensor) – 包含索引下标的一维张量</li><li><code>out</code> (Tensor, 可选的) – 目标张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">index = torch.LongTensor([<span class="number">0</span>,<span class="number">1</span>])</div><div class="line">torch.index_select(a, <span class="number">0</span>, index)</div><div class="line">Out[<span class="number">66</span>]: </div><div class="line"> <span class="number">0.6552</span>  <span class="number">1.2615</span> <span class="number">-1.8676</span> <span class="number">-1.3015</span></div><div class="line"><span class="number">-0.6448</span> <span class="number">-0.0267</span>  <span class="number">0.6535</span> <span class="number">-0.2193</span></div><div class="line">[torch.FloatTensor of size <span class="number">2</span>x4]</div><div class="line"></div><div class="line">torch.index_select(a, <span class="number">1</span>, index)</div><div class="line">Out[<span class="number">67</span>]: </div><div class="line"> <span class="number">0.6552</span>  <span class="number">1.2615</span></div><div class="line"><span class="number">-0.6448</span> <span class="number">-0.0267</span></div><div class="line"><span class="number">-0.0179</span> <span class="number">-0.2577</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x2]</div></pre></td></tr></table></figure><p>返回一个新的张量，其索引input 张量沿尺寸 dim使用的条目中index这是一个LongTensor。</p><p>返回的Tensor具有与原始Tensor相同数量的尺寸。注意： 返回的张量不与原始张量共享内存空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"> <span class="number">0.6552</span>  <span class="number">1.2615</span> <span class="number">-1.8676</span> <span class="number">-1.3015</span></div><div class="line"><span class="number">-0.6448</span> <span class="number">-0.0267</span>  <span class="number">0.6535</span> <span class="number">-0.2193</span></div><div class="line"><span class="number">-0.0179</span> <span class="number">-0.2577</span>  <span class="number">0.0076</span>  <span class="number">0.2455</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div><div class="line"></div><div class="line">mask = a.ge(<span class="number">0.5</span>)</div><div class="line">a.ge(<span class="number">0.5</span>)</div><div class="line">Out[<span class="number">2</span>]: </div><div class="line"> <span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line"> <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></div><div class="line"> <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">[torch.ByteTensor of size <span class="number">3</span>x4]</div><div class="line"></div><div class="line">torch.masked_select(a, mask)</div><div class="line">Out[<span class="number">3</span>]: </div><div class="line"> <span class="number">0.6552</span></div><div class="line"> <span class="number">1.2615</span></div><div class="line"> <span class="number">0.6535</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>]</div></pre></td></tr></table></figure><p>根据掩码张量<code>mask</code>中的二元值，取输入张量中的指定项( <code>mask</code>为一个 <em>ByteTensor</em>)，将取值返回到一个新的1D张量，张量 <code>mask</code>须跟<code>input</code>张量有相同数量的元素数目，但形状或维度不需要相同。注意： 返回的张量不与原始张量共享内存空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.nonzero(input, out=<span class="keyword">None</span>) → LongTensor</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>input</code> (Tensor) – 源张量</li><li><code>out</code> (LongTensor, 可选的) – 包含索引值的结果张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">b = torch.Tensor([<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>])</div><div class="line">torch.nonzero(b)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"> <span class="number">0</span></div><div class="line"> <span class="number">2</span></div><div class="line"> <span class="number">3</span></div><div class="line">[torch.LongTensor of size <span class="number">3</span>x1]</div></pre></td></tr></table></figure><p>返回一个包含输入<code>input</code>中非零元素索引的张量。输出张量中的每行包含输入中非零元素的索引。</p><p>如果输入<code>input</code>有<code>n</code>维，则输出的索引张量<code>output</code>的形状为 z x n, 这里 z 是输入张量<code>input</code>中所有非零元素的个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.split(tensor, split_size, dim=<span class="number">0</span>)</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>tensor</code>  (Tensor) – 待分割张量</li><li><code>split_size</code>  (int) – 单个分块的形状大小</li><li><code>dim</code>  (int) – 沿着此维进行分割</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">torch.split(a,<span class="number">1</span>,<span class="number">0</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line">(</div><div class="line">  <span class="number">0.6552</span>  <span class="number">1.2615</span> <span class="number">-1.8676</span> <span class="number">-1.3015</span></div><div class="line"> [torch.FloatTensor of size <span class="number">1</span>x4], </div><div class="line"> <span class="number">-0.6448</span> <span class="number">-0.0267</span>  <span class="number">0.6535</span> <span class="number">-0.2193</span></div><div class="line"> [torch.FloatTensor of size <span class="number">1</span>x4], </div><div class="line"> <span class="number">-0.0179</span> <span class="number">-0.2577</span>  <span class="number">0.0076</span>  <span class="number">0.2455</span></div><div class="line"> [torch.FloatTensor of size <span class="number">1</span>x4])</div><div class="line"></div><div class="line">torch.split(a,<span class="number">1</span>,<span class="number">1</span>)</div><div class="line">Out[<span class="number">101</span>]: </div><div class="line">(</div><div class="line">  <span class="number">0.6552</span></div><div class="line"> <span class="number">-0.6448</span></div><div class="line"> <span class="number">-0.0179</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>x1], </div><div class="line">  <span class="number">1.2615</span></div><div class="line"> <span class="number">-0.0267</span></div><div class="line"> <span class="number">-0.2577</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>x1], </div><div class="line"> <span class="number">-1.8676</span></div><div class="line">  <span class="number">0.6535</span></div><div class="line">  <span class="number">0.0076</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>x1], </div><div class="line"> <span class="number">-1.3015</span></div><div class="line"> <span class="number">-0.2193</span></div><div class="line">  <span class="number">0.2455</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>x1])</div></pre></td></tr></table></figure><p>将输入张量分割成相等形状的chunks（如果可分）。 如果沿指定维的张量形状大小不能被<code>split_size</code> 整分， 则最后一个分块会小于其它分块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.squeeze(input, dim=<span class="keyword">None</span>, out=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>参数: </p><ul><li><code>input</code> (Tensor) – 输入张量</li><li><code>dim</code> (int, 可选的) – 如果给定，则<code>input</code>只会在给定维度挤压</li><li><code>out</code> (Tensor, 可选的) – 输出张量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">x = torch.zeros(2, 1, 2, 1, 2)</div><div class="line">torch.squeeze(x)</div><div class="line">Out[1]: </div><div class="line">[torch.FloatTensor of size 2x2x2]</div><div class="line"></div><div class="line">torch.squeeze(x, 0)</div><div class="line">Out[2]: </div><div class="line">[torch.FloatTensor of size 2x1x2x1x2]</div><div class="line"></div><div class="line">torch.squeeze(x,1)</div><div class="line">Out[3]:</div><div class="line">[torch.FloatTensor of size 2x2x1x2]</div></pre></td></tr></table></figure><p>将输入张量形状中的<code>1</code> 去除并返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.unsqueeze(input, dim, out=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>tensor</code> (Tensor) – 输入张量</li><li><code>dim</code> (int)  – 插入维度的索引</li><li><code>out</code> (Tensor, 可选的) – 结果张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">x = torch.FloatTensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</div><div class="line">torch.unsqueeze(x, <span class="number">0</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line">(<span class="number">0</span> ,.,.) = </div><div class="line">  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line">  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line">[torch.FloatTensor of size <span class="number">1</span>x2x3]</div><div class="line"></div><div class="line">torch.unsqueeze(x, <span class="number">1</span>)</div><div class="line">Out[<span class="number">2</span>]: </div><div class="line">(<span class="number">0</span> ,.,.) = </div><div class="line">  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line">(<span class="number">1</span> ,.,.) = </div><div class="line">  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line">[torch.FloatTensor of size <span class="number">2</span>x1x3]</div><div class="line"></div><div class="line">torch.unsqueeze(x, <span class="number">2</span>)</div><div class="line">Out[<span class="number">3</span>]: </div><div class="line">(<span class="number">0</span> ,.,.) = </div><div class="line">  <span class="number">1</span></div><div class="line">  <span class="number">2</span></div><div class="line">  <span class="number">3</span></div><div class="line">(<span class="number">1</span> ,.,.) = </div><div class="line">  <span class="number">4</span></div><div class="line">  <span class="number">5</span></div><div class="line">  <span class="number">6</span></div><div class="line">[torch.FloatTensor of size <span class="number">2</span>x3x1]</div></pre></td></tr></table></figure><p>返回一个新的张量，对输入的制定位置插入维度 1</p><p>如果<code>dim</code>为负，则将会被转化dim+input.dim()+1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.stack(sequence, dim=0)</div></pre></td></tr></table></figure><p>参数: </p><ul><li><code>sequence</code> (Sequence) – 待连接的张量序列</li><li><code>dim</code> (int) – 插入的维度。必须介于 0 与 待连接的张量序列数之间。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">x = torch.FloatTensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</div><div class="line">torch.stack((x, x), <span class="number">0</span>)</div><div class="line">Out[<span class="number">115</span>]: </div><div class="line">(<span class="number">0</span> ,.,.) = </div><div class="line">  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line">  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line">(<span class="number">1</span> ,.,.) = </div><div class="line">  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></div><div class="line">  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span></div><div class="line">[torch.FloatTensor of size <span class="number">2</span>x2x3]</div><div class="line"></div><div class="line">torch.stack((x, x), <span class="number">2</span>)</div><div class="line">Out[<span class="number">117</span>]: </div><div class="line">(<span class="number">0</span> ,.,.) = </div><div class="line">  <span class="number">1</span>  <span class="number">1</span></div><div class="line">  <span class="number">2</span>  <span class="number">2</span></div><div class="line">  <span class="number">3</span>  <span class="number">3</span></div><div class="line">(<span class="number">1</span> ,.,.) = </div><div class="line">  <span class="number">4</span>  <span class="number">4</span></div><div class="line">  <span class="number">5</span>  <span class="number">5</span></div><div class="line">  <span class="number">6</span>  <span class="number">6</span></div><div class="line">[torch.FloatTensor of size <span class="number">2</span>x3x2]</div></pre></td></tr></table></figure><p>沿着一个新维度对输入张量序列进行连接。序列中所有的张量都应该为相同形状。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.take(input, indices) → Tensor</div></pre></td></tr></table></figure><p>参数: </p><ul><li><code>input</code> (Tensor) – 输入张量</li><li><code>indices</code>(LongTensor) – 索引到张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">x = torch.FloatTensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</div><div class="line">torch.take(x, torch.LongTensor([<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>]))</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">3</span></div><div class="line"> <span class="number">6</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>]</div></pre></td></tr></table></figure><p>用给定索引处的输入元素返回一个新的张量， 输入张量被看作是一维张量。 结果与指数具有相同形状。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.transpose(input, dim0, dim1, out=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><p>参数: </p><ul><li><code>input</code> (Tensor) – 输入张量</li><li><code>dim0</code> (int) – 转置的第一维</li><li><code>dim1</code>  (int) – 转置的第二维 </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"> <span class="number">0.6552</span>  <span class="number">1.2615</span> <span class="number">-1.8676</span> <span class="number">-1.3015</span></div><div class="line"><span class="number">-0.6448</span> <span class="number">-0.0267</span>  <span class="number">0.6535</span> <span class="number">-0.2193</span></div><div class="line"><span class="number">-0.0179</span> <span class="number">-0.2577</span>  <span class="number">0.0076</span>  <span class="number">0.2455</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div><div class="line"></div><div class="line">torch.transpose(a, <span class="number">0</span>, <span class="number">1</span>)</div><div class="line">Out[<span class="number">2</span>]: </div><div class="line"> <span class="number">0.6552</span> <span class="number">-0.6448</span> <span class="number">-0.0179</span></div><div class="line"> <span class="number">1.2615</span> <span class="number">-0.0267</span> <span class="number">-0.2577</span></div><div class="line"><span class="number">-1.8676</span>  <span class="number">0.6535</span>  <span class="number">0.0076</span></div><div class="line"><span class="number">-1.3015</span> <span class="number">-0.2193</span>  <span class="number">0.2455</span></div><div class="line">[torch.FloatTensor of size <span class="number">4</span>x3]</div></pre></td></tr></table></figure><p>返回输入矩阵<code>input</code>的转置。交换维度<code>dim0</code>和<code>dim1</code>。输出张量与输入张量共享内存，所以改变其中一个会导致另外一个也被修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.unbind(tensor, dim=<span class="number">0</span>)</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>tensor</code> (Tensor) – 输入张量</li><li><code>dim</code> (int) – 删除的维度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>,<span class="number">4</span>)</div><div class="line">torch.unbind(a, <span class="number">1</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line">(</div><div class="line">  <span class="number">0.6552</span></div><div class="line"> <span class="number">-0.6448</span></div><div class="line"> <span class="number">-0.0179</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>], </div><div class="line">  <span class="number">1.2615</span></div><div class="line"> <span class="number">-0.0267</span></div><div class="line"> <span class="number">-0.2577</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>], </div><div class="line"> <span class="number">-1.8676</span></div><div class="line">  <span class="number">0.6535</span></div><div class="line">  <span class="number">0.0076</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>], </div><div class="line"> <span class="number">-1.3015</span></div><div class="line"> <span class="number">-0.2193</span></div><div class="line">  <span class="number">0.2455</span></div><div class="line"> [torch.FloatTensor of size <span class="number">3</span>])</div><div class="line"></div><div class="line">torch.unbind(a, <span class="number">0</span>)</div><div class="line">Out[<span class="number">2</span>]: </div><div class="line">(</div><div class="line">  <span class="number">0.6552</span></div><div class="line">  <span class="number">1.2615</span></div><div class="line"> <span class="number">-1.8676</span></div><div class="line"> <span class="number">-1.3015</span></div><div class="line"> [torch.FloatTensor of size <span class="number">4</span>], </div><div class="line"> <span class="number">-0.6448</span></div><div class="line"> <span class="number">-0.0267</span></div><div class="line">  <span class="number">0.6535</span></div><div class="line"> <span class="number">-0.2193</span></div><div class="line"> [torch.FloatTensor of size <span class="number">4</span>], </div><div class="line"> <span class="number">-0.0179</span></div><div class="line"> <span class="number">-0.2577</span></div><div class="line">  <span class="number">0.0076</span></div><div class="line">  <span class="number">0.2455</span></div><div class="line"> [torch.FloatTensor of size <span class="number">4</span>])</div></pre></td></tr></table></figure><p>移除指定维后，返回一个元组，包含了沿着指定维切片后的各个切片</p><h2 id="随机抽样-Random-sampling"><a href="#随机抽样-Random-sampling" class="headerlink" title="随机抽样 Random sampling"></a>随机抽样 Random sampling</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.manual_seed(seed)</div></pre></td></tr></table></figure><p>设定生成随机数的种子，并返回一个 _torch.<em>C.Generator</em> 对象.</p><p>参数: seed (int or long) – 种子.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.initial_seed()</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">torch.manual_seed(<span class="number">2</span>)</div><div class="line">Out[<span class="number">1</span>]: &lt;torch._C.Generator at <span class="number">0x7fa4860b2370</span>&gt;</div><div class="line">    </div><div class="line">torch.initial_seed()</div><div class="line">Out[<span class="number">2</span>]: <span class="number">2L</span></div></pre></td></tr></table></figure><p>返回生成随机数的原始种子值（python long）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.get_rng_state()</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">torch.get_rng_state()</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line">   <span class="number">2</span></div><div class="line">   <span class="number">0</span></div><div class="line">   <span class="number">0</span></div><div class="line"> ⋮  </div><div class="line">   <span class="number">0</span></div><div class="line">   <span class="number">0</span></div><div class="line">   <span class="number">0</span></div><div class="line">[torch.ByteTensor of size <span class="number">5048</span>]</div></pre></td></tr></table></figure><p>返回随机生成器状态(<em>ByteTensor</em>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.set_rng_state(new_state)</div></pre></td></tr></table></figure><p>设定随机生成器状态参数:     new_state (torch.ByteTensor) – 期望的状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.bernoulli(input, out=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">b = torch.Tensor(<span class="number">3</span>,<span class="number">4</span>).uniform_(<span class="number">0</span>,<span class="number">1</span>)</div><div class="line">b</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"> <span class="number">0.5596</span>  <span class="number">0.5591</span>  <span class="number">0.0915</span>  <span class="number">0.2100</span></div><div class="line"> <span class="number">0.0072</span>  <span class="number">0.0390</span>  <span class="number">0.9929</span>  <span class="number">0.9131</span></div><div class="line"> <span class="number">0.6186</span>  <span class="number">0.9744</span>  <span class="number">0.3189</span>  <span class="number">0.2148</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div><div class="line"></div><div class="line">torch.bernoulli(b)</div><div class="line">Out[<span class="number">2</span>]: </div><div class="line"> <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line"> <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span></div><div class="line"> <span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div></pre></td></tr></table></figure><p>从伯努利分布中抽取二元随机数(0 或者 1)。输入张量须包含用于抽取上述二元随机值的概率。 因此，输入中的所有值都必须在［0,1］区间，即 ( 0&lt;=input_i&lt;=1 )输出张量的第<em>i</em>个元素值， 将会以输入张量的第<em>i</em>个概率值等于<code>1</code>。返回值将会是与输入相同大小的张量，每个值为0或者1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.multinomial(input, num_samples,replacement=False, out=None) → LongTensor</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>input</code> (Tensor) – 包含概率值的张量</li><li><code>num_samples</code> (int) – 抽取的样本数</li><li><code>replacement</code> (bool, 可选的) – 布尔值，决定是否能重复抽取</li><li><code>out</code> (Tensor, 可选的) – 结果张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">weights = torch.Tensor([<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">1</span>])</div><div class="line">torch.multinomial(weights, <span class="number">4</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">2</span></div><div class="line"> <span class="number">3</span></div><div class="line"> <span class="number">0</span></div><div class="line">[torch.LongTensor of size <span class="number">4</span>]</div><div class="line"></div><div class="line">torch.multinomial(weights, <span class="number">4</span>, replacement=<span class="keyword">True</span>)</div><div class="line">Out[<span class="number">2</span>]: </div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">1</span></div><div class="line">[torch.LongTensor of size <span class="number">4</span>]</div></pre></td></tr></table></figure><p>返回一个张量，每行包含从<code>input</code>相应行中定义的多项分布中抽取的<code>num_samples</code>个样本。 </p><p>当抽取样本时，依次从左到右排列(第一个样本对应第一列)。</p><p>如果输入<code>input</code>是一个向量，输出<code>out</code>也是一个相同长度<code>num_samples</code>的向量。如果输入<code>input</code>是有 (m )行的矩阵，输出<code>out</code>是形如( m * n )的矩阵。</p><p>如果参数<code>replacement</code> 为 <em>True</em>, 则样本抽取可以重复。否则，一个样本在每行不能被重复抽取。</p><p>参数<code>num_samples</code>必须小于<code>input</code>长度(即，<code>input</code>的列数，如果是<code>input</code>是一个矩阵)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.normal(means, std, out=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>means</code>  (Tensor) – 均值</li><li><code>std</code>  (Tensor) – 标准差</li><li><code>out</code>  (Tensor) – 可选的输出张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">torch.normal(means=torch.arange(<span class="number">0</span>, <span class="number">11</span>), std=torch.arange(<span class="number">1</span>, <span class="number">0</span>, <span class="number">-0.1</span>))</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line">  <span class="number">0.3889</span></div><div class="line"> <span class="number">-0.1244</span></div><div class="line">  <span class="number">1.4945</span></div><div class="line">  <span class="number">3.0249</span></div><div class="line">  <span class="number">3.4251</span></div><div class="line">  <span class="number">4.1258</span></div><div class="line">  <span class="number">6.5222</span></div><div class="line">  <span class="number">7.0321</span></div><div class="line">  <span class="number">7.9798</span></div><div class="line">  <span class="number">8.9608</span></div><div class="line"> <span class="number">10.0000</span></div><div class="line">[torch.FloatTensor of size <span class="number">11</span>]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.normal(mean=<span class="number">0.0</span>, std, out=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">torch.normal(mean=<span class="number">0.5</span>, std=torch.arange(<span class="number">1</span>,<span class="number">6</span>))</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"><span class="number">-0.4879</span></div><div class="line"><span class="number">-0.2523</span></div><div class="line"><span class="number">-0.3742</span></div><div class="line"><span class="number">-1.0413</span></div><div class="line"> <span class="number">2.2176</span></div><div class="line">[torch.FloatTensor of size <span class="number">5</span>]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.normal(means, std=<span class="number">1.0</span>, out=<span class="keyword">None</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">torch.normal(means=torch.arange(<span class="number">1</span>,<span class="number">6</span>))</div><div class="line">Out[<span class="number">171</span>]: </div><div class="line"> <span class="number">1.9339</span></div><div class="line"> <span class="number">1.5494</span></div><div class="line"> <span class="number">1.9340</span></div><div class="line"> <span class="number">3.5107</span></div><div class="line"> <span class="number">3.8822</span></div><div class="line">[torch.FloatTensor of size <span class="number">5</span>]</div></pre></td></tr></table></figure><p>返回一个张量，包含从给定参数<code>means</code>,<code>std</code>的离散正态分布中抽取随机数。均值<code>means</code>是一个张量，包含每个输出元素相关的正态分布的均值。<code>std</code>是一个张量，包含每个输出元素相关的正态分布的标准差。均值和标准差的形状不须匹配，但每个张量的元素个数须相同。</p><h2 id="序列化-Serialization"><a href="#序列化-Serialization" class="headerlink" title="序列化 Serialization"></a>序列化 Serialization</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.save(obj, f, pickle_module=&lt;module <span class="string">'pickle'</span> <span class="keyword">from</span> <span class="string">'/usr/bin/python2.7/pickle.py'</span>&gt;, pickle_protocol=<span class="number">2</span>)</div></pre></td></tr></table></figure><p>参数：</p><ul><li><code>obj</code> – 保存对象</li><li><code>f</code> － 类文件对象 (返回文件描述符)或一个保存文件名的字符串</li><li><code>pickle_module</code>  – 用于pickling元数据和对象的模块</li><li><code>pickle_protocol</code>  – 指定pickle protocal 可以覆盖默认参数</li></ul><p>保存一个对象到一个硬盘文件上。参见 <a href="http://pytorch.org/docs/0.3.0/notes/serialization.html#recommend-saving-models" target="_blank" rel="external">Recommended approach for saving a model</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.load(f, map_location=<span class="keyword">None</span>, pickle_module=&lt;module <span class="string">'pickle'</span> <span class="keyword">from</span> <span class="string">'/usr/bin/python2.7/pickle.py'</span>&gt;)</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>f</code> – 类文件对象 (返回文件描述符)或一个保存文件名的字符串</li><li><code>map_location</code>  – 一个函数或字典规定如何remap存储位置</li><li><code>pickle_module</code>   – 用于unpickling元数据和对象的模块 (必须匹配序列化文件时的pickle_module )</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>torch.load(<span class="string">'tensors.pt'</span>)</div><div class="line"><span class="comment"># Load all tensors onto the CPU</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>torch.load(<span class="string">'tensors.pt'</span>, map_location=<span class="keyword">lambda</span> storage, loc: storage)</div><div class="line"><span class="comment"># Map tensors from GPU 1 to GPU 0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>torch.load(<span class="string">'tensors.pt'</span>, map_location=&#123;<span class="string">'cuda:1'</span>:<span class="string">'cuda:0'</span>&#125;)</div></pre></td></tr></table></figure><p>从磁盘文件中读取一个通过<code>torch.save()</code>保存的对象。<code>torch.load()</code> 可通过参数<code>map_location</code><br>动态地进行内存重映射，使其能从不动设备中读取文件。一般调用时，需两个参数: storage 和 location tag. 返回不同地址中的storage，或着返回None (此时地址可以通过默认方法进行解析). 如果这个参数是字典的话，意味着其是从文件的地址标记到当前系统的地址标记的映射。默认情况下， location tags中 “cpu”对应host tensors，‘cuda:device_id’ (e.g. ‘cuda:2’) 对应cuda tensors。</p><p>用户可以通过register_package进行扩展，使用自己定义的标记和反序列化方法。</p><h1 id="数学操作Math-operations"><a href="#数学操作Math-operations" class="headerlink" title="数学操作Math operations"></a>数学操作Math operations</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.abs(input, out=<span class="keyword">None</span>) → Tensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">torch.abs(torch.FloatTensor([<span class="number">-1</span>, <span class="number">2</span>, <span class="number">-3</span>]))</div><div class="line">Out[<span class="number">8</span>]: </div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">2</span></div><div class="line"> <span class="number">3</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>]</div></pre></td></tr></table></figure><p>计算输入张量的每个元素绝对值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.add(input, value, out=None)</div></pre></td></tr></table></figure><p>参数:</p><ul><li><code>input</code> (Tensor) – 输入张量</li><li><code>value</code> (Number) – 添加到输入每个元素的数</li><li><code>out</code> (Tensor, 可选的) – 结果张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>, <span class="number">4</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"><span class="number">-0.5815</span> <span class="number">-1.6031</span>  <span class="number">1.9077</span>  <span class="number">0.0478</span></div><div class="line"> <span class="number">2.6821</span>  <span class="number">1.0581</span>  <span class="number">0.0966</span> <span class="number">-0.8499</span></div><div class="line"><span class="number">-0.7623</span>  <span class="number">1.3194</span>  <span class="number">1.4320</span> <span class="number">-0.0202</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div><div class="line"></div><div class="line">torch.add(a, <span class="number">10</span>)</div><div class="line">Out[<span class="number">2</span>]: </div><div class="line">  <span class="number">9.4185</span>   <span class="number">8.3969</span>  <span class="number">11.9077</span>  <span class="number">10.0478</span></div><div class="line"> <span class="number">12.6821</span>  <span class="number">11.0581</span>  <span class="number">10.0966</span>   <span class="number">9.1501</span></div><div class="line">  <span class="number">9.2377</span>  <span class="number">11.3194</span>  <span class="number">11.4320</span>   <span class="number">9.9798</span></div><div class="line">[torch.FloatTensor of size <span class="number">3</span>x4]</div></pre></td></tr></table></figure><p>对输入张量<code>input</code>逐元素加上标量值<code>value</code>，并返回结果到一个新的张量<code>out</code>，即 ( out = tensor + value )。如果输入<code>input</code>是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.addcdiv(tensor, value=1, tensor1, tensor2, out=None) → Tensor</div></pre></td></tr></table></figure><p>参数：</p><ul><li>tensor (Tensor) – 张量，对 tensor1 ./ tensor 进行相加</li><li>value (Number, 可选的) –  标量，对 tensor1 ./ tensor2 进行相乘</li><li>tensor1 (Tensor) – 张量，作为被除数(分子)</li><li>tensor2 (Tensor) –张量，作为除数(分母)</li><li>out (Tensor, 可选的) – 输出张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = torch.randn(<span class="number">3</span>, <span class="number">4</span>)</div><div class="line">a1 = torch.randn(<span class="number">2</span>, <span class="number">6</span>)</div><div class="line">a2 = torch.randn(<span class="number">6</span>, <span class="number">2</span>)</div><div class="line">torch.addcdiv(a, <span class="number">0.1</span>, a1, a2)</div></pre></td></tr></table></figure><p>对<code>tensor2</code>对<code>tensor1</code>逐元素相除，然后乘以标量值<code>value</code> 并加到<code>tensor</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.addcmul(tensor, value=1, tensor1, tensor2, out=None) → Tensor</div></pre></td></tr></table></figure><p>用<code>tensor2</code>对<code>tensor1</code>逐元素相乘，并对结果乘以标量值<code>value</code>然后加到<code>tensor</code>。张量的形状不需要匹配，但元素数量必须一致。如果输入是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.ceil(input, out=None) → Tensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">b = torch.randn(<span class="number">4</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"><span class="number">-0.4149</span></div><div class="line"> <span class="number">1.1449</span></div><div class="line"><span class="number">-1.3121</span></div><div class="line"> <span class="number">1.4417</span></div><div class="line">[torch.FloatTensor of size <span class="number">4</span>]</div><div class="line"></div><div class="line">torch.ceil(b)</div><div class="line">Out[<span class="number">20</span>]: </div><div class="line"><span class="number">-0</span></div><div class="line"> <span class="number">2</span></div><div class="line"><span class="number">-1</span></div><div class="line"> <span class="number">2</span></div><div class="line">[torch.FloatTensor of size <span class="number">4</span>]</div></pre></td></tr></table></figure><p>对输入<code>input</code>张量每个元素向上取整, 即取不小于每个元素的最小整数，并返回结果到输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.clamp(input, min, max, out=None) → Tensor</div></pre></td></tr></table></figure><p>操作定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      | min, if x_i &lt; min</div><div class="line">y_i = | x_i, if min &lt;= x_i &lt;= max</div><div class="line">      | max, if x_i &gt; max</div></pre></td></tr></table></figure><p>如果输入是FloatTensor or DoubleTensor类型，则参数<code>min</code> <code>max</code> 必须为实数，否则须为整数。</p><p>参数：</p><ul><li>input (Tensor) –  输入张量</li><li>min (Number) – 限制范围下限</li><li>max (Number) – 限制范围上限</li><li>out (Tensor, 可选的) – 输出张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">b = torch.randn(<span class="number">4</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"><span class="number">-0.4149</span></div><div class="line"> <span class="number">1.1449</span></div><div class="line"><span class="number">-1.3121</span></div><div class="line"> <span class="number">1.4417</span></div><div class="line">[torch.FloatTensor of size <span class="number">4</span>]</div><div class="line"></div><div class="line">torch.clamp(b, <span class="number">-1</span>, <span class="number">1</span>)</div><div class="line">Out[<span class="number">22</span>]: </div><div class="line"><span class="number">-0.4149</span></div><div class="line"> <span class="number">1.0000</span></div><div class="line"><span class="number">-1.0000</span></div><div class="line"> <span class="number">1.0000</span></div><div class="line">[torch.FloatTensor of size <span class="number">4</span>]</div></pre></td></tr></table></figure><p>将输入<code>input</code>张量每个元素的夹紧到区间 ([min, max] )，并返回结果到一个新张量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">torch.floor(input, out=None) → Tensor</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">b = torch.randn(<span class="number">4</span>)</div><div class="line">Out[<span class="number">1</span>]: </div><div class="line"><span class="number">-0.4149</span></div><div class="line"> <span class="number">1.1449</span></div><div class="line"><span class="number">-1.3121</span></div><div class="line"> <span class="number">1.4417</span></div><div class="line">[torch.FloatTensor of size <span class="number">4</span>]</div><div class="line"></div><div class="line">torch.floor(b)</div><div class="line">Out[<span class="number">24</span>]: </div><div class="line"><span class="number">-1</span></div><div class="line"> <span class="number">1</span></div><div class="line"><span class="number">-2</span></div><div class="line"> <span class="number">1</span></div><div class="line">[torch.FloatTensor of size <span class="number">4</span>]</div></pre></td></tr></table></figure><p>床函数: 返回一个新张量，包含输入<code>input</code>张量每个元素的floor，即不小于元素的最大整数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Torch&quot;&gt;&lt;a href=&quot;#Torch&quot; class=&quot;headerlink&quot; title=&quot;Torch&quot;&gt;&lt;/a&gt;Torch&lt;/h3&gt;&lt;p&gt;&lt;code&gt;torch&lt;/code&gt;包含了多维的数据结构以及基于其上的数学运算。它提供了多种实用工具，具有CUDA对应的实现&lt;/p&gt;
&lt;h2 id=&quot;张量-Tensors&quot;&gt;&lt;a href=&quot;#张量-Tensors&quot; class=&quot;headerlink&quot; title=&quot;张量 Tensors&quot;&gt;&lt;/a&gt;张量 Tensors&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;torch.is_tensor(obj)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;a = torch.randn(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;b = np.random.randn(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;torch.is_tensor(a)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Out[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]: &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;torch.is_tensor(b)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Out[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]: &lt;span class=&quot;keyword&quot;&gt;False&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;判断是否为张量，如果是pytorch张量，则返回True&lt;/p&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源，torch" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90%EF%BC%8Ctorch/"/>
    
  </entry>
  
  <entry>
    <title>cache_model</title>
    <link href="http://yoursite.com/2018/01/15/cache-model/"/>
    <id>http://yoursite.com/2018/01/15/cache-model/</id>
    <published>2018-01-15T10:02:44.000Z</published>
    <updated>2018-01-15T10:13:21.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h3><p>我们提出对神经网络语言模型进行的一个扩展，以使其预测适应最近的历史。我们的模型是内存增强网络的简化版本。它将过去隐藏的激活存储为内存，并通过当前隐藏激活的点积访问它们。这种机制非常有效，可以扩展到非常大的内存大小。我们还在神经网络中使用外部存储器和基于计数的语言模型使用缓存模型之间建立了联系。我们在几个语言模型数据集上进行演示，我们的方法比最近的内存扩展网络性能更好。</p><h3 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h3><p>语言模型是单词序列的概率分布，具有许多应用，如machine translation，speech recognition 或dialogue agents。虽然传统的神经网络语言模型已经在这个领域获得了最先进的性能，但是它们缺乏适应其最近历史的能力，这限制了它们在动态环境中的应用。最近的解决这个问题的方法是用external memory来扩充这些网络。这些模型可能会使用外部存储器来存储新的信息并适应不断变化的环境。</p><p>虽然这些网络在语言建模数据集上取得了很好的结果，但它们在计算上相当昂贵。通常，他们必须学习一个可以参数化的机制来读取或写入存储单元。这可能会限制其可用内存的大小以及可以训练的数据量。在这项工作中，我们提出了一个非常轻量级的选择，它可以共享内存扩展网络的一些特性，特别是随着时间的推移动态调整的能力。通过最小化内存的计算负担，我们可以使用更大的内存并扩展到更大的数据集。我们在实践中观察到，这使我们能够在不同的语言建模任务上超越记忆增强网络的性能。</p><a id="more"></a><p>我们的模型与Kuhn提出的模型有一些相似之处，称为缓存模型。缓存模型存储最近过去的简单表示，通常以unigrams和…的形式存储使用它们进行预测。这种上下文信息是非常容易存储并且可以有效地访问。它也不需要任何训练，可以应用在任何模型之上。这使得这个模型对领域适应尤其有意思。</p><p>我们的主要贡献是提出一个缓存模型的连续版本，称为神经缓存模型，它可以适应任何神经网络语言模型。我们存储最近隐藏的激活并将其用作上下文的表示。并和当前的隐藏激活使用简单的点积操作，结果发现获得料非常丰富的预测。我们的模型不需要训练，可以用于任何预先训练的神经网络。它也可以毫不费力地扩展到数千个存储单元。我们演示了几种语言模型任务和LAMBADA数据集的神经缓存模型的质量。</p><h3 id="LANGUAGE-MODELING"><a href="#LANGUAGE-MODELING" class="headerlink" title="LANGUAGE MODELING"></a>LANGUAGE MODELING</h3><p>语言模型是单词序列的概率分布。令词汇表的大小为$V$。每个单词由在$R^V = K$中的one-hot编码向量表示，对应于其在词汇表中的索引。使用链式规则，分配给一系列单词$x_1,…,x_T$的概率可以被分解为:</p><script type="math/tex; mode=display">p(x_1,...,x_T) = P(x1)P(x_2|x_1)P(x_3|x_2, x_1)· · · P(x_T |x_1 . . . x_{T −1})</script><script type="math/tex; mode=display">=\prod_{t-1}^{T}p(x_t|x_{t-1},...,x_1)</script><p>Language modeling通常被定义为在给定历史的情况下在单词上学习条件概率。这个条件概率传统上是用基于计数统计的非参数模型来近似的，特别是平滑的N-gram模型在实践中取得了良好的表现。参数化模型有最大熵语言模型，前馈网络语言模型或循环神经网络语言模型。特别地，循环神经网络是目前近似这个条件概率最好的解决方案，并在标准语言建模基准上 实现了state-of-the-arts的性能。</p><p><strong>Recurrent networks.</strong> 假设我们有一个向量为$h_t \in R^d$对历史单词$x_t,…,x_1$进行编码，则可以将单词w的条件概率参数化为：</p><script type="math/tex; mode=display">p_{vocab}(w|x_t,...,x_1) \propto exp(h_t^To_w)</script><p>历史向量$h_t$通过递归地应用形式的等式由循环神经网络计算</p><script type="math/tex; mode=display">h_t = \Phi(x_t,h_{t-1})</script><p>其中$\Phi$是一个取决于网络架构的函数。已经提出了几种循环神经网络的架构，例如Elman network，LSTM,GRU。Elman network是最简单的循环神经网络之一，其中：</p><script type="math/tex; mode=display">h_t = \sigma(Lx_t+Rh_{t-1})</script><p>其中$\sigma$是非线性的，例如logistic或tanh函数，$L \in R^{d\times V}$是一个word embedding 矩阵，$R \in R^{d\times d}$是隐藏层矩阵。LSTM架构在语言建模方面尤为有趣我们将读者引用Graves到了解这个架构的细节。</p><p>通过最小化训练数据的负对数似然性来学习循环神经网络语言模型的参数。这个目标函数通常通过使用随机梯度下降算法或Adagrad等变体来最小化。使用截断后向传播时间算法计算梯度。</p><p><strong>Cache model.</strong>一个单词在一个文档出现后，它很有可能再次出现。例如，在维基百科页面上单词$tiger$出现相同名字的频率是2.8％，而整个维基百科的频率是0.0037％。Cache model利用这个简单的观察来通过捕获文档中的远程依赖关系来改进n-gram语言模型。更确切地说，这些模型有一个缓存组件，其中包含近期历史中出现的单词（文档或固定数量的单词）。一个简单的语言模型，比如一个unigram或平滑的bigram模型，被放在缓存中的单词上，并用静态语言模型进行插值（在较大的数据集上进行训练）。这种技术有很多优点。首先，这是使语言模型适应新领域的一种非常有效的方法。其次，这样的模型能够预测不在词汇表中的词（OOV词），在看过一次这些词后。最后，这有助于捕获文档中的远程依赖关系，以便生成更加一致的文本。</p><p>　　　　　　　　　　　<img src="/home/miacher/Pictures/datastructure/cache_model.png" alt="cache_model"></p><p>神经缓存模型将先前的隐藏状态存储在存储器单元中。然后将它们用作key来检索它们相应的单词，即下一个单词。在写作和阅读过程中，存储没有任何转换。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ABSTRACT&quot;&gt;&lt;a href=&quot;#ABSTRACT&quot; class=&quot;headerlink&quot; title=&quot;ABSTRACT&quot;&gt;&lt;/a&gt;ABSTRACT&lt;/h3&gt;&lt;p&gt;我们提出对神经网络语言模型进行的一个扩展，以使其预测适应最近的历史。我们的模型是内存增强网络的简化版本。它将过去隐藏的激活存储为内存，并通过当前隐藏激活的点积访问它们。这种机制非常有效，可以扩展到非常大的内存大小。我们还在神经网络中使用外部存储器和基于计数的语言模型使用缓存模型之间建立了联系。我们在几个语言模型数据集上进行演示，我们的方法比最近的内存扩展网络性能更好。&lt;/p&gt;
&lt;h3 id=&quot;INTRODUCTION&quot;&gt;&lt;a href=&quot;#INTRODUCTION&quot; class=&quot;headerlink&quot; title=&quot;INTRODUCTION&quot;&gt;&lt;/a&gt;INTRODUCTION&lt;/h3&gt;&lt;p&gt;语言模型是单词序列的概率分布，具有许多应用，如machine translation，speech recognition 或dialogue agents。虽然传统的神经网络语言模型已经在这个领域获得了最先进的性能，但是它们缺乏适应其最近历史的能力，这限制了它们在动态环境中的应用。最近的解决这个问题的方法是用external memory来扩充这些网络。这些模型可能会使用外部存储器来存储新的信息并适应不断变化的环境。&lt;/p&gt;
&lt;p&gt;虽然这些网络在语言建模数据集上取得了很好的结果，但它们在计算上相当昂贵。通常，他们必须学习一个可以参数化的机制来读取或写入存储单元。这可能会限制其可用内存的大小以及可以训练的数据量。在这项工作中，我们提出了一个非常轻量级的选择，它可以共享内存扩展网络的一些特性，特别是随着时间的推移动态调整的能力。通过最小化内存的计算负担，我们可以使用更大的内存并扩展到更大的数据集。我们在实践中观察到，这使我们能够在不同的语言建模任务上超越记忆增强网络的性能。&lt;/p&gt;
    
    </summary>
    
      <category term="论文" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="论文，cache model" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%EF%BC%8Ccache-model/"/>
    
  </entry>
  
  <entry>
    <title>worldcloud</title>
    <link href="http://yoursite.com/2018/01/13/worldcloud/"/>
    <id>http://yoursite.com/2018/01/13/worldcloud/</id>
    <published>2018-01-13T12:25:37.000Z</published>
    <updated>2018-01-27T06:48:18.060Z</updated>
    
    <content type="html"><![CDATA[<p>　　今天介绍一个python库－－wordcloud，这个库的主要功能是对一个文本中的单词进行统计，并且以词云的方式进行展示，从生成的图片中，我们可以直观的发现哪些单词出现的频率较高，一个很有意思的用途就是统计一个会议中，提交论文的主题是哪些，从而看出当前研究的趋势。</p><h3 id="快速安装词云"><a href="#快速安装词云" class="headerlink" title="快速安装词云"></a>快速安装词云</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install wordcloud</div></pre></td></tr></table></figure><h3 id="快速生成词云"><a href="#快速生成词云" class="headerlink" title="快速生成词云"></a>快速生成词云</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</div><div class="line"></div><div class="line">f = open(<span class="string">u'moment.txt'</span>,<span class="string">'r'</span>).read()</div><div class="line">wordcloud = WordCloud(background_color=<span class="string">"white"</span>,width=<span class="number">1000</span>, height=<span class="number">860</span>, margin=<span class="number">2</span>).generate(f)</div><div class="line"></div><div class="line"><span class="comment"># width,height,margin可以设置图片属性</span></div><div class="line"><span class="comment"># generate 可以对全部文本进行自动分词,但是他对中文支持不好,对中文的分词处理请看我的下一篇文章</span></div><div class="line"><span class="comment">#wordcloud = WordCloud(font_path = r'~\Fonts\simkai.ttf').generate(f)</span></div><div class="line"><span class="comment"># 你可以通过font_path参数来设置字体集</span></div><div class="line"><span class="comment">#background_color参数为设置背景颜色,默认颜色为黑</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">plt.imshow(wordcloud)</div><div class="line">plt.axis(<span class="string">"off"</span>)</div><div class="line">plt.show()</div><div class="line"></div><div class="line">wordcloud.to_file(<span class="string">'test.png'</span>)</div><div class="line"><span class="comment"># 保存图片,但是在第三模块的例子中 图片大小将会按照 mask 保存</span></div></pre></td></tr></table></figure><a id="more"></a><h2 id="利用背景图片生成词云"><a href="#利用背景图片生成词云" class="headerlink" title="利用背景图片生成词云"></a>利用背景图片生成词云</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</div><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud, STOPWORDS, ImageColorGenerator</div><div class="line"></div><div class="line">d = path.dirname(__file__)</div><div class="line"></div><div class="line"><span class="comment"># Read the whole text.</span></div><div class="line">text = open(path.join(d, <span class="string">'moment.txt'</span>)).read()</div><div class="line"></div><div class="line"><span class="comment"># read the mask / color image taken from</span></div><div class="line"><span class="comment"># http://jirkavinse.deviantart.com/art/quot-Real-Life-quot-Alice-282261010</span></div><div class="line">alice_coloring = np.array(Image.open(path.join(d, <span class="string">"alice_color.png"</span>)))</div><div class="line"></div><div class="line"><span class="comment"># 设置停用词</span></div><div class="line">stopwords = set(STOPWORDS)</div><div class="line">stopwords.add(<span class="string">"life"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 你可以通过 mask 参数 来设置词云形状</span></div><div class="line">wc = WordCloud(background_color=<span class="string">"white"</span>, max_words=<span class="number">2000</span>, mask=alice_coloring,</div><div class="line">               stopwords=stopwords, max_font_size=<span class="number">40</span>, random_state=<span class="number">42</span>)</div><div class="line"><span class="comment"># generate word cloud</span></div><div class="line">wc.generate(text)</div><div class="line"></div><div class="line"><span class="comment"># create coloring from image</span></div><div class="line">image_colors = ImageColorGenerator(alice_coloring)</div><div class="line"></div><div class="line"><span class="comment"># show</span></div><div class="line"><span class="comment"># 在只设置mask的情况下,你将会得到一个拥有图片形状的词云</span></div><div class="line">plt.imshow(wc, interpolation=<span class="string">"bilinear"</span>)</div><div class="line">plt.axis(<span class="string">"off"</span>)</div><div class="line">plt.figure()</div><div class="line"><span class="comment"># recolor wordcloud and show</span></div><div class="line"><span class="comment"># we could also give color_func=image_colors directly in the constructor</span></div><div class="line"><span class="comment"># 我们还可以直接在构造函数中直接给颜色</span></div><div class="line"><span class="comment"># 通过这种方式词云将会按照给定的图片颜色布局生成字体颜色策略</span></div><div class="line">plt.imshow(wc.recolor(color_func=image_colors), interpolation=<span class="string">"bilinear"</span>)</div><div class="line">plt.axis(<span class="string">"off"</span>)</div><div class="line">plt.figure()</div><div class="line">plt.imshow(alice_coloring, cmap=plt.cm.gray, interpolation=<span class="string">"bilinear"</span>)</div><div class="line">plt.axis(<span class="string">"off"</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　今天介绍一个python库－－wordcloud，这个库的主要功能是对一个文本中的单词进行统计，并且以词云的方式进行展示，从生成的图片中，我们可以直观的发现哪些单词出现的频率较高，一个很有意思的用途就是统计一个会议中，提交论文的主题是哪些，从而看出当前研究的趋势。&lt;/p&gt;
&lt;h3 id=&quot;快速安装词云&quot;&gt;&lt;a href=&quot;#快速安装词云&quot; class=&quot;headerlink&quot; title=&quot;快速安装词云&quot;&gt;&lt;/a&gt;快速安装词云&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;pip install wordcloud&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;快速生成词云&quot;&gt;&lt;a href=&quot;#快速生成词云&quot; class=&quot;headerlink&quot; title=&quot;快速生成词云&quot;&gt;&lt;/a&gt;快速生成词云&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; wordcloud &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; WordCloud&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;f = open(&lt;span class=&quot;string&quot;&gt;u&#39;moment.txt&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;r&#39;&lt;/span&gt;).read()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;wordcloud = WordCloud(background_color=&lt;span class=&quot;string&quot;&gt;&quot;white&quot;&lt;/span&gt;,width=&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;, height=&lt;span class=&quot;number&quot;&gt;860&lt;/span&gt;, margin=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;).generate(f)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# width,height,margin可以设置图片属性&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# generate 可以对全部文本进行自动分词,但是他对中文支持不好,对中文的分词处理请看我的下一篇文章&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#wordcloud = WordCloud(font_path = r&#39;~\Fonts\simkai.ttf&#39;).generate(f)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 你可以通过font_path参数来设置字体集&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#background_color参数为设置背景颜色,默认颜色为黑&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;plt.imshow(wordcloud)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;plt.axis(&lt;span class=&quot;string&quot;&gt;&quot;off&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;plt.show()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;wordcloud.to_file(&lt;span class=&quot;string&quot;&gt;&#39;test.png&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 保存图片,但是在第三模块的例子中 图片大小将会按照 mask 保存&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源，词云" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90%EF%BC%8C%E8%AF%8D%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Exploring Word Vectors with GloVe</title>
    <link href="http://yoursite.com/2018/01/12/Golve/"/>
    <id>http://yoursite.com/2018/01/12/Golve/</id>
    <published>2018-01-12T11:25:20.000Z</published>
    <updated>2018-01-12T11:28:14.006Z</updated>
    
    <content type="html"><![CDATA[<p>在处理文字时，处理庞大但是稀少的语言是很困难的。即使对于一个晓得语料库，神经网络也需要支持数以千计的离散输入和输出。</p><p>除了原始数字外，将单词表示为one-hot向量的方法无法捕获任何有关单词之间关系的信息。</p><p>Ｗord Vector 通过在多维向量空间中表示单词来解决这个问题。这样就可以将问题的维度数十万减少到数百。而且向量空间能够从距离向量之间的夹角来捕获单词之间的语义关系。</p><p><img src="../img/analogy.png" alt="analogy"></p><p>现已有一些创建Ｗord Vector的技巧。word2vec算法可预测上下文中的单词(例如”the cat”最可能出现的单词是”the mouse”)，而Glove向量则基于整个语料库的全局计数。glove最大的特点就是可以轻松的下载多套预先训练好的词向量。</p><a id="more"></a><h3 id="Loading-word-vectors"><a href="#Loading-word-vectors" class="headerlink" title="Loading word vectors"></a>Loading word vectors</h3><p>Torchtext包括下载GloVe（和其他）嵌入的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch</div><div class="line"><span class="keyword">import</span> torchtext.vocab <span class="keyword">as</span> vocab</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">glove = vocab.GloVe(name=<span class="string">'6B'</span>, dim=<span class="number">100</span>)</div></pre></td></tr></table></figure><blockquote><p>[out]: 98%|█████████▊| 391063/400000 [00:19&lt;00:00, 19964.76it/s]<br>​          98%|█████████▊| 393086/400000 [00:19&lt;00:00, 19965.52it/s]<br>​          99%|█████████▉| 395108/400000 [00:19&lt;00:00, 19966.79it/s]<br>​          99%|█████████▉| 397132/400000 [00:19&lt;00:00, 19968.13it/s]<br>​          100%|█████████▉| 399154/400000 [00:19&lt;00:00, 19968.55it/s]<br>​          100%|██████████| 400000/400000 [00:20&lt;00:00, 19969.45it/s]</p></blockquote><p>返回的GloVe对象包含以下属性：</p><ul><li><code>stoi</code> <em>string-to-index</em> returns a dictionary of words to indexes</li><li><code>itos</code> <em>index-to-string</em> returns an array of words by index</li><li><code>vectors</code> returns the actual vectors. To get a word vector get the index to get the vector</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_word</span><span class="params">(word)</span>:</span></div><div class="line">    <span class="keyword">return</span> glove.vectors[glove.stoi[word]]</div><div class="line"><span class="comment">#get_word('google')  输出size为100的向量</span></div></pre></td></tr></table></figure><h3 id="Finding-closest-vectors"><a href="#Finding-closest-vectors" class="headerlink" title="Finding closest vectors"></a>Finding closest vectors</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">closest</span><span class="params">(vec, n=<span class="number">10</span>)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Find the closest words for a given vector</span></div><div class="line"><span class="string">    """</span></div><div class="line">    all_dists = [(w, torch.dist(vec, get_word(w))) <span class="keyword">for</span> w <span class="keyword">in</span> glove.itos]</div><div class="line">    <span class="keyword">return</span> sorted(all_dists, key=<span class="keyword">lambda</span> t: t[<span class="number">1</span>])[:n]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_tuples</span><span class="params">(tuples)</span>:</span></div><div class="line">    <span class="keyword">for</span> tuple <span class="keyword">in</span> tuples:</div><div class="line">        print(<span class="string">'(%.4f) %s'</span> % (tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]))</div><div class="line">print_tuples(closest(get_word(<span class="string">'google'</span>)))</div></pre></td></tr></table></figure><blockquote><p>[out]: (0.0000) google<br>​           (3.0772) yahoo<br>​           (3.8836) microsoft<br>​           (4.1048) web<br>​           (4.1082) aol<br>​           (4.1165) facebook<br>​           (4.3917) ebay<br>​           (4.4122) msn<br>​           (4.4540) internet<br>​           (4.4651) netscape</p></blockquote><h3 id="Word-analogies-with-vector-arithmetic"><a href="#Word-analogies-with-vector-arithmetic" class="headerlink" title="Word analogies with vector arithmetic"></a>Word analogies with vector arithmetic</h3><p>训练有素的单词向量空间的最有趣的特征是可以用正则向量算法来捕捉某些语义关系（不仅仅是单词的紧密性）。</p><p><img src="../../Pictures/datastructure/anology_ex.png" alt="anology_ex"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># In the form w1 : w2 :: w3 : ?</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">analogy</span><span class="params">(w1, w2, w3, n=<span class="number">5</span>, filter_given=True)</span>:</span></div><div class="line">    print(<span class="string">'\n[%s : %s :: %s : ?]'</span> % (w1, w2, w3))</div><div class="line">   </div><div class="line">    <span class="comment"># w2 - w1 + w3 = w4</span></div><div class="line">    closest_words = closest(get_word(w2) - get_word(w1) + get_word(w3))</div><div class="line">    </div><div class="line">    <span class="comment"># Optionally filter out given words</span></div><div class="line">    <span class="keyword">if</span> filter_given:</div><div class="line">        closest_words = [t <span class="keyword">for</span> t <span class="keyword">in</span> closest_words <span class="keyword">if</span> t[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> [w1, w2, w3]]</div><div class="line">        </div><div class="line">    print_tuples(closest_words[:n])</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">analogy(<span class="string">'king'</span>, <span class="string">'man'</span>, <span class="string">'queen'</span>)</div></pre></td></tr></table></figure><blockquote><p>[out]: [king : man :: queen : ?]<br>​          (4.0811) woman<br>​          (4.6916) girl<br>​          (5.2703) she<br>​          (5.2788) teenager<br>​          (5.3084) boy</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在处理文字时，处理庞大但是稀少的语言是很困难的。即使对于一个晓得语料库，神经网络也需要支持数以千计的离散输入和输出。&lt;/p&gt;
&lt;p&gt;除了原始数字外，将单词表示为one-hot向量的方法无法捕获任何有关单词之间关系的信息。&lt;/p&gt;
&lt;p&gt;Ｗord Vector 通过在多维向量空间中表示单词来解决这个问题。这样就可以将问题的维度数十万减少到数百。而且向量空间能够从距离向量之间的夹角来捕获单词之间的语义关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../img/analogy.png&quot; alt=&quot;analogy&quot;&gt;&lt;/p&gt;
&lt;p&gt;现已有一些创建Ｗord Vector的技巧。word2vec算法可预测上下文中的单词(例如”the cat”最可能出现的单词是”the mouse”)，而Glove向量则基于整个语料库的全局计数。glove最大的特点就是可以轻松的下载多套预先训练好的词向量。&lt;/p&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
      <category term="Glove词向量" scheme="http://yoursite.com/tags/Glove%E8%AF%8D%E5%90%91%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>An Empirical Study of Language CNN for Image Captioning</title>
    <link href="http://yoursite.com/2018/01/10/language-CNN/"/>
    <id>http://yoursite.com/2018/01/10/language-CNN/</id>
    <published>2018-01-10T13:16:39.000Z</published>
    <updated>2018-01-10T13:22:53.769Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>In contrast to previous models which predict next word based on one previous word and hidden state, our language CNN is fed with all the previous words and can model the long-range dependencies in history words, which are critical for image captioning.</p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Image captioning model should be capable of capturing implicit semantic information of an im-age and generating humanlike sentences. Most image captioning models follow the encoder-decoder pipeline.</p><p>Although models like LSTM networks have memory cells which aim to memorize history information for long-term, they are still limited to several time steps because long-term information is gradually diluted at every time step</p><p>To better model the hierarchical structure and long-term dependencies in word sequences we adopt a language CNN which applies temporal convolution to extract features from sequences.</p><p>To summarize, our primary contribution lies in incorporating a language CNN, which is capable of capturing long-range dependencies in sequences, with RNNs for image captioning.</p><a id="more"></a><h3 id="Model-Architecture"><a href="#Model-Architecture" class="headerlink" title="Model Architecture"></a>Model Architecture</h3><h4 id="Overall-Framework"><a href="#Overall-Framework" class="headerlink" title="Overall Framework"></a>Overall Framework</h4><p><img src="../img/language_CNN.png" alt="language_CNN"></p><p>Given an image I, we take the widely-used CNN architecture VGGNet (16-layer)  pre-trained on ImageNet to extract the image features $V \in R^K$ .</p><script type="math/tex; mode=display">V = CNN_L(I)</script><h4 id="CNN-L-Layer"><a href="#CNN-L-Layer" class="headerlink" title="$CNN_L$ Layer"></a>$CNN_L$ Layer</h4><p>The $CNN_L$  is designed to represent words and their hierarchical structure in word sequences. It takes a sequence of t generated words (each word is encoded as a one-hot representation) as inputs and generates a bottom-up representation of these words.</p><p>The first layer of $CNN_L$ is a word embedding layer.Suppose we have t input words$S = ${$ {S^{[0]}, S^{[1]}, … , S^{[t-1]}}$ }, $S^{[i]}$ is the one-of-V( one-hot ) encoding.</p><p>We map each word $S^{[t]}$ in the sentence into a K-dimensional vector $x^{[t]} = W_{e}S^{[t]}$, $W_e \in R^{K \times V}$ is word embedding matrix. Those embedding are concatenated to produce a matrix:</p><script type="math/tex; mode=display">x = [x^{[0]}, x^{[1]}, ... , x^{[t-1]}]^{T}   x \in R^{t \times K}</script><p>We use the temporal convolution to model the sentence. Given an input feature map $y^{(\ell-1)} \in R^{M_{\ell-1}\times K}$of Layer-$\ell$-1,the output feature map $y^{(\ell)} \in R^{M_{\ell}\times K}$of the temporal convolution layer-$\ell$ will be:</p><script type="math/tex; mode=display">y_i^{(l)}(x) = \delta (w_L^{(l)}y_i^{(\ell -1)}+b_L^{\ell})</script><p>here $y_i^{(l)}(x)$ dives the output feature map for location $i$ in Layer-$\ell$ , $w_L^{(l)}$denotes the parameters on  Layer-$\ell$. The input feature map $y_i^{(\ell -1)}$ is the segment of Layer-$\ell$-1 for the convolution at location $i$.</p><p>While $y^{[0]}$ is the concatenation of $t$ word embeddings from the sequence input $S^{[0:t-1]}$.</p><p><img src="../img/sentence_modeling.png" alt="sentence_modeling"></p><p>The output features of the final convolution layer are fed into a fully connected layer that projects the extracted words features into a low-dimensional representation. Next, the projected features will be fed to a highway connection which controls flows of information in the layer and improves the gradient flow. The final output of the highway connection is a K-dimensional vector $y^{[t]}$.</p><h4 id="Multimodal-Fusion-Layer"><a href="#Multimodal-Fusion-Layer" class="headerlink" title="Multimodal Fusion Layer"></a>Multimodal Fusion Layer</h4><script type="math/tex; mode=display">m^{[t]} = f_{multimodal}(y^{[t]},V) = \delta (f_y; W_Y,b_Y)+g_v(V; W_V,b_V)</script><h4 id="Recurrent-Networks"><a href="#Recurrent-Networks" class="headerlink" title="Recurrent Networks"></a>Recurrent Networks</h4><p>RHN has directly gated connections between previous state $r^{[t-1]}$and current input $z^{[t]}$ to modulate the flow of information. The transition equations of RHN can be formulated as follows:</p><p><img src="../img/RHN.png" alt="RHN"></p><p><img src="../img/highway_net.png" alt="highway_net"></p><p>where $c^{[t]}$ is the carry gate, $t^{[t]}$is the transform gate, $h^{[t]}$ denotes the modulated  input, M:$R^{2K+d} \rightarrow R^{3d}$ is an affine trandformation. $z^{[t]} \in R^{[2k]}$ denotes the concatenation of two vectors: $m^{[t]}$ and $x^{[t-1]}$.</p><script type="math/tex; mode=display">z^{[t]} = [f_{multimodal}(CNN_L(x^{[0,...,t-1]}),V);x^{[t-1]}]</script><h4 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h4><p>During training, given the ground truth words S and corresponding image I, the loss function for a single training instance (S, I) is defined as a sum of the negative log likelihood of the words. The loss can be written as:</p><script type="math/tex; mode=display">L(S,I) = - \sum_{T=0}^{N-1}log P(S^{[t]}|S^{[0]},...,S^{[t-1]},I)</script><p>where N is the sequence length, and $S^{[t]}$ denotes a word in the sentence S. The training objective is to minimize the cost function.</p><h3 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h3><h4 id="Datasets-and-Evaluation-Metrics"><a href="#Datasets-and-Evaluation-Metrics" class="headerlink" title="Datasets and Evaluation Metrics"></a>Datasets and Evaluation Metrics</h4><p><strong>BLEU</strong>-n is a precision-based metric. It measures how many words are shared by the generated captions and ground truth captions.</p><p><strong>METEOR</strong> is based on the explicit word to word matches between generated captions and ground-truth captions.</p><p><strong>CIDEr</strong> is a metric developed specifically for evaluating image captions. It measures consensus in image caption by performing a Term Frequency-Inverse Document Frequency weighting for each n-gram.</p><p><strong>SPICE</strong> is a more recent metric which has been shown to correlate better with the human judgment<br>of semantic quality than previous metrics.</p><h4 id="Results-Using-CNN-L-on-MS-COCO-and-Filcker30k"><a href="#Results-Using-CNN-L-on-MS-COCO-and-Filcker30k" class="headerlink" title="Results Using CNN L on MS COCO and Filcker30k"></a>Results Using CNN L on MS COCO and Filcker30k</h4><p><img src="../img/ms_coco.png" alt="ms_coco"></p><p><img src="../img/flicker30k.png" alt="flicker30k"></p><p><img src="../img/MS_coco.png" alt="MS_coco"></p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>In this work, we present an image captioning model with language CNN to explore both hierarchical and temporal information in sequence for image caption generation. Experiments conducted on MS COCO and Flickr30K image captioning datasets validate our proposal and analysis. Performance improvements are clearly observed when compared with other image captioning methods. Future research directions will go towards integrating extra attributes learning into image captioning, and how to apply a single language CNN for image caption generation is worth trying.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;In contrast to previous models which predict next word based on one previous word and hidden state, our language CNN is fed with all the previous words and can model the long-range dependencies in history words, which are critical for image captioning.&lt;/p&gt;
&lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;Image captioning model should be capable of capturing implicit semantic information of an im-age and generating humanlike sentences. Most image captioning models follow the encoder-decoder pipeline.&lt;/p&gt;
&lt;p&gt;Although models like LSTM networks have memory cells which aim to memorize history information for long-term, they are still limited to several time steps because long-term information is gradually diluted at every time step&lt;/p&gt;
&lt;p&gt;To better model the hierarchical structure and long-term dependencies in word sequences we adopt a language CNN which applies temporal convolution to extract features from sequences.&lt;/p&gt;
&lt;p&gt;To summarize, our primary contribution lies in incorporating a language CNN, which is capable of capturing long-range dependencies in sequences, with RNNs for image captioning.&lt;/p&gt;
    
    </summary>
    
      <category term="论文" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="论文，image caption model" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%EF%BC%8Cimage-caption-model/"/>
    
  </entry>
  
  <entry>
    <title>Exploring the Limits of Language Modeling</title>
    <link href="http://yoursite.com/2018/01/09/language-modeling-limit/"/>
    <id>http://yoursite.com/2018/01/09/language-modeling-limit/</id>
    <published>2018-01-09T02:46:00.000Z</published>
    <updated>2018-01-09T02:49:01.917Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h3><p>We extend current models to deal with two key challenges present in this task: corpora and vocabulary sizes, and complex, long term structure of language. We perform an exhaustive study on techniques such as character Convolutional Neural Networks or Long-Short Term Memory, on the One Billion Word Benchmark.</p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Models which can accurately place distributions over sentences not only encode complexities of language such as grammatical structure, but also distill a fair amount of information about the knowledge that a corpora may contain.(提取大量关于语料库可能包含的知识的信息).</p><p>Language Modeling can apply in speech recoginition, machine translation, text summarization etc. (such as word error rate for speech recognition, or BLEU score for translation). </p><p>When trained on vast amounts of data, language models compactly extract knowledge encoded in the training data. For example, when trained on movie subtitles, language models are able to generate basic answers to questions about object colors,  facts about people, etc.</p><a id="more"></a><p>language model such as N-grams, only use a short history of previous words to predict the next word, , they are still a key component to high quality, low perplexity Language Modeling.  RNNs based language model are great in  combination with N-grams.</p><p>The contributions:</p><blockquote><p>Unify some of the current research on larger scale LM</p><p>Designed a Softmax loss which is based on character level CNNs instead of a full softmax</p><p>Reduce the number of parameters </p></blockquote><h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h3><h4 id="Language-Models"><a href="#Language-Models" class="headerlink" title="Language Models"></a>Language Models</h4><p>Much work has been done on both parametric (e.g., log-linear models) and non-parametric approaches (e.g., count-based LMs).</p><p>Count-based approaches(based on statistics of N-grams). For example: unigram, bigram, trigram, 5-gram models. Log-linear approaches(based on recurrent neural network).  For example: RNN-based, LSTM, GRU.</p><p><img src="../img/char_RNN.png" alt="char_RNN"></p><h4 id="Convolution-Embedding-Models"><a href="#Convolution-Embedding-Models" class="headerlink" title="Convolution Embedding Models"></a>Convolution Embedding Models</h4><p>There is an increased interest in incorporating character-level inputs to build word embeddings for various NLP problems, including part-of-speech tagging, parsing and language modeling.</p><p>Several approach building word embedding: </p><blockquote><p><strong>Bidirectional LSTMs </strong>over the characters.<br><strong>The recurrent networks</strong> process sequences of characters from both sides and their final state vectors are concatenated.<br>The words characters are processed by a <strong>1-d CNN</strong> with max-pooling across the sequence for each convolutional feature. <strong>The resulting features are fed to a 2-layer highway network, which allows the embedding to learn semantic representations.</strong></p></blockquote><h4 id="Softmax-Over-Large-Vocabularies"><a href="#Softmax-Over-Large-Vocabularies" class="headerlink" title="Softmax Over Large Vocabularies"></a>Softmax Over Large Vocabularies</h4><p>Assigning probability distributions over large vocabularies is computationally challenging. For modeling language, maximizing log-likelihood of a given word sequence leads to optimizing cross entropy between the target probability distribution, and our model predictions $p$. Generaly, predictions come from a linear layer follows by a Sofemax non-linearity:  $p(w)={\exp(z_w) \over \sum_{w’ \in V} exp(z_{w’})}$,where $z_w$ is the  logit corresponding to a word $w$. The logit is generally computed as an inner product $z_w = h^Te_w$ where $h$ is a context vector and $e_w$ is a “word embedding” for $w$.</p><p>The main challenge when $|V|$ is very large is the fact that computing all inner products between h and all embeddings becomes prohibitively slow during training. Several approaches have been proposed to cope with the scaling issue: <strong>importance sampling , Noise Contrastive Estimation (NCE), self normalizing partition functions, Hierarchical Softmax</strong>.</p><h3 id="Language-Modeling-Improvements"><a href="#Language-Modeling-Improvements" class="headerlink" title="Language Modeling Improvements"></a>Language Modeling Improvements</h3><p>Recurrent Neural Networks based LMs employ the chain rule to model joint probabilities over word sequences:</p><script type="math/tex; mode=display">p(w_1,...,w_N)=\prod_{i=1}^{N}p(w_i|w_{i-1},...,x_1)</script><p>where the context of all previous words is encoded with an LSTM, and the probability over words uses a Softmax.</p><h4 id="Relationship-between-Noise-Contrastive-Estimation-and-Importance-Sampling"><a href="#Relationship-between-Noise-Contrastive-Estimation-and-Importance-Sampling" class="headerlink" title="Relationship between Noise Contrastive Estimation and Importance Sampling"></a>Relationship between Noise Contrastive Estimation and Importance Sampling</h4><p>A large scale Softmax is necessary for training good LMs because of the vocabulary size.  A <strong>Hierarchical Softmax</strong> employs a tree in which the probability distribution over words is decomposed into a product of two probabilities for each word, greatly reducing training and inference time as only the path specified by the hierarchy needs to be computed and updated. Choosing a good hierarchy is important for obtaining good results and we did not explore this approach further for this paper as sampling methods worked well for our setup.</p><p><strong>Sampling approaches</strong> are only useful during training, as they propose an approximation to the loss which is cheap to compute (also in a distributed setting) – however, at inference time one still has to compute the normalization term over all words. Noise Contrastive Estimation (NCE) pro-<br>poses to consider a surrogate binary classification task in which a classifier is trained to discriminate between true data, or samples coming from some arbitrary distribution. If both the noise and data distributions were known, the optimal classifier would be:</p><script type="math/tex; mode=display">p(Y = true|w) = {p_d(w) \over p_d(w)+kp_n(w) }</script><p>where $Y$ is the binary random variable indicating whether w comes from the true data distribution, $k$ is the number of negative samples per positive word, and $p_d$ and $p_n$ are the data and noise distribution respectively (we dropped any dependency on previous words for notational simplicity). It is easy to show that if we train a logistic classifier $p_{\theta}(Y=true|w) = \sigma(s_{\theta}(w,h)-logkp_n(w))$, then, $p’(w)=softmax(s_{\theta}(w,h))$ is good approximation of $p_d(w)$($s_{\theta}$ is a logit which e.g. an LSTM LM computes).</p><p>The other technique, which is based on <strong>importance sampling (IS)</strong>, proposes to directly approximate the partition function (which comprises a sum over all words) with an estimate of it through importance sampling. Though the methods look superficially similar, we will derive a similar surrogate classification task akin to NCE which arrives at IS, showing a strong connection between the two.</p><p>Suppose that, instead of having a binary task to decide if a word comes from the data or from the noise distribution, we want to identify the words coming from the true data distribution in a set</p><p>$W={w_1,…,W_{k+1}}$, comprised of $k$ noise samples and one data distribution sample. we can train a multiclass loss over a multinomial random variable $Y$ which maximizes $logp(Y=1|W)$, assuming w.l.o.g. that $w_1 \in W$ is always the word coming from true data. By Bayes rule, and ignoring terms that are constant with respect to $Y$, we can write:</p><script type="math/tex; mode=display">p(Y=k|W) \propto_{Y}{p_d(w_k) \over p_n(w_k)}</script><p>and, following a similar argument than for NCE, if we define :$p(Y=k|W) = softmax(s_{\theta}(w_k)-logp_n(w_k))$ then $p’(w)=softmax(s_{\theta}(w,h))$. Note that the only difference between NCE and IS is that, in NCE, we define a binary classification task<br>between true or noise words with a logistic loss, whereas in IS we define a multiclass classification problem with a Softmax and cross entropy loss. We hope that our derivation helps clarify the similarities and differences between the two. In particular, we observe that IS, as it optimizes<br>a multiclass classification task (in contrast to solving a binary task), may be a better choice. Indeed, the updates to the logits with IS are tied whereas in NCE they are independent.</p><h4 id="CNN-softmax"><a href="#CNN-softmax" class="headerlink" title="CNN softmax"></a>CNN softmax</h4><p>The character-level features allow for a smoother and compact parametrization of the word embeddings. Recall that the Softmax computers a logit as $z_w=h^Te_w$ where $h$ is a context vector and $e_w$ is a “word embedding” for $w$. Instead of building a matrix of$|V| \times |h|$(whose rows correspond to $e_w$),  we produce $e_w$w with a CNN over the characters of $w$ as$e_w=CNN(chars_w)$– we call this a CNN Softmax. We used the same network architecture to dynamically generate the Softmax word embeddings without sharing the parameters with the input word-embedding sub-network. For inference, the vectors $e_w$ can be precomputed, so there is no computational complexity increase w.r.t. the regular Softmax.</p><p>When using an importance sampling loss only a few logits have non-zero gradient (those corresponding to the true and sampled words). With a Softmax where $e_w$ are independently<br>learned word embeddings, this is not a problem. But we observed that, when using a CNN, all the logits become tied as the function mapping from $w$ to $e_w$ w is quite smooth. As a result, a much smaller learning rate had to be used. Even with this, the model lacks capacity to differentiate<br>between words that have very different meanings but that are spelled similarly. Thus, a reasonable compromise was to add a small correction factor which is learned per word,<br>such that:</p><script type="math/tex; mode=display">z_w=h^TCNN(chars_w)+h^TM_{corr_w}</script><p>where M is a matrix projecting a low-dimensional embedding vector $corr_w$ back up to the dimensionality of the projected LSTM hidden state of h. This amounts to adding a bottleneck linear layer, and brings the CNN Softmax much closer to our best result, where adding a 128-dim correction halves the gap between regular and the CNN Softmax.</p><p>Aside from a big reduction in the number of parameters and incorporating morphological knowledge from words, the other benefit of this approach is that out-of-vocabulary (OOV) words can easily be scored. This may be useful for other problems such as Machine Translation where handling out-of-vocabulary words is very important . This approach also allows parallel training<br>over various data sets since the model is no longer explicitly parametrized by the vocabulary size – or the language. </p><h4 id="Char-LSTM-Predictions"><a href="#Char-LSTM-Predictions" class="headerlink" title="Char LSTM Predictions"></a>Char LSTM Predictions</h4><p>The CNN Softmax layer can handle arbitrary words and is much more efficient in terms of number of parameters than the full Softmax matrix. It is, though, still considerably slow, as to evaluate perplexities we need to compute the partition function. A class of models that solve this prob-<br>lem more efficiently are character-level LSTMs. They make predictions one character at a time, thus allowing to compute probabilities over a much smaller vocabulary. On the other hand,<br>these models are more difficult to train and seem to perform worse even in small tasks like PTB Most likely this is due to the sequences becoming much longer on average as the LSTM reads the input character by character instead of word by word. </p><p>Thus, we combine the word and character-level models by feeding a word-level LSTM hidden state h into a small LSTM that predicts the target word one character at a time. In order to make the whole process reasonably efficient, we train the standard LSTM model until convergence, freeze its weights, and replace the standard word-level Softmax layer with the aforementioned character-level LSTM.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ABSTRACT&quot;&gt;&lt;a href=&quot;#ABSTRACT&quot; class=&quot;headerlink&quot; title=&quot;ABSTRACT&quot;&gt;&lt;/a&gt;ABSTRACT&lt;/h3&gt;&lt;p&gt;We extend current models to deal with two key challenges present in this task: corpora and vocabulary sizes, and complex, long term structure of language. We perform an exhaustive study on techniques such as character Convolutional Neural Networks or Long-Short Term Memory, on the One Billion Word Benchmark.&lt;/p&gt;
&lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;Models which can accurately place distributions over sentences not only encode complexities of language such as grammatical structure, but also distill a fair amount of information about the knowledge that a corpora may contain.(提取大量关于语料库可能包含的知识的信息).&lt;/p&gt;
&lt;p&gt;Language Modeling can apply in speech recoginition, machine translation, text summarization etc. (such as word error rate for speech recognition, or BLEU score for translation). &lt;/p&gt;
&lt;p&gt;When trained on vast amounts of data, language models compactly extract knowledge encoded in the training data. For example, when trained on movie subtitles, language models are able to generate basic answers to questions about object colors,  facts about people, etc.&lt;/p&gt;
    
    </summary>
    
      <category term="论文" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="论文，语言模型待解决问题" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%EF%BC%8C%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%BE%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>语言模型数据处理</title>
    <link href="http://yoursite.com/2018/01/04/language-model-data/"/>
    <id>http://yoursite.com/2018/01/04/language-model-data/</id>
    <published>2018-01-04T07:25:32.000Z</published>
    <updated>2018-01-04T08:25:57.020Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">data = [(<span class="string">"me gusta comer en la cafeteria"</span>.split(), <span class="string">"SPANISH"</span>),</div><div class="line">        (<span class="string">"Give it to me"</span>.split(), <span class="string">"ENGLISH"</span>),</div><div class="line">        (<span class="string">"No creo que sea una buena idea"</span>.split(), <span class="string">"SPANISH"</span>),</div><div class="line">        (<span class="string">"No it is not a good idea to get lost at sea"</span>.split(), <span class="string">"ENGLISH"</span>)]</div></pre></td></tr></table></figure><blockquote><p>out[]</p><p>[([‘me’, ‘gusta’, ‘comer’, ‘en’, ‘la’, ‘cafeteria’], ‘SPANISH’),<br> ([‘Give’, ‘it’, ‘to’, ‘me’], ‘ENGLISH’),<br> ([‘No’, ‘creo’, ‘que’, ‘sea’, ‘una’, ‘buena’, ‘idea’], ‘SPANISH’),<br> ([‘No’,  ‘it’,   ‘is’,   ‘not’,   ‘a’,   ‘good’,   ‘idea’,   ‘to’,   ‘get’,   ‘lost’,   ‘at’,   ‘sea’],  ‘ENGLISH’)]</p></blockquote><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">word_to_ix = &#123;&#125;</div><div class="line"><span class="keyword">for</span> sent, _ <span class="keyword">in</span> data + test_data:</div><div class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> sent:</div><div class="line">        <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> word_to_ix:</div><div class="line">            word_to_ix[word] = len(word_to_ix)</div><div class="line">print(word_to_ix)</div><div class="line"><span class="keyword">print</span> (word)</div></pre></td></tr></table></figure><blockquote><p>out[] sent</p><p>[‘me’, ‘gusta’, ‘comer’, ‘en’, ‘la’, ‘cafeteria’]<br>[‘Give’, ‘it’, ‘to’, ‘me’]<br>[‘No’, ‘creo’, ‘que’, ‘sea’, ‘una’, ‘buena’, ‘idea’]<br>[‘No’, ‘it’, ‘is’, ‘not’, ‘a’, ‘good’, ‘idea’, ‘to’, ‘get’, ‘lost’, ‘at’, ‘sea’]</p><p>out[] word </p><p>me<br>gusta<br>comer<br>en<br>la<br>cafeteria<br>Give</p><p>……</p><p> out[] word_to_ix</p><p>{‘en’: 3, ‘No’: 9, ‘buena’: 14, ‘it’: 7, ‘at’: 22, ‘sea’: 12, ‘cafeteria’: 5, ‘la’: 4, ‘to’: 8, ‘creo’: 10, ‘is’: 16, ‘a’: 18, ‘good’: 19, ‘get’: 20, ‘idea’: 15, ‘que’: 11, ‘not’: 17, ‘me’: 0, ‘gusta’: 1, ‘lost’: 21, ‘Give’: 6, ‘una’: 13, ‘comer’: 2}</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> torch</div><div class="line"></div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dictionary</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.word2idx = &#123;&#125;</div><div class="line">        self.idx2word = []</div><div class="line">        self.counter = Counter()</div><div class="line">        self.total = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_word</span><span class="params">(self, word)</span>:</span></div><div class="line">        <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> self.word2idx:</div><div class="line">            self.idx2word.append(word)</div><div class="line">            self.word2idx[word] = len(self.idx2word) - <span class="number">1</span></div><div class="line">        token_id = self.word2idx[word]</div><div class="line">        self.counter[token_id] += <span class="number">1</span></div><div class="line">        self.total += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> self.word2idx[word]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> len(self.idx2word)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Corpus</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, path)</span>:</span></div><div class="line">        self.dictionary = Dictionary()</div><div class="line">        self.train = self.tokenize(os.path.join(path, <span class="string">'train.txt'</span>))</div><div class="line">        self.valid = self.tokenize(os.path.join(path, <span class="string">'valid.txt'</span>))</div><div class="line">        self.test = self.tokenize(os.path.join(path, <span class="string">'test.txt'</span>))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tokenize</span><span class="params">(self, path)</span>:</span></div><div class="line">        <span class="string">"""Tokenizes a text file."""</span></div><div class="line">        <span class="keyword">assert</span> os.path.exists(path)</div><div class="line">        <span class="comment"># Add words to the dictionary</span></div><div class="line">        <span class="keyword">with</span> open(path, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">            tokens = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">                words = line.split() + [<span class="string">'&lt;eos&gt;'</span>]</div><div class="line">                tokens += len(words)</div><div class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> words:</div><div class="line">                    self.dictionary.add_word(word)</div><div class="line"></div><div class="line">        <span class="comment"># Tokenize file content</span></div><div class="line">        <span class="keyword">with</span> open(path, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">            ids = torch.LongTensor(tokens)</div><div class="line">            token = <span class="number">0</span></div><div class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">                words = line.split() + [<span class="string">'&lt;eos&gt;'</span>]</div><div class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> words:</div><div class="line">                    ids[token] = self.dictionary.word2idx[word]</div><div class="line">                    token += <span class="number">1</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> ids</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;data = [(&lt;span class=&quot;string&quot;&gt;&quot;me gusta comer en la cafeteria&quot;&lt;/span&gt;.split(), &lt;span class=&quot;string&quot;&gt;&quot;SPANISH&quot;&lt;/span&gt;),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        (&lt;span class=&quot;string&quot;&gt;&quot;Give it to me&quot;&lt;/span&gt;.split(), &lt;span class=&quot;string&quot;&gt;&quot;ENGLISH&quot;&lt;/span&gt;),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        (&lt;span class=&quot;string&quot;&gt;&quot;No creo que sea una buena idea&quot;&lt;/span&gt;.split(), &lt;span class=&quot;string&quot;&gt;&quot;SPANISH&quot;&lt;/span&gt;),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        (&lt;span class=&quot;string&quot;&gt;&quot;No it is not a good idea to get lost at sea&quot;&lt;/span&gt;.split(), &lt;span class=&quot;string&quot;&gt;&quot;ENGLISH&quot;&lt;/span&gt;)]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;out[]&lt;/p&gt;
&lt;p&gt;[([‘me’, ‘gusta’, ‘comer’, ‘en’, ‘la’, ‘cafeteria’], ‘SPANISH’),&lt;br&gt; ([‘Give’, ‘it’, ‘to’, ‘me’], ‘ENGLISH’),&lt;br&gt; ([‘No’, ‘creo’, ‘que’, ‘sea’, ‘una’, ‘buena’, ‘idea’], ‘SPANISH’),&lt;br&gt; ([‘No’,  ‘it’,   ‘is’,   ‘not’,   ‘a’,   ‘good’,   ‘idea’,   ‘to’,   ‘get’,   ‘lost’,   ‘at’,   ‘sea’],  ‘ENGLISH’)]&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源，语言模型" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90%EF%BC%8C%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>前向神经网络</title>
    <link href="http://yoursite.com/2018/01/03/Forward%20Neural%20Network/"/>
    <id>http://yoursite.com/2018/01/03/Forward Neural Network/</id>
    <published>2018-01-03T14:22:21.599Z</published>
    <updated>2018-01-03T14:22:21.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深度学习应用于自然语言处理-前向神经网络"><a href="#深度学习应用于自然语言处理-前向神经网络" class="headerlink" title="深度学习应用于自然语言处理-前向神经网络"></a>深度学习应用于自然语言处理-前向神经网络</h2><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>深度学习的浪潮袭来，现已在各个领域中应用。深度学习的表现令人叹为观止，不得不说我们迎来了依靠深度学习的人工智能学习时代。</p><blockquote><p>　人工智能，让世界更美好。</p></blockquote><p>这一章主要是通过学习 <a href="http://cs224d.stanford.edu/" target="_blank" rel="external">Stanford cs224d</a> 课程已经阅读一些有些的博客所作出的总结。</p><a id="more"></a><h2 id="本章介绍"><a href="#本章介绍" class="headerlink" title="本章介绍"></a>本章介绍</h2><p>从数学的角度对前向神经网络数学模型进行介绍、推导和证明。</p><h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><p><a href="http://cs229.stanford.edu/section/cs229-linalg.pdf" target="_blank" rel="external">线性代数(Linear Algebra)</a><br><a href="http://cs229.stanford.edu/section/cs229-prob.pdf" target="_blank" rel="external">概率论(Probability Theory)</a><br><a href="http://cs229.stanford.edu/section/cs229-cvxopt.pdf" target="_blank" rel="external">凸优化(Convex Optimization)</a></p><h2 id="前向神经网络"><a href="#前向神经网络" class="headerlink" title="前向神经网络"></a>前向神经网络</h2><p>所谓神经网络就是将许多个单一“神经元”联结在一起，这样，一个“神经元”的输出就可以是另一个“神经元”的输入。以下是一个简单的<strong>三层前向全连接神经网络：</strong></p><p><img src="http://oddpnmpll.bkt.clouddn.com/2016-10-18-14%3A47%3A20.jpg" alt="neural networks"></p><p>图中<strong>x</strong>为输入层，<strong>h</strong>为隐藏层，$\hat{y}$为输出层。在全连接网络中，上一层和下一层的每个神经元都相连。隐藏层在接收到输入x后会进行一个非线性变化，再将输出信号传递给下一层。非线性变换由激活函数(activation function)实现。在数学上，我们可以用矩阵乘法（Matrix multiplication）来解释:</p><script type="math/tex; mode=display">\begin{align*}\boldsymbol{h} &= \text{sigmoid}(\boldsymbol{xW}_1+\boldsymbol{b}_1)\\\boldsymbol{\hat{y}} &= \text{softmax}(\boldsymbol{hW}_2+\boldsymbol{b}_2)\\\end{align*}</script><p>式中<strong>sigmoid</strong>和<strong>softmax</strong>都是一个激活函数,<strong>W</strong>是指两层之间的权重，<strong>b</strong>是偏置量。我们可以看到<strong>x</strong>进行了线性变换后，再做非线性变换，<strong>x</strong>输出的信号将作为<strong>b</strong>的输入。</p><h3 id="激活函数-Activation-fuction"><a href="#激活函数-Activation-fuction" class="headerlink" title="激活函数(Activation fuction)"></a>激活函数(Activation fuction)</h3><p>激活函数的作用是能够给神经网络加入一些非线性因素，使得神经网络可以更好地解决较为复杂的问题。激活函数的缺点是如果模型比较复杂，面对样本数不大的情况时容易出现<a href="http://blog.csdn.net/artprog/article/details/51278643" target="_blank" rel="external"><strong>过拟合</strong></a>。常用的激活函数还有<strong>tanh函数</strong>，<strong>RelU函数</strong>等等。</p><p><strong>sigmoid</strong>函数的数学形式：</p><script type="math/tex; mode=display">\sigma(x) = \dfrac{1}{1+e^{-x}}</script><p><strong>sigmoid</strong>函数求导：</p><script type="math/tex; mode=display">\sigma '(x)= \dfrac{e^{-x}}{(1+e^{-x})^2}=(1-\sigma)\sigma</script><p><strong>sigmoid</strong>函数和导数python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></div><div class="line">  x = <span class="number">1.</span>/(<span class="number">1</span>+np.exp(-x))</div><div class="line">  <span class="keyword">return</span> x</div><div class="line"><span class="comment"># grad</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_grad</span><span class="params">(f)</span>:</span></div><div class="line">  f = f*(<span class="number">1</span>-f)</div><div class="line">  <span class="keyword">return</span> f</div></pre></td></tr></table></figure><p><strong>softmax</strong>函数的数学形式：</p><script type="math/tex; mode=display">\text{softmax}(z_i) = \dfrac{e^{z_i}}{\sum_{j=1}^{c} e^{z_j}}      \quad 假设a_i=\text{softmax}(z_i)</script><p><strong>softmax</strong>函数求导：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial a_i}{\partial z_i}&=-\dfrac{e^{z_i}(\sum_{j} e^{z_j})-e^{z_i}e^{z_i}}{(\sum_{j} e^{z_j})^2}\\&=-\dfrac{e^{z_i}}{\sum_{j} e^{z_j}}+(\dfrac{e^{z_i}}{\sum_{j} e^{z_j}})^2\\&= a_i(1-a_i)\end{align*}</script><p><strong>softmax函数</strong>的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy</div><div class="line"><span class="comment"># 输出softmax函数值，输入向量或矩阵x</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(x.shape)&gt;<span class="number">1</span>:</div><div class="line">        max = np.max(x,axis=<span class="number">1</span>)[:,np.newaxis]</div><div class="line">        x -= max</div><div class="line">        x = np.exp(x)</div><div class="line">        softmax_deno = np.sum(x, axis=<span class="number">1</span>)[:,np.newaxis]</div><div class="line">        x = x/softmax_deno</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        max = np.max(x)</div><div class="line">        x -= max</div><div class="line">        x = np.exp(x)</div><div class="line">        softmax_deno = np.sum(x)</div><div class="line">        x = x/softmax_deno</div><div class="line">    <span class="keyword">return</span> x</div></pre></td></tr></table></figure><h3 id="目标函数-Objective-fuction"><a href="#目标函数-Objective-fuction" class="headerlink" title="　目标函数(Objective fuction)"></a>　目标函数(Objective fuction)</h3><p>目标函数，有时候又称<strong>损失函数（loss function），代价函数（cost function ）</strong>，是网络中的性能参数，也是编译一个模型必须的两个参数之一。在训练模型时，我们的最终目标就是最大化或者最小化目标函数，用$J$表示目标函数。</p><script type="math/tex; mode=display">\arg\min_{\theta}\ J</script><h4 id="交叉熵-Cross-entropy"><a href="#交叉熵-Cross-entropy" class="headerlink" title="交叉熵(Cross entropy)"></a>交叉熵(Cross entropy)</h4><p>一种常见的目标函数形式：</p><script type="math/tex; mode=display">J = -\sum_{i}y_i\log{\hat{y}_i}</script><p>其中$i$代表响应的类别，$y_i$是训练样本中的标签，而$\hat{y}_i$模型预测结果。</p><p>一般情况下，我们对$y_i$使用<strong>one-hot</strong>编码，而$\hat{y}$代表了对应类别的概率$p(y_i|w,x)$，因此，$\sum_i\hat{y_i}=1$,在这里我们称$y_i$为预测函数。</p><p>*对$\hat{y}$求导：    </p><script type="math/tex; mode=display">\dfrac{\partial{J}}{\partial{\hat{y}_i}}=-\dfrac{y_i}{\hat{y}_i}</script><p>对向量$\hat{\boldsymbol{y}}=(\hat{y}_1,\ \dots\ ,\hat{y}_c)$求导：</p><script type="math/tex; mode=display">\dfrac{\partial{J}}{\partial\hat{\boldsymbol{y}}}=(-\dfrac{y_1}{\hat{y}_1},\ \dots\ ,-\dfrac{y_c}{\hat{y}_c})</script><h3 id="预测函数-Predict-function"><a href="#预测函数-Predict-function" class="headerlink" title="　预测函数(Predict function)"></a>　预测函数(Predict function)</h3><p>对于预测函数$\hat{y}_i$,我们取$\hat{y}_i$最大的$i$作为模型最终预测的类别。使用softmax函数对输出层的输入进行归一化操作，数学表示为：</p><script type="math/tex; mode=display">\hat{y_i}=p(y_i|w,x)=\dfrac{e^{z_i}}{\sum_{j=1}^{c} e^{z_j}}</script><p>其中$c$表示类别个数，在这里即是输出层的神经元个数。$z_i$为输出层的输入。</p><p>根据softmax函数的求导可知，预测函数$\hat{y}_i$对$z_i$求导：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial \hat{y_i}}{\partial z_i} &= -\hat{y_i}(1-\hat{y_i})\\\dfrac{\partial \hat{y_k}}{\partial z_i} &= -\hat{y_k}\hat{y_i}\end{align*}</script><p>根据链式法则，目标函数$J$对$z_i$求导：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial J}{\partial z_i} &=\dfrac{\partial J}{\partial \hat{y_1}} \dfrac{\partial \hat{y_1}}{\partial z_i}+\dots+ \dfrac{\partial J}{\partial \hat{y_c}} \dfrac{\partial \hat{y_c}}{\partial z_i}\\&= y_1\hat{y_i}+\dots+y_i(\hat{y_i}-1)+\dots+y_c\hat{y_i}\\&=\hat{y}_i\sum_{j=1}^cy_c-y_i\\&=\hat{y}_i-y_i\end{align*}</script><p>目标函数$J$对向量$z$求导：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial J}{\partial \boldsymbol{z}} = {\boldsymbol{y}}-{\hat{\boldsymbol{y}}}\end{align*}</script><h3 id="前向传播-Forward-propagation"><a href="#前向传播-Forward-propagation" class="headerlink" title="前向传播(Forward propagation)"></a>前向传播(Forward propagation)</h3><p><strong>前向传播是求目标函数值的过程</strong>，从输入层开始，样本的特征向量$x$遍历模型，到达输出层$\hat{y}$，再将$\hat{y}$和  $y$进行比较，得到目标函数值$J$： </p><script type="math/tex; mode=display">\begin{align*}\boldsymbol{h} &= sigmoid(\boldsymbol{xW}_1+\boldsymbol{b}_1)\\\boldsymbol{\hat{y}} &= sigmoid(\boldsymbol{hW}_2+\boldsymbol{b}_2)\\J &= -\sum_{i}y_i\log{\hat{y}_i}\end{align*}</script><p>训练模型的过程就是优化目标函数的过程，我们需要最小化$J=J(\boldsymbol{W}_1,\boldsymbol{b}_1,\boldsymbol{W}_2,\boldsymbol{b_2})$,这歌优化过程我们可以使用<a href="http://www.cnblogs.com/pinard/p/5970503.html" target="_blank" rel="external">梯度下降法</a>,但是由于$J$是一个非凸函数，因此不能使用梯度下降法求得全局最优，也就是不能获得的$J$最小值。</p><h3 id="随机梯度下降-Stochastic-gradient-descent"><a href="#随机梯度下降-Stochastic-gradient-descent" class="headerlink" title="随机梯度下降(Stochastic gradient descent)"></a>随机梯度下降(Stochastic gradient descent)</h3><p>我们可以求目标函数的梯度，它代表目标函数变化增加最快的地方。相反，沿着梯度相反的方向，梯度减少最快，所以我们可以使用迭代的方法更新参数，使得目标函数往着最优的方向进行优化，找到目标函数的最小值：</p><script type="math/tex; mode=display">\boldsymbol{g}^{(t)} = \dfrac{\partial{J}}{\partial{\boldsymbol{W}^{(t)}}}\\\boldsymbol{W}^{(t+1)} =\boldsymbol{W}^{(t)}+ \alpha\boldsymbol{g}^{(t)}</script><p>$t$表示第$t$次进行迭代更新，$\alpha$表示学习率，代表着每一次迭代要走的步长，$Ｗ$表示我们需要更新的参数，在本例子中，我们需要对$W_1$,$b_2$,$W_2$,$b_2$进行参数更新，每次迭代都需要进行梯度的计算，每次迭代都要计算目标函数的值。</p><p>假设训练样本数量为$N$，如果每次迭代都使用所有的训练样本。这时的目标函数是：</p><script type="math/tex; mode=display">\mathbb{J}=\mathbb{E}(J)=\dfrac{1}{N}\sum_nJ_n</script><p>当$N$很大的时候，每次迭代都十分耗时，因此收敛的速度会较慢。我们可以使用一种逼近方法，称为<strong>mini-batch</strong>。</p><ul><li><strong>mini-batch</strong>很简单，就是每次迭代更新只使用$k$个训练样本，$k$可以是100这种相对较小的数。</li><li>而<strong>随机梯度下降(SGD)</strong>是每次更新迭代只使用$1$个训练样本，即$k=1$。<strong>SGD</strong>是<strong>mini-batch</strong>的特殊情况，但是我们一般说<strong>SGD</strong>就是指<strong>mini-batch</strong>。</li></ul><h3 id="后向传播-Backward-propagation"><a href="#后向传播-Backward-propagation" class="headerlink" title="后向传播(Backward propagation)"></a>后向传播(Backward propagation)</h3><p><strong>后向传播就是一个求梯度的过程</strong>从输出层开始往输入层传入误差。</p><p>我们将三层全连接神经网络模型的前向传播表示为：</p><script type="math/tex; mode=display">\begin{align*}&\boldsymbol{z}_1 = \boldsymbol{xW_1}+\boldsymbol{b}_1\\&\boldsymbol{h} = {\text sigmoid}(\boldsymbol{z}_1)\\&\boldsymbol{z}_2 = \boldsymbol{xW_2}+\boldsymbol{b}_2\\&\hat{\boldsymbol{y}} = softmax(\boldsymbol{z}_2)\\&J = -\sum_{i}y_i\log{\hat{y}_i}\end{align*}</script><p>计算后向传播：</p><script type="math/tex; mode=display">\begin{align*}&\boldsymbol{\delta}_1 = \dfrac{\partial J}{\partial \boldsymbol{z}_2} = \hat{\boldsymbol{y}}-\boldsymbol{y}\\&\boldsymbol{\delta}_2 = \dfrac{\partial J}{\partial \boldsymbol{h}} = \boldsymbol{\delta}_1\dfrac{\partial \boldsymbol{z}_2}{\partial \boldsymbol{h}} =\boldsymbol{\delta}_1\boldsymbol{W}^T_2 \\&\boldsymbol{\delta}_3 = \dfrac{\partial J}{\partial \boldsymbol{z}_1} = \boldsymbol{\delta}_2\dfrac{\partial \boldsymbol{h}}{\partial \boldsymbol{z}_1} =\boldsymbol{\delta}_2*\sigma'(\boldsymbol{z}_1) \\&\boldsymbol{\delta}_4 = \dfrac{\partial J}{\partial \boldsymbol{x}} = \boldsymbol{\delta}_3\dfrac{\partial \boldsymbol{z}_1}{\partial \boldsymbol{x}} =\boldsymbol{\delta}_3\boldsymbol{W}^T_1 \\\end{align*}</script><p>$\boldsymbol{\delta}_1$就是预测误差，得到上面传播的误差，我们对每一层的参数求梯度：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial J}{\partial \boldsymbol{W}_2}&= \boldsymbol{\delta}_1 \dfrac{\partial\boldsymbol{z}_2 }{\partial \boldsymbol{W}_2} = \boldsymbol{h}^T\boldsymbol{\delta}_1\\\dfrac{\partial J}{\partial \boldsymbol{b}_2} &= \boldsymbol{\delta}_1 \dfrac{\partial\boldsymbol{z}_2 }{\partial \boldsymbol{b}_2} = \boldsymbol{\delta}_1\\\dfrac{\partial J}{\partial \boldsymbol{W}_1} &= \boldsymbol{\delta}_3 \dfrac{\partial\boldsymbol{z}_1 }{\partial \boldsymbol{W}_1} = \boldsymbol{x}^T\boldsymbol{\delta}_3\\\dfrac{\partial J}{\partial \boldsymbol{b}_1} &= \boldsymbol{\delta}_3 \dfrac{\partial\boldsymbol{z}_1 }{\partial \boldsymbol{b}_1} = \boldsymbol{\delta}_3\\\end{align*}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;深度学习应用于自然语言处理-前向神经网络&quot;&gt;&lt;a href=&quot;#深度学习应用于自然语言处理-前向神经网络&quot; class=&quot;headerlink&quot; title=&quot;深度学习应用于自然语言处理-前向神经网络&quot;&gt;&lt;/a&gt;深度学习应用于自然语言处理-前向神经网络&lt;/h2&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;深度学习的浪潮袭来，现已在各个领域中应用。深度学习的表现令人叹为观止，不得不说我们迎来了依靠深度学习的人工智能学习时代。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;　人工智能，让世界更美好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一章主要是通过学习 &lt;a href=&quot;http://cs224d.stanford.edu/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stanford cs224d&lt;/a&gt; 课程已经阅读一些有些的博客所作出的总结。&lt;/p&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="http://yoursite.com/2018/01/03/stack/"/>
    <id>http://yoursite.com/2018/01/03/stack/</id>
    <published>2018-01-03T13:30:09.000Z</published>
    <updated>2018-01-03T14:15:58.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈(stack)　限定仅在表尾进行插入或删除操作的线性表。</p><p>表尾端称为<strong>栈顶(top)</strong>，表头端称为<strong>栈底(bottom)</strong>。</p><p><img src="../img/stackfeature.png" alt="stackfeature"></p><p><strong>后进先出</strong>的线性表。栈的抽象数据类型定义：</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ADT Stack&#123;</div><div class="line">  数据对象： D = &#123;ai|ai belong to ElemSet,i=<span class="number">1</span>,<span class="number">2</span>,....,n, n&gt;=<span class="number">0</span>&#125;</div><div class="line">  数据关系： R1 = &#123;&lt;ai<span class="number">-1</span>,ai&gt;|ai<span class="number">-1</span>,ai belong to D,i=<span class="number">1</span>,<span class="number">2</span>,....,n&#125;</div><div class="line">      InitStack(&amp;S)</div><div class="line">      <span class="comment">// 构造一个空栈Ｓ。</span></div><div class="line">      DestoryStack(&amp;S)</div><div class="line">      <span class="comment">// 销毁栈Ｓ。</span></div><div class="line">      ClearStack(&amp;S)</div><div class="line">      <span class="comment">//将S清为空栈。</span></div><div class="line">      StackEmpty(S)</div><div class="line">      <span class="comment">// 若栈Ｓ为空栈，则返回true,否则False。</span></div><div class="line">      StackLength(S)</div><div class="line">      <span class="comment">//返回S的元素个数，即栈的长度。</span></div><div class="line">      GetTop(S,&amp;e)</div><div class="line">      <span class="comment">//用e返回S的栈顶元素。</span></div><div class="line">      Push(&amp;S,e)</div><div class="line">      <span class="comment">//插入元素e为新的栈顶元素。</span></div><div class="line">      Pop(&amp;S,&amp;e)</div><div class="line">      <span class="comment">//删除S的栈顶元素，并用e返回其值。</span></div><div class="line"> </div><div class="line">&#125;ADT Stack</div></pre></td></tr></table></figure><p>顺序栈定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">  SElemType    *base;</div><div class="line">  SElemType    *top;</div><div class="line">  <span class="keyword">int</span>          stacksize;</div><div class="line">&#125;SqStack</div></pre></td></tr></table></figure><p>设定两个常量：<strong>STACK_INIT_SIZE</strong>(存储空间初始分配量) 和<strong>STACKINCREMENT</strong>（存储空间分配增量)</p><p><strong>top</strong>:栈顶指针，初始值指向栈底，<strong>base</strong>:栈底指针，初始值指向栈底顶，<strong>stacksize</strong>:栈当前可用容量</p><p>顺序栈模块说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE  100;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT   10;</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">  SElemType    *base;</div><div class="line">  SElemType    *top;</div><div class="line">  <span class="keyword">int</span>          stacksize;</div><div class="line">&#125;SqStack;</div><div class="line"><span class="comment">//－－－－－基本操作的函数原型说明－－－－－</span></div><div class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">DestoryStack</span><span class="params">(SqStack &amp;S)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Status  <span class="title">ClearStack</span><span class="params">(SqStack &amp;S)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">StackLength</span><span class="params">(SqStack S)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S,SElemType &amp;e)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span>;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//－－－－－基本操作的算法描述－－－－－</span></div><div class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</div><div class="line">  S.base = (SElemType *)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="keyword">sizeof</span>(SElemType))</div><div class="line">  <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span> (OVERFLOW);  <span class="comment">//存储分配失败</span></div><div class="line">  S.top = S.base;</div><div class="line">  S.stacksize = STACK_INIT_SIZE;</div><div class="line">  <span class="keyword">return</span> Ok;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack S,SElemType &amp;e)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(S.top == S.base) <span class="keyword">return</span> ERROR;</div><div class="line">  e = *(S.top<span class="number">-1</span>);</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize)&#123;</div><div class="line">    S.base = (SElemType *)<span class="built_in">realloc</span> (S.base,(S.stacksize+STACKINCREMENT)*<span class="keyword">sizeof</span>(SElemType));</div><div class="line">    <span class="keyword">if</span>(!S.base) <span class="built_in">exit</span> (OVERFLOW);</div><div class="line">    S.top = S.base+S.stacksize;</div><div class="line">    S.stacksize+= STACKINCREMENT;</div><div class="line">  &#125;</div><div class="line">  *S.top ++ = e;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType &amp;e)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(S.top == S.base) <span class="keyword">return</span> ERROR;</div><div class="line">  e = *--S.top;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="栈的应用举例"><a href="#栈的应用举例" class="headerlink" title="栈的应用举例"></a>栈的应用举例</h3><p>迷宫求解（从入口到出口的路径算法）</p><p><img src="../img/migong.png" alt="migong"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">  <span class="keyword">int</span>       ord;       <span class="comment">//通道块在路径上的“序号”</span></div><div class="line">  PosType   seat;　　　<span class="comment">//通道块在迷宫中的“坐标位置”</span></div><div class="line">  <span class="keyword">int</span>       di;　　　　<span class="comment">//从此通道走向下一通道块的“方向”</span></div><div class="line">&#125;SElemType;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">MazePath</span><span class="params">(MazeType maze,PosType start,PosType end)</span></span>&#123;</div><div class="line">  InitStack(S); curpos = start;   <span class="comment">//设定“当前位置”为“入口位置”</span></div><div class="line">  curpos = <span class="number">1</span>;　　　　　　　　　　　　<span class="comment">//探索第一步</span></div><div class="line">  <span class="keyword">do</span>&#123;</div><div class="line">    <span class="keyword">if</span>(Pass(curpos))&#123;　　　　　　　<span class="comment">//当前位置可以通过，即是未曾走到过的通道块</span></div><div class="line">      FootPrint(curpos);　　　　　<span class="comment">//留下足迹</span></div><div class="line">      e = (curstep,curpos,<span class="number">1</span>);</div><div class="line">      Push(S,e);　　　　　　　　　<span class="comment">//加入路径</span></div><div class="line">      <span class="keyword">if</span>(corpos == end) <span class="keyword">return</span> (TRUE);</div><div class="line">      curpos = NextPos(curpos,<span class="number">1</span>);</div><div class="line">      curpos ++;　　　　　　　　 <span class="comment">//探索下一步</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;　　　　　　　　　　　　　<span class="comment">//当前位置不可以通过</span></div><div class="line">      <span class="keyword">if</span>(!StackEmpty(S))&#123;</div><div class="line">        Pop(S,e);</div><div class="line">        <span class="keyword">while</span>(e.di == <span class="number">4</span> &amp;&amp; !StackEmpty(S))&#123;</div><div class="line">          MarkPrint(e.seat); Pop(S,e);   <span class="comment">//留下不能通过的标记，并退回一步</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(e.di&lt;<span class="number">4</span>)&#123;</div><div class="line">          e.di++;  Push(S,e); 　　　　　　<span class="comment">//换下一个方向探索</span></div><div class="line">          curpos = NextPos(e.seat,e.di);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="keyword">while</span>(!StackEmpty(S));</div><div class="line">  <span class="keyword">return</span> (FALSE);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="栈与递归的实现"><a href="#栈与递归的实现" class="headerlink" title="栈与递归的实现"></a>栈与递归的实现</h3><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p><strong>队列</strong>(queue)是一种<strong>先进先出</strong>的线性表。只允许在表的<strong>一端进行插入，而在另一端删除元素</strong>。</p><p>队列的抽象数据类型定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ADT Queue&#123;</div><div class="line">  数据对象： D = &#123;ai|ai belong to ElemSet,i=<span class="number">1</span>,<span class="number">2</span>,....,n, n&gt;=<span class="number">0</span>&#125;</div><div class="line">  数据关系： R1 = &#123;&lt;ai<span class="number">-1</span>,ai&gt;|ai<span class="number">-1</span>,ai belong to D,i=<span class="number">1</span>,<span class="number">2</span>,....,n&#125;</div><div class="line">      InitQueue(&amp;Q)</div><div class="line">      <span class="comment">// 构造一个空队列Q。</span></div><div class="line">      DestoryQueue(&amp;Q)</div><div class="line">      <span class="comment">// 销毁栈Q。</span></div><div class="line">      ClearQueue(&amp;Q)</div><div class="line">      <span class="comment">//将Q清为空队列。</span></div><div class="line">      QueueEmpty(Q)</div><div class="line">      <span class="comment">// 若栈Q为空队列，则返回true,否则False。</span></div><div class="line">      QueueLength(Q)</div><div class="line">      <span class="comment">//返回S的元素个数，即队列的长度。</span></div><div class="line">      GetHead(Q,&amp;e)</div><div class="line">      <span class="comment">//用e返回Q的队头元素。</span></div><div class="line">      EnQueue(&amp;Q,e)</div><div class="line">      <span class="comment">//插入元素e为Q的新的队尾元素。</span></div><div class="line">      DeQueue(&amp;S,&amp;e)</div><div class="line">      <span class="comment">//删除Q的队头元素，并用e返回其值。</span></div><div class="line"> </div><div class="line">&#125;ADT Queue</div></pre></td></tr></table></figure><p>链队列</p><p><img src="../img/queue.png" alt="queue"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//－－－－－ADT Queue的表示与实现－－－－－</span></div><div class="line"></div><div class="line"><span class="comment">//－－－－－单链队列－－队列的链式存储结构－－－－－</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></div><div class="line">  QElemType       data;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">QNOde</span>    *<span class="title">next</span>;</span></div><div class="line">&#125;QNOde, *QueuePtr;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">  QueuePtr   front    <span class="comment">//队头指针</span></div><div class="line">  QueuePtr   rear     <span class="comment">//队尾指针</span></div><div class="line">&#125;LinkQueue;</div><div class="line"></div><div class="line"><span class="comment">//－－－－－基本操作的函数原型说明－－－－－</span></div><div class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></div><div class="line"><span class="function">   </span></div><div class="line"><span class="function">Status <span class="title">DestoryQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(LinkQueue &amp;Q)</span></span></div><div class="line"><span class="function">  </span></div><div class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(LinkQueue Q)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">Status <span class="title">QueueLength</span><span class="params">(LinkQueue Q)</span></span></div><div class="line"><span class="function">  </span></div><div class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span></div><div class="line"><span class="function">  </span></div><div class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span></div><div class="line"><span class="function">  </span></div><div class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="comment">//－－－－－基本操作的算法描述－－－－－</span></span></div><div class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</div><div class="line">  Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</div><div class="line">  <span class="keyword">if</span>(!Q.front)<span class="built_in">exit</span>(OVERFLOW);</div><div class="line">  Q.front-&gt;next = <span class="literal">NULL</span>;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">DestoryQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</div><div class="line">  <span class="keyword">while</span>(Q.front)&#123;</div><div class="line">    Q.rear = Q.front-&gt;next;</div><div class="line">    <span class="built_in">free</span>(Q.front);</div><div class="line">    Q.front = Q.rear;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span></span>&#123;</div><div class="line">  p = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</div><div class="line">  <span class="keyword">if</span>(!p) <span class="built_in">exit</span>(OVERFLOW);</div><div class="line">  p-&gt;data = e;  p-&gt;next = <span class="literal">NULL</span>;</div><div class="line">  Q.rear-&gt;next = p;</div><div class="line">  Q.rear = p;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;</div><div class="line">  p = Q.front-&gt;next;</div><div class="line">  e = p-&gt;data;</div><div class="line">  Q.front-&gt;next = p-&gt;next;</div><div class="line">  <span class="keyword">if</span>(Q.rear == p) Q.rear = Q.front;</div><div class="line">  <span class="built_in">free</span>(p);</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>循环队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//－－－－－循环队列－－队列的顺序存储结构－－－－－</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQSIZE 100　　　<span class="comment">//最大队列长度</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">  QElemType  *base;   <span class="comment">//初始化的动态分配存储空间</span></div><div class="line">  <span class="keyword">int</span>  front;         <span class="comment">//头指针，若队列不为空，指向队列头元素</span></div><div class="line">  <span class="keyword">int</span>  rear;　　　　　　<span class="comment">//尾指针，若队列不为空，指向队列尾元素的下一个位置</span></div><div class="line">&#125;sqQueue;</div><div class="line"></div><div class="line"><span class="comment">//－－－－－循环队列的基本操作的算法描述－－－－－</span></div><div class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</div><div class="line">  <span class="comment">//构造一个空队列</span></div><div class="line">  Q.base = (QElemType ×)<span class="built_in">malloc</span>(MAXQSIZE *<span class="keyword">sizeof</span>(QElemType));</div><div class="line">  <span class="keyword">if</span>(!Q.base) <span class="built_in">exit</span>(OVERFLOW);</div><div class="line">  Q.front = Q.rear = <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span>&#123;</div><div class="line">  <span class="comment">//返回Ｑ的元素个数，即队列的长度</span></div><div class="line">  <span class="keyword">return</span>(Q.rear-Q.front+MAXQSIZE) % MAXQSIZE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, QElemType e)</span></span>&#123;</div><div class="line">  <span class="comment">//插入元素ｅ为Ｑ的新的队尾元素</span></div><div class="line">  <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MAXQSIZE == Q.front) <span class="keyword">return</span> ERROR; <span class="comment">//队列满</span></div><div class="line">  Q.base[Q.rear]= e;</div><div class="line">  Q.rear = (Q.rear+<span class="number">1</span>) % MAXQSIZE;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">DEQueue</span><span class="params">(SqQueue &amp;Q, QElemType e)</span></span>&#123;</div><div class="line">  <span class="comment">//若对垒不为空，则删除Ｑ的队头元素，用ｅ返回其值，并返回ＯＫ；</span></div><div class="line">  <span class="comment">//否则返回ＥＲＲＯＲ</span></div><div class="line">  <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;</div><div class="line">  e = Q.base[Q.front];</div><div class="line">  Q.front = (Q.front+<span class="number">1</span>) %　MAXQSIZE;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;栈和队列&quot;&gt;&lt;a href=&quot;#栈和队列&quot; class=&quot;headerlink&quot; title=&quot;栈和队列&quot;&gt;&lt;/a&gt;栈和队列&lt;/h2&gt;&lt;h3 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h3&gt;&lt;p&gt;栈(stack)　限定仅在表尾进行插入或删除操作的线性表。&lt;/p&gt;
&lt;p&gt;表尾端称为&lt;strong&gt;栈顶(top)&lt;/strong&gt;，表头端称为&lt;strong&gt;栈底(bottom)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../img/stackfeature.png&quot; alt=&quot;stackfeature&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后进先出&lt;/strong&gt;的线性表。栈的抽象数据类型定义：&lt;/p&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读，栈和队列" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%EF%BC%8C%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Array</title>
    <link href="http://yoursite.com/2018/01/02/array/"/>
    <id>http://yoursite.com/2018/01/02/array/</id>
    <published>2018-01-02T12:24:44.000Z</published>
    <updated>2018-01-03T13:32:44.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><p>简言之，一个线性表是n个数据元素的有限序列。</p><p>在复杂的线性表中，一个数据元素可由若干个数据项(item)组成。在这种情况下，常把数据元素称为记录(record)，含有大量记录的线性表又称为文件（file）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ADT List&#123;</div><div class="line">  <span class="comment">//数据对象</span></div><div class="line">  D = &#123;a1|a2 belong to ElemSet, i=<span class="number">1</span>,<span class="number">2</span>,....,n, n&gt;<span class="number">0</span>&#125;</div><div class="line">  <span class="comment">//数据关系</span></div><div class="line">  R1 = &#123;&lt;ai<span class="number">-1</span>,ai&gt;|ai<span class="number">-1.</span>ai belong to D,i = <span class="number">1</span>,<span class="number">2.</span>..n&#125;</div><div class="line">  <span class="comment">//基本操作</span></div><div class="line">  InitList(&amp;L)</div><div class="line">    <span class="comment">//构造一个空的线性表Ｌ</span></div><div class="line">  DestoryList(&amp;L)</div><div class="line">    <span class="comment">//销毁线性表Ｌ</span></div><div class="line">  ClearList(&amp;L)</div><div class="line">    <span class="comment">//将Ｌ重置为空表</span></div><div class="line">  ListEmpty(L)</div><div class="line">    <span class="comment">//若L为空表，返回True,否则False</span></div><div class="line">  ListLength(L)</div><div class="line">    <span class="comment">//返回L中数据元素个数</span></div><div class="line">  GetElem(L,i,&amp;e)</div><div class="line">    <span class="comment">//用e返回L中第i个数据元素的值</span></div><div class="line">  ListInsert(&amp;L,i,e)</div><div class="line">    <span class="comment">//在Ｌ中第i个位置之前插入新的数据元素e，Ｌ的长度加1。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p>例2.1　LA和LB中的数据元素按值非递减有序排列，要求将LA和LB归并为新的线性表LC，且LC中的数据元素仍然按值非递减有序排列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LA = (3,5,8,11)  LB = (2,6,8,9,11,15,20)</span></div><div class="line"><span class="comment">// LC =(2,3,5,6,8,8,9,11,11,15,20)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList</span><span class="params">(List La,List Lb,List &amp;Lc)</span></span>&#123;</div><div class="line">  InitList(Lc);</div><div class="line">  i = j = <span class="number">1</span>; k=<span class="number">0</span>;</div><div class="line">  La_len = ListLength(La); Lb_len = ListLength(Lb);</div><div class="line">  <span class="keyword">while</span>((i&lt;=La_len)&amp;&amp;(j&lt;=Lb_len))&#123;</div><div class="line">    GetElem(La,i,ai); GetElem(Lb,j,bj);</div><div class="line">    <span class="keyword">if</span>(ai&lt;=bj)&#123;ListInsert(Lc,++k,ai);++i;&#125;</div><div class="line">    <span class="keyword">else</span>&#123;ListInsert(Lc,++k,bj);++j;&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span>(i&lt;=La_len)&#123;</div><div class="line">    GetElem(La,i,ai);ListInsert(Lc,++k,ai);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">while</span>(j&lt;=Lb_len)&#123;</div><div class="line">     GetElem(Lb,i,bj);ListInsert(Lc,++k,bj);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h3><p>线性表的顺序表示指的是用一组地址连续的存储单元以此存储线性表的数据元素。</p><p>一般来说，线性表的第$i$个数据元素$a_j$的存储位置为 $LOC(a_i) = LOC(a_1)+(i-1) \times l$</p><p>线性表的这种机内表示称作线性表的顺序存储结构或顺序映像(sequential mapping)。</p><p>Ｃ语言中可用动态分配的一维数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// －－－－－线性表的动态分配顺序存储结构－－－－－</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE   100  <span class="comment">// 线性表存储空间的初始分配量</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT    10　 <span class="comment">// 线性表存储空间的分配增量</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></div><div class="line">  ElemType *elem;       <span class="comment">// 存储空间基址</span></div><div class="line">  <span class="keyword">int</span>      length;      <span class="comment">// 当前长度</span></div><div class="line">  <span class="keyword">int</span>      listsize;    <span class="comment">// 当前分配的存储容量</span></div><div class="line">&#125;SqList;</div></pre></td></tr></table></figure><p>线性表插入和删除操作：</p><p><img src="../Pictures/datastructure/insert.png" alt="insert"></p><p>一般情况下，把第$i(1\le i\le n)$个元素之前插入一个元素时，需要将第$n$至第$i$（共$n-i+1$）个元素向后移动一个位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>) <span class="keyword">return</span> ERROR;</div><div class="line">  <span class="keyword">if</span>(L.length&gt;=L.listsize)&#123;       <span class="comment">//当前存储空间已满，增加分配</span></div><div class="line">    newbase = (ElemType *)<span class="built_in">realloc</span>(L.elem,               (L.listsize+LISTINCREMENT)*<span class="keyword">sizeof</span>(ElemType));</div><div class="line">    <span class="keyword">if</span>(!newbase)<span class="built_in">exit</span>(OVERFLOW);   <span class="comment">//存储分配失败</span></div><div class="line">    L.elem = newbase;             <span class="comment">//新基址  </span></div><div class="line">    L.listsize+= LISTINCREMENT;   <span class="comment">//增加爱存储容量</span></div><div class="line">  &#125;</div><div class="line">  q = &amp;(L.elem[i<span class="number">-1</span>]);            <span class="comment">//q为插入位置</span></div><div class="line">  <span class="keyword">for</span>(p = &amp;(L.elem[L.length<span class="number">-1</span>]);p&gt;=<span class="number">1</span>;--p) *(p+<span class="number">1</span>) = *(p);</div><div class="line">                                 <span class="comment">//插入位置及之后的元素右移</span></div><div class="line">  *q = e;　　　　　　　　　　　　　　<span class="comment">//插入e</span></div><div class="line">  ++L.length;                    <span class="comment">//表长增１</span></div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;                               <span class="comment">//时间复杂度Ｏ(n)</span></div></pre></td></tr></table></figure><p>线性表删除操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">ListDelete_Sq</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</div><div class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>) <span class="keyword">return</span> ERROR;</div><div class="line">  p = &amp;(L.elem[i<span class="number">-1</span>]);         <span class="comment">//p被删除元素的位置</span></div><div class="line">  e = *p;                     <span class="comment">//被删除元素的值赋给e</span></div><div class="line">  q = L.elem + L.length<span class="number">-1</span>;    <span class="comment">//表尾元素的位置</span></div><div class="line">  <span class="keyword">for</span>(++p;p&lt;=q;++p) *(p<span class="number">-1</span>) = *p;  <span class="comment">//被删除元素之后的元素左移  </span></div><div class="line">  --L.length;                 <span class="comment">//表长减1  </span></div><div class="line">  <span class="keyword">return</span> Ok;</div><div class="line">&#125;                            <span class="comment">//时间复杂度Ｏ(n)</span></div></pre></td></tr></table></figure><p>案例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> NO;</div><div class="line">    <span class="keyword">int</span> score;</div><div class="line">&#125;ElemType;</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    ElemType elem[MAXSIZE];</div><div class="line">    <span class="keyword">int</span> length;</div><div class="line">&#125;SqList;</div><div class="line"></div><div class="line"><span class="comment">//初始化</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList *pL)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    pL-&gt;length =<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//插入</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertList</span><span class="params">(SqList *pL,ElemType e,<span class="keyword">int</span> i)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(pL-&gt;length &gt;MAXSIZE)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    pL-&gt;elem [i]=e;</div><div class="line">    pL-&gt;length ++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//排序</span></div><div class="line"><span class="function"><span class="keyword">void</span>  <span class="title">SortScore</span><span class="params">(SqList *pL)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pL-&gt;length ;i++)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;pL-&gt;length ;j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(pL-&gt;elem [i].score&lt;pL-&gt;elem [j].score )</div><div class="line">            &#123;</div><div class="line">                ElemType temp=pL-&gt;elem [i];</div><div class="line">                pL-&gt;elem [i]=pL-&gt;elem [j];</div><div class="line">                pL-&gt;elem [j]=temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(SqList *pL,SqList *pS,SqList *T)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i&lt;pL-&gt;length &amp;&amp;j&lt;pS-&gt;length )</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(pL-&gt;elem [i].score &gt;pS-&gt;elem [j].score )</div><div class="line">            T-&gt;elem [k++]=pL-&gt;elem [i++];</div><div class="line">            </div><div class="line">        <span class="keyword">else</span></div><div class="line">    </div><div class="line">            T-&gt;elem [k++]=pS-&gt;elem [j++];</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i&lt;pL-&gt;length )</div><div class="line">        T-&gt;elem [k ++]=pL-&gt;elem [i++ ];</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(j&lt;pS-&gt;length )</div><div class="line">        T-&gt;elem [k ++]=pS-&gt;elem [j ++];    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Printf</span><span class="params">(SqList *pL)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pL-&gt;length ;i++)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"(%2d,%2d)\n"</span>,pL-&gt;elem [i].NO ,pL-&gt;elem [i].score );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    SqList L,S,T;</div><div class="line">    ElemType e;</div><div class="line">    InitList(&amp;L);</div><div class="line">    e.NO =<span class="number">5</span>; e.score =<span class="number">60</span>;</div><div class="line">    InsertList(&amp;L,e,<span class="number">0</span>);</div><div class="line">    e.NO =<span class="number">6</span>; e.score =<span class="number">80</span>;</div><div class="line">    InsertList(&amp;L,e,<span class="number">1</span>);</div><div class="line">    e.NO =<span class="number">7</span>; e.score =<span class="number">76</span>;</div><div class="line">    InsertList(&amp;L,e,<span class="number">2</span>);</div><div class="line">    e.NO =<span class="number">8</span>; e.score =<span class="number">50</span>;</div><div class="line">    InsertList(&amp;L,e,<span class="number">3</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"顺序表L:\n"</span>);</div><div class="line">    Printf(&amp;L);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n按照成绩大小排序后的顺序表L：\n"</span>);</div><div class="line">    SortScore(&amp;L);</div><div class="line">    Printf(&amp;L);</div><div class="line"></div><div class="line">    InitList(&amp;S);</div><div class="line">    e.NO =<span class="number">10</span>; e.score =<span class="number">70</span>;</div><div class="line">    InsertList(&amp;S,e,<span class="number">0</span>);</div><div class="line">    e.NO =<span class="number">20</span>; e.score =<span class="number">85</span>;</div><div class="line">    InsertList(&amp;S,e,<span class="number">1</span>);</div><div class="line">    e.NO =<span class="number">30</span>; e.score =<span class="number">75</span>;</div><div class="line">    InsertList(&amp;S,e,<span class="number">2</span>);</div><div class="line">    e.NO =<span class="number">40</span>; e.score =<span class="number">90</span>;</div><div class="line">    InsertList(&amp;S,e,<span class="number">3</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n顺序表S:\n"</span>);</div><div class="line">    Printf(&amp;S);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n按照成绩大小排序后的顺序表S：\n"</span>);</div><div class="line">    SortScore(&amp;S);</div><div class="line">    Printf(&amp;S);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</div><div class="line"></div><div class="line">    InitList(&amp;T);</div><div class="line">    T.length =L.length +S.length ;</div><div class="line">    Merge(&amp;L,&amp;S,&amp;T);</div><div class="line">    Printf(&amp;T);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>线性表的顺序存储结构特点：逻辑关系上相邻的两个单元在物理位置上也相邻。缺点：在作插入或删除操作时，需要移动大量元素。</p><h3 id="线性表的链式表现和实现"><a href="#线性表的链式表现和实现" class="headerlink" title="线性表的链式表现和实现"></a>线性表的链式表现和实现</h3><p>线性表链式存储结构特点：用一组任意的存储单元(连续或不连续)存储线性表的数据元素 。</p><p>如何表示数据元素$a_i$与其直接后继数据元素$a_{i+1}$之间关系:结点｛<strong>本身信息+直接后继的存储位置</strong>｝</p><p>结点包含两个域：数据域＋指针域　　n个结点链结成一个链表。</p><p><img src="../../Pictures/datastructure/list_operate.png" alt="list_operate"></p><blockquote><p>线性单链表：(ZHAO, QIAN, SUN, LI, ZHOU, WU, ZHENG, WANG)</p></blockquote><p><img src="../Pictures/datastructure/linear_list.png" alt="linear_list"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//－－－－－线性表的单链存存储结构－－－－－－</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></div><div class="line">  ElemType        data;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>   *<span class="title">next</span>;</span></div><div class="line">&#125;LNode, *LinkList;</div></pre></td></tr></table></figure><p>$p-&gt;data = a_i$, 则$p-&gt;next-&gt;data = a_{i+1}$。</p><p>GetElem在单链表中的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span>&#123;</div><div class="line">  <span class="comment">//L为带头结点的单链表的头指针。</span></div><div class="line">  <span class="comment">//当第i个元素存在时，其值赋给e并返回OK，否则返回error。</span></div><div class="line">  p = L-&gt;next; j = <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span>(p&amp;&amp;j&lt;i)&#123;</div><div class="line">    p = p-&gt;next;++j;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(!p||j&gt;i) <span class="keyword">return</span> ERROR;</div><div class="line">  e = p-&gt;data;         <span class="comment">//取第i个元素</span></div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>单链表插入操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</div><div class="line">  <span class="comment">//在带头结点的单链表Ｌ中第i个位置之前插入元素e</span></div><div class="line">  p = L; j = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(p&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;p = p-&gt;next;++j;&#125;  <span class="comment">//寻找第i－１个结点</span></div><div class="line">  <span class="keyword">if</span>(!p||j&gt;i) <span class="keyword">return</span> ERROR;</div><div class="line">  s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode)); <span class="comment">//生成新结点</span></div><div class="line">  s-&gt;data = e; s-&gt;next = p-&gt;next;　　　　<span class="comment">//插入Ｌ中</span></div><div class="line">  p-&gt;next = s;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;　                                 <span class="comment">//O(n)</span></div></pre></td></tr></table></figure><p>单链表删除操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">ListDelete_L</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span>&#123;</div><div class="line">  <span class="comment">//在带头结点的单链表Ｌ中删除第i个元素，并由e返回其值</span></div><div class="line">  p = L;j=<span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(p-&gt;next&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;       <span class="comment">//寻找第i个结点，并令p指向其前趋</span></div><div class="line">    p = p-&gt;next;++j;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(!(p-&gt;next)||j&gt;i) <span class="keyword">return</span> ERROR;</div><div class="line">  q = p-&gt;next; p-&gt;next = q-&gt;next;   <span class="comment">//删除并释放结点</span></div><div class="line">  e = q-&gt;data; <span class="built_in">free</span>(q);</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;                                  <span class="comment">//O(n)</span></div></pre></td></tr></table></figure><p>两个有序链表合并为一个有序链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_L</span><span class="params">(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)</span></span>&#123;</div><div class="line">  pa = La-&gt;next; pb = Lb-&gt;next;</div><div class="line">  Lc = pc = La;       <span class="comment">//用La的头结点作为Lc的头结点</span></div><div class="line">  <span class="keyword">while</span>(pa&amp;&amp;pb)&#123;</div><div class="line">    <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;</div><div class="line">      pc-&gt;next = pa; pc = pa; pa= pa-&gt;next;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span>&#123;pa-next = pb; pc=pb; pb = pb-&gt;next;&#125;</div><div class="line">  &#125;</div><div class="line">  pc-&gt;next = pa?pa:pb; <span class="comment">//插入剩余段</span></div><div class="line">  <span class="built_in">free</span>(Lb);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>双向链表</strong>：结点有两个指针域，其一指向直接后继，另一指向直接前趋</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//－－－－－线性表的双向链表存储结构－－－－－</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>&#123;</span></div><div class="line">  ElemType        data;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>   *<span class="title">prior</span>;</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span>   *<span class="title">next</span>;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="../Pictures/datastructure/dulnode.png" alt="dulnode"></p><p>结构特性：$d-&gt;next-&gt;prior = d-&gt;prior-&gt;next = d$&gt;</p><p>双向链表插入操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">ListInsert_DuL</span><span class="params">(DuLinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</div><div class="line">  <span class="comment">//在带头结点的双链循环表Ｌ中第i个位置之前插入元素e</span></div><div class="line">  <span class="keyword">if</span>(!(p = GetElemP_Dul(L,i)))   <span class="comment">//在Ｌ中确定插入位置</span></div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line">  <span class="keyword">if</span>(!(s = (DuLinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DuLNode))))</div><div class="line">    <span class="keyword">return</span> ERROR</div><div class="line">  s-&gt;data = e;</div><div class="line">  s-&gt;prior = p-&gt;prior; p-&gt;prior-&gt;next = s;</div><div class="line">  s-&gt;next = p;         p-&gt;prior = s;</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>双向链表删除操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">ListDElete_DuL</span><span class="params">(DuLinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</div><div class="line">  <span class="comment">//删除带头结点的双链循环表Ｌ第i个元素</span></div><div class="line">  <span class="keyword">if</span>(!(p = GetElemP_Dul(L,i)))   <span class="comment">//在Ｌ中确定插入位置</span></div><div class="line">    <span class="keyword">return</span> ERROR;</div><div class="line"> e = p-&gt;data;</div><div class="line">  p-&gt;prior-&gt;next = p-&gt;next;</div><div class="line">  p-&gt;next-&gt;prior = p-&gt;prior;</div><div class="line">  <span class="built_in">free</span>(p);</div><div class="line">  <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h2&gt;&lt;h3 id=&quot;类型定义&quot;&gt;&lt;a href=&quot;#类型定义&quot; class=&quot;headerlink&quot; title=&quot;类型定义&quot;&gt;&lt;/a&gt;类型定义&lt;/h3&gt;&lt;p&gt;简言之，一个线性表是n个数据元素的有限序列。&lt;/p&gt;
&lt;p&gt;在复杂的线性表中，一个数据元素可由若干个数据项(item)组成。在这种情况下，常把数据元素称为记录(record)，含有大量记录的线性表又称为文件（file）。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ADT List&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//数据对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  D = &amp;#123;a1|a2 belong to ElemSet, i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,....,n, n&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//数据关系&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  R1 = &amp;#123;&amp;lt;ai&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,ai&amp;gt;|ai&lt;span class=&quot;number&quot;&gt;-1.&lt;/span&gt;ai belong to D,i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt;..n&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//基本操作&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  InitList(&amp;amp;L)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//构造一个空的线性表Ｌ&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  DestoryList(&amp;amp;L)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//销毁线性表Ｌ&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ClearList(&amp;amp;L)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//将Ｌ重置为空表&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ListEmpty(L)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//若L为空表，返回True,否则False&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ListLength(L)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//返回L中数据元素个数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  GetElem(L,i,&amp;amp;e)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//用e返回L中第i个数据元素的值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ListInsert(&amp;amp;L,i,e)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//在Ｌ中第i个位置之前插入新的数据元素e，Ｌ的长度加1。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读，线性表" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%EF%BC%8C%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://yoursite.com/2017/12/27/computer-network/"/>
    <id>http://yoursite.com/2017/12/27/computer-network/</id>
    <published>2017-12-27T11:22:47.000Z</published>
    <updated>2017-12-29T12:20:10.128Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h3><p>计算机网络的分类标准很多，比如按拓扑结构、截至交换方式、交换方式以及数据传输率等．</p><h4 id="局域网-LAN"><a href="#局域网-LAN" class="headerlink" title="局域网(LAN)"></a>局域网(LAN)</h4><p>　　指的是范围几百米到几十公里内办公楼群或校园内的计算接相互连接所构成的计算机网络．局域网区别其他网络的主要体现：(1)网络所覆盖的物理范围；(2)网络所使用的传输技术；(3)网络的拓扑结构．</p><p>　　局域网机场使用共享通道，即所以的机器都接在同一条电缆上．</p><p>　　局域网具有不同的拓扑结构．在总线网络中，任何时刻只允许一台机器发送数据，其他所有奇迹处于接受状态．当两台或多台机器想要同时发送数据时必须进行仲裁，仲裁机制可以是集中式也可以是分布式．<strong>以太网是基于共享总线采用分布控制机制的局域网．</strong>在环形网中，数据沿着环不停地旋转．</p><a id="more"></a><h4 id="城域网-MAN"><a href="#城域网-MAN" class="headerlink" title="城域网(MAN)"></a>城域网(MAN)</h4><p>　　城域网可以覆盖距离不远的几栋办公楼，也可以覆盖一座城市；既可以是私人网，也可以是公用网；即可以支持数据和话音传输，也可以与有线电视相连．</p><p>　　城域网的标准名称为分布式队列双总线(DQDB)，其工作范围一般是160km，数据传输率为44.736Mbps. DQDB采用两条单项总线相连，其中每条总线都有一个端接点，各自产生一个53字节的信元流．每个信元都从端接点沿着总线往下传，当它到达终点时，就从总线消失．</p><h4 id="广域网-WAN"><a href="#广域网-WAN" class="headerlink" title="广域网(WAN)"></a>广域网(WAN)</h4><p>　　通常跨接很大的物理范围，如一个国家．广域网包含很多用来运行用户应用程序的机器集合，我们通常把这些机器叫做主机；把这些主机连接在一起的是<strong>通信子网</strong>．通信子网的任务是在主机之间传送报文．通信子网包含两部分：传输信道和转接设备．传输信道用于在机器间传送数据，转接设备是专用计算机，用来连接两条或多条传输线．当数据从一条输入信道到达后，转接设备必须选择一条输出信道，把数据继续向前发送．</p><h4 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h4><p>　　世界上有许多网络，不同网络的物理结构、协议和所采用的标准是各不相同的．如果连接到不同网络的用户需要进行相互通信，就需要将这些不兼容的网络通过称为网关的机器设备连接起来，并有网管完成相应的１转换功能．多个网络相互连接构成的集合称为互联网．</p><h4 id="无线网"><a href="#无线网" class="headerlink" title="无线网　"></a>无线网　</h4><p>　　无线网易于安装和使用，但是数据传输率一般较低，远低于有限局域网；另外无线局域网的误码率也比较高，而且站点之间相互干扰比较厉害．</p><ul><li><strong>要想让两台计算机进行通信，必须是它们采用相同的信息交换规则．我们吧计算机网络中用于规定信息的格式以及如何发送和接收信息的一套规则称为网络协议或通信协议</strong>．</li></ul><h3 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分　"></a>网络层次划分　</h3><p>　　为了是不用计算机厂家生产的计算机能够相互通信，更大范围内建立计算机网络，国际标准化组织(ISO)在1978年提出＂开放系统互联参考模型OSI/RM模型（Open System Interconnection/Reference Model）＂它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层．第四层完成数据传送服务，上面三层面向用户．</p><p>　　除了标准的OSI七层模型之外，常见的网络层此划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示：</p><p><img src="http://images2015.cnblogs.com/blog/764050/201509/764050-20150904094019903-1923900106.jpg" alt="通信协议"></p><h4 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h4><p>　　TCP/IP协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开TCP/IP协议。</p><p><img src="http://images2015.cnblogs.com/blog/764050/201509/764050-20150904095142060-1017190812.gif" alt=""></p><p><strong>物理层(Physical Layer)</strong></p><p>　　激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性．<strong>该层为上层协议提供了传输数据的可靠物理媒体，简单的说，物理层确保原始的数据可在各种物理媒体上传输</strong>．物理层记住两个重要的设备名称：中继器和集线器．</p><p><strong>数据链路层(Data Link Layer)</strong></p><p>　　数据链路层在物理层提供的服务的基础上想网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层．未达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路从中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接受方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理．数据链路层在不可靠的物理介质上提供可靠的传输．该层的作用包括：物理层地址寻址、数据的成帧、流量控制、数据的检错、重发等．</p><blockquote><p>数据链路层为网络层提供可靠的数据传输．</p><p>基本数据单位为帧．</p><p>主要的协议为以太网协议．</p><p>两个重要的设备名称：网桥和交换机．</p></blockquote><p><strong>网络层（Network Layer）</strong></p><p>　　网络层实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的选择、保持和终止等．它提供的服务使传输层不元哦了解网络中的数据传输和交换技术．＂路劲选择、路由和逻辑寻址＂．</p><p>　　网络层中涉及众多的协议，其中包括TCP/IP的核心协议——IP协议．IP协议非常简单，仅仅提供不可靠、无连接的传送服务．IP协议的主要功能有：</p><ul><li>无连接数据报传输、数据报路由选择和差错控制，与IP协议配套使用实现其功能的还有地址解析协议ARP，逆地址解析协议RARP、因特网报文协议ICMP、因特网管理协议IGMP．</li></ul><p><strong>1&gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；</strong></p><p><strong>2&gt; 基本数据单位为IP数据报；</strong></p><p><strong>3&gt; 包含的主要协议：</strong></p><ul><li><strong>IP协议（Internet Protocol，因特网互联协议）;</strong></li><li><strong>ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;</strong></li><li><strong>ARP协议（Address Resolution Protocol，地址解析协议）;</strong></li><li><strong>RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。</strong></li></ul><p><strong>4&gt; 重要的设备：路由器。</strong></p><p><strong>传输层（Transport Layer）</strong></p><p>　　第一个端到端，即主机到主机的层次．传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输．此外传输层还要处理端到端的差错控制和流量控制问题．</p><p>　　传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输．在这一层，信息传送的协议数据单元称为段或报文．</p><p>　　网络协议值根据网路地址将源结点出发的数据包传送到目的终点，而传输层则负责将数据可靠地传送到相应的端口．</p><ul><li><strong>传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题．</strong></li><li><strong>包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）．</strong></li><li><strong>重要设备：网关．</strong></li></ul><p><strong>会话层（Session Layer）</strong></p><p>会话层管理主机之间的会话进程，负责建立、管理、终止进程之间的回话．会话层还利用在数据中插入校检点来实现数据的同步．</p><p><strong>表示层（Presentation Layer）</strong></p><p>表示层岁上层数据或信息进行狡猾以保证一个主机信息应用层信息可以被另外一个主句的应用程序来理解．表示层的数据转换包括数据的加密、压缩、格式转换等．</p><p><strong>应用层（Application Layer）</strong></p><p>为操作系统或网络应用程序提供访问网络服务的接口．</p><p>会话层、表示层和应用层重点：</p><ul><li><strong>数据传输基本单位为报文</strong></li><li><strong>包含的主要协议：FTP（文件传送协议）、Telnet(远程登录协议)、DNS(域名解析协议)、SMTP(邮件传送协议)、POP3协议(邮局协议)、HTTP协议（Hyper Text Transfer Protocol）．</strong></li></ul><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p><strong>网络地址</strong></p><p>IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。</p><p><strong>广播地址</strong></p><p>广播地址通常称为直接广播地址，是为了区分首先广播地址。</p><p>广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1.当向某个网络的广播地址发送消息时，该网络的所有主机都能接收到该广播的地址。</p><p><strong>组播地址</strong></p><p>D类地址就是组播地址。</p><ul><li><p>A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255;</p></li><li><p>B类地址以10开头，前两个字节作为网络号，地址范围为：128.0.0.0~191.255.255.255;</p></li><li><p>C类地址以110开头，前三个字节作为网络号，地址范围为：192.0.0.0~223.255.255.255;</p></li><li><p>D类地址以1110开头，地址范围为：224.0.0.0~239.255.255.255,D类地址作为组播地址（一对多通信）；</p></li><li><p>E类地址以1111开头，地址范围为：240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用</p><p>​</p></li></ul><p>A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><p><strong>255.255.255.255</strong></p><p>该IP四肢指的是受限的广播地址。首先广播地址与一般广播地址（直接广播地址）的区别在于，受限广播只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址即可在本地广播，也可跨网段广播。例如主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能接收到该数据包；若发送受限广播数据包，则不能收到。受限的广播不能通过路由器。</p><p><strong>0.0.0.0</strong></p><p>常用于寻找自己的IP地址，例如在我们的RARP,BOOTP和DHCP协议中，若某个未知的IP地址的无盘机想要知道自己的IP地址，他就以255.255.255.255为目的的地址，向本地范围（具体而言就是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p><p><strong>回环地址</strong></p><p>127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用语对本机的测试，用的最多的是127.0.0.0</p><p><strong>A,B,C类私有地址</strong></p><p>私有地址也叫专用地址，它们不会在全球使用，只具体本地意义。</p><ul><li>A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255</li><li>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</li><li>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168..255.255</li></ul><h3 id="子掩码及网络划分"><a href="#子掩码及网络划分" class="headerlink" title="子掩码及网络划分"></a>子掩码及网络划分</h3><p>　　IPv4网络号占位太多，而主机号位太少，所以其能提供的主机地址也越来越稀缺，目前除了使用NAT在企业内部利用保留地址自行分配以外，通常都对一个高类别的IP地址进行再划分，以形成多个子网，提供不同规模的用户群使用，为了在网络分段情况下有效地利用IP地址，通过对主机号的高位部分取作为子网号，从通常的网络位界限中扩展或压缩子网掩码，用来创建某类地址的更多子网。</p><p><strong>子掩码</strong></p><p>　　子掩码是标志两个IP地址是否同属于一个子网的，也是32为二进制地址，其每一个为1代表改为是网络位，为0代表主机位。他和IP地址一样也是使用点式十进制来表示。如果两个IP地址在子网掩码的按位与的计算下得到相同结果，即表明它们共属于同一子网。</p><p>　　<strong>在计算子网掩码时，我们要注意IP地址中的保留地址，即“0”地址和广播地址，它们是指主机地址或网络地址全为0或1时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。</strong></p><p><strong>子网掩码的计算：</strong></p><p>　　对于无须再划分成子网的IP地址来说，其子网掩码非常简单，即按照其定义可写出：如某B类IP地址为10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果他是一个C类地址，则其子网掩码为255.255.255.0。</p><p>子网掩码和网络划分常见面试考题：</p><p><strong>利用子网数来计算</strong></p><p>在求子网掩码之前必须搞清楚要划分的子网数目，以及每个子网内所需主机数目。</p><p>（１）将子网数目转化为二进制表示：</p><p>如欲将B类IP地址168.195.0.0划分成27个子网：27=11011；</p><p>（２）取得该耳机在南海的位数，为N；</p><p>该耳机在南海为五位数，N=5</p><p>（３）取IP地址的类子网掩码，将主机地址部分的前N位置1即可以得出该IP地址划分子网的子网掩码。</p><p>将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0</p><p><strong>利用主机数来计算</strong></p><p>如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台：</p><p>(1) 将主机数目转化为二进制来表示；</p><p>　700=1010111100；</p><p>(２)如果主机数小与或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数为N，这里肯定N<8。如果大于254，则n>8，这就是说主机地址将占据不止8位；</8。如果大于254，则n></p><p>该二进制是十位数，N=10</p><p>(3) 使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。</p><p>将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后 10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。</p><p><strong>根据每个网络的主机数量进行子网地址的规划和计算子网掩码</strong></p><p>比如一个子网有10台主机，那么对于这个子网需要的IP地址是：10+1+1+1=13</p><p><strong>加的第一个1是这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址</strong></p><p>因为13小于16（16等于2的4次方），所以主机为为4位，而256－16＝240，所以该子网掩码为255.255.255.240。如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。</p><h3 id="ARP-RARP协议"><a href="#ARP-RARP协议" class="headerlink" title="ARP/RARP协议"></a>ARP/RARP协议</h3><p>　　地址解析协议，即ARP(Address Resolution Protocol)，是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求是直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上，网络的主机可以自助发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其计入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。</p><p><strong>ARP工作流程举例：</strong></p><p>主机B的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01;</p><p>主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02;</p><p>当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：</p><ul><li>根据主机A上的路由表的内容，IP确定用于访问主机B的转发IP协议地址是192.168.1.2。然后Ａ主机在自己本地ARP缓存中检查主机Ｂ的匹配MAC地址。</li><li>如果主机Ａ在ARP缓存中没有找到映射，他将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机Ａ的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台诸暨都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。</li><li>主机Ｂ确定ARP请求中的IP地址与自己的IP地址匹配，则将主机Ａ的IP地址和MAC地址映射田间道本地的ARP缓存中。</li><li>主机Ｂ将包含其MAC地址的ARP回复消息直接发送回去主机Ａ。</li><li>当主机Ａ收到从主机Ｂ发来的ARP回复消息时，会用主机Ｂ的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机Ｂ的MAC地址一旦确定，主机Ａ就能想主机Ｂ发送IP通信了。</li></ul><p>　　<strong>逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址。</strong>比如局域网中的一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答.</p><p>　　RARP协议工作流程：</p><ul><li>给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配的一个IP地址</li><li>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址相应的IP地址</li><li>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用</li><li>如果不存在，RARP服务器对此不作任何的响应</li><li>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</li></ul><h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><p>常见的路由选择协议有：RIP协议、OSPF协议。</p><ul><li><strong>RIP**</strong>协议** ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</li><li><strong>OSPF**</strong>协议** ：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</li></ul><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><p>　　<strong>TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。</strong></p><p>　　IP层接收由更底层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层－－TCP或UDP；相反IP层也把从TCP或UDP层接收来的数据包传送到更低层．IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者没有被破坏，IP数据包中含义发送它的主机地址（源地址）和接收它主机的地址（目的地址）．</p><p>　　TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯．TCP提供的是一种可靠的数据流业务，采用＂带重穿的肯定确认＂技术来实现传输的可靠性．TCP还采用一种称为＂滑动窗口＂的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送放的发送速度．</p><p><strong>TCP报文首部格式：</strong></p><p><img src="http://images2015.cnblogs.com/blog/764050/201509/764050-20150904110054856-961661137.png" alt="报文首部格式"></p><blockquote><p><strong>TCP协议的三次握手和四次挥手：</strong></p></blockquote><p><img src="http://images2015.cnblogs.com/blog/764050/201509/764050-20150904110008388-1768388886.gif" alt="三次握手"></p><ul><li><strong>seq</strong>:”sequance”序列号；<strong>ack</strong>:”acknowledge”确认号；</li><li><strong>SYN</strong>:”synchronize”请求同步标志；<strong>ACK</strong>:”acknowledge”确认标志”<strong>；FIN</strong>：”Finally”结束标志。</li></ul><p><strong>TCP连接建立过程：</strong>首先Client端发送链接请求报文，Server段接收连接后回复ACK报文后也向Server段发ACK报文，并分配资源，这样TCP连接就建立了．</p><p><strong>TCP连接断开过程：</strong>假设Client端发起中断请求连接，也就是发送FIN报文．Server段收到FIN报文后，意思是说＂我Client端没有数据要发给你了＂，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据．所以你先发送ACK，＂告诉Client端，你的请求我收到了，但是我还没准备好，请继续等我的消息＂．这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文．当Server端确定数据已发送完成，则向Client端发送FIN报文，＂告诉Client端，好了，我这边数据发完了，准备好关闭连接了＂．Client端收到FIN报文还有，＂就知道可以关闭连接了，蛋挞还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传．＂，Server端收到ACK后，＂就知道可以断开连接了＂．Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了．OK，TCP连接就这样关闭了</p><p><strong>为什么需要三次握手</strong></p><p>　　在只有两次＂握手＂的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报文丢失了，故Client端不得不重新发送一遍；这格式化Server端仅收到一个连接请求，因此可以正常的建立连接．但是，有时候Client端重新发送请求不是因为数据报文丢失了，而是有可能数据传输过程因为网络并发亮很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据．．．问题就在这里，Client端实际上只有一次请求，而Server端却有2个相应，极端的情况下由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费．因此＂三次握手＂很有必要！</p><p><strong>为什么要四次挥手？</strong></p><p>　　试想一下，假如现在你是客户端，你想要断开与Server的所有连接该怎么做？第一步，你自己现停止向Server端发送数据，并等待Server的回复．但事情还没完，虽然你自身不往Server发送数据，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认．其实，说白了就是保证双方的一个合约的完整执行！</p><p>　　使用TCP的协议：FTP(文件传输协议)、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。</p><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>　　<strong>UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送，UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中需要程序员编程验证．</strong></p><p>　　UDP和TCP位于同一层，但它不管数据包的顺序、错误或重发．因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询－－应答的服务，例如NFS．相对与FTP或Telnet，这些服务需要交换的信息量较小。</p><p>　　每个UDP报文分UDP报头和UDP数据区两部分．报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度及校检值．UDP报头由四个域组成，其中每个域各占用2个字节，具体如下：</p><ul><li>源端口号</li><li>目标端口号</li><li>数据报长度</li><li>校检值</li></ul><p>使用UDP协议包括：TFTP(简单文件传输协议)、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP．</p><p><strong>TCP和UDP的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务．</strong></p><h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><p>　　DNS是域名系统（DomainNameSystem）的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为<strong>将URL转换为IP地址</strong>．域名是由圆点分开一串单词或缩写组成，每一个域名都对应一个唯一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器．DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务．</p><h3 id="NAT协议"><a href="#NAT协议" class="headerlink" title="NAT协议"></a>NAT协议</h3><p>　　NAT网络地址转换(Network Address Translation)属于接入广域网（WAN）技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，他被广泛应用与各种类型Internet接入方式和各种类型的网络中．原因很简单，NAT不仅完美地解决了IP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机．</p><h3 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3><p>　　DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段．</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>　　超文本传输协议（HTTP, HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议．所有的WWW文件必须遵守这个标准．</p><p>　　HTTP包括哪些请求：</p><ul><li>GET:　请求读取由URL所标志的信息</li><li>POST:　给服务器添加信息（如注释）</li><li>PUT：　在给定的URL下存储一个文档</li><li>DELETE：　删除给定的URL所标志的资源</li></ul><p><strong>HTTP中，POST与GET的区别</strong></p><ul><li>GET是服务器上获取数据，POST是向服务器传送数据</li><li>GET是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到</li><li>GET传送的数据量小，不能大于2KB；POST传送的数据量较大，一般被默认不受限制</li><li>根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的</li></ul><p>所谓的<strong>安全的</strong>意味着该操作用于获取信息而非修改信息．换句话说，GET请求一般不应该产生副作用．就是说，它仅仅是获取资源信息，就像是数据库查询一样，不会修改、增加数据，不会影响资源的状态</p><p><strong>幂等</strong>的意味着对同一URL的多个请求应该返回同样的结果</p><h3 id="一个生动形象的例子"><a href="#一个生动形象的例子" class="headerlink" title="一个生动形象的例子"></a>一个生动形象的例子</h3><p><strong>在浏览器中输入 <a href="http://www.baidu.com/" target="_blank" rel="external">www.baidu.com </a> 后执行的全部过程</strong></p><p>　　现在假设如果我们在客户端浏览器输入<a href="http://www.baidu.com，而baidu.com为要访问的服务器，下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：" target="_blank" rel="external">http://www.baidu.com，而baidu.com为要访问的服务器，下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：</a></p><ul><li>客户端浏览器通过DNS解析到www.baidu.com的IP地址为220.181.27.48，通过这个IP地址客户端到服务器的路径．客户端浏览器发起一个HTTP会话到220.181.27.48，然后通过TCP进行封装数据包，输入到网络层．</li><li>在客户端的传输层，把HTTP会话请求分成报文段，天剑源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口．然后使用IP层的IP地址查找目的端．</li><li>客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多描述，无非就是通过查找路由表决定通过那个路径到达服务器．</li><li>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包就可以传输了，然后发送IP数据包到达服务器的地址．</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;计算机网络分类&quot;&gt;&lt;a href=&quot;#计算机网络分类&quot; class=&quot;headerlink&quot; title=&quot;计算机网络分类&quot;&gt;&lt;/a&gt;计算机网络分类&lt;/h3&gt;&lt;p&gt;计算机网络的分类标准很多，比如按拓扑结构、截至交换方式、交换方式以及数据传输率等．&lt;/p&gt;
&lt;h4 id=&quot;局域网-LAN&quot;&gt;&lt;a href=&quot;#局域网-LAN&quot; class=&quot;headerlink&quot; title=&quot;局域网(LAN)&quot;&gt;&lt;/a&gt;局域网(LAN)&lt;/h4&gt;&lt;p&gt;　　指的是范围几百米到几十公里内办公楼群或校园内的计算接相互连接所构成的计算机网络．局域网区别其他网络的主要体现：(1)网络所覆盖的物理范围；(2)网络所使用的传输技术；(3)网络的拓扑结构．&lt;/p&gt;
&lt;p&gt;　　局域网机场使用共享通道，即所以的机器都接在同一条电缆上．&lt;/p&gt;
&lt;p&gt;　　局域网具有不同的拓扑结构．在总线网络中，任何时刻只允许一台机器发送数据，其他所有奇迹处于接受状态．当两台或多台机器想要同时发送数据时必须进行仲裁，仲裁机制可以是集中式也可以是分布式．&lt;strong&gt;以太网是基于共享总线采用分布控制机制的局域网．&lt;/strong&gt;在环形网中，数据沿着环不停地旋转．&lt;/p&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读，计算机网络" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
