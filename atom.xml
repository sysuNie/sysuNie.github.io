<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sysuNie</title>
  
  <subtitle>Gotta to change</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-18T14:15:59.580Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JiKang Nie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode</title>
    <link href="http://yoursite.com/2017/12/18/leetcode/"/>
    <id>http://yoursite.com/2017/12/18/leetcode/</id>
    <published>2017-12-18T14:00:54.000Z</published>
    <updated>2017-12-18T14:15:59.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h2><h3 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h3><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Given nums = [2, 7, 11, 15], target = 9,</div><div class="line"></div><div class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line">return [0, 1].</div></pre></td></tr></table></figure><a id="more"></a><p><strong>思路</strong></p><p>题意是让你从给定的数组中找到两个元素的和为指定值的两个索引，<strong>利用HashMap作为存储，键为目标值减去当前元素值，索引为值</strong>，比如<code>i = 0</code>时，此时首先要判断<code>nums[0] = 2</code>是否在map中，如果不存在，那么插入键值对<code>key = 9 - 2 = 7, value = 0</code>，之后当<code>i = 1</code>时，此时判断<code>nums[1] = 7</code>已存在于map中，那么取出该<code>value = 0</code>作为第一个返回值，当前<code>i</code>作为第二个返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">int</span> len = nums.length;　　　　<span class="comment">//数组长度</span></div><div class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="comment">//新建HashMap</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;len; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;　　　　<span class="comment">//遍历数组中的元素是否在HashMap中</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(nums[i]),i&#125;;</div><div class="line">            &#125;</div><div class="line">            map.put(target - nums[i],i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26 Remove Duplicates from Sorted Array"></a>26 Remove Duplicates from Sorted Array</h3><p>Given a sorted array, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="external"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p>For example,<br>Given input array <em>nums</em> = <code>[1,1,2]</code>,</p><p>Your function should return length = <code>2</code>, with the first two elements of <em>nums</em> being <code>1</code> and <code>2</code> respectively. It doesn’t matter what you leave beyond the new length.</p><p><strong>思路</strong></p><p>题意是让你从一个有序的数组中移除重复的元素，并返回之后数组的长度。我的思路是：首先判断如果数组长度等于0的话直接返回原长度即可，否则的话遍历一遍数组，用一个<code>index</code>变量指向尾部，如果后面的元素和前面的元素不同，就让<code>index</code>变量加1，最后返回<code>index</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = nums.size();    <span class="comment">//输出数组长度</span></div><div class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> len;</div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;　　　　　　 <span class="comment">//index</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;　　　　<span class="comment">//遍历数组</span></div><div class="line">            <span class="keyword">if</span>(nums[index]!=nums[i])&#123;　　</div><div class="line">                nums[++index] = nums[i];  <span class="comment">//判断后面的元素是否和前面的相同</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> index+<span class="number">1</span>;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27 Remove Element"></a>27 Remove Element</h3><p>Given an array and a value, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="external"><strong>in-place</strong></a> and return the new length.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Given nums = [3,2,2,3], val = 3,</div><div class="line"></div><div class="line">Your function should return length=2, with the first two elements of nums being 2.</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是移除数组中值等于<code>val</code>的元素，并返回之后数组的长度，并且题目中指定空间复杂度为O(1)，我的思路是用<code>index</code>标记尾部，遍历该数组时当索引元素不等于<code>val</code>时，<code>index</code>加一，尾部指向当前元素，最后返回<code>index</code>即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i]!= val)&#123;</div><div class="line">                nums[index++]=nums[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> index;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33 Search in Rotated Sorted Array"></a>33 Search in Rotated Sorted Array</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p><p><strong>思路</strong></p><p>题意是让你从一个旋转过后的递增序列中寻找给定值，找到返回索引，找不到返回-1，我们在下面这组数据中寻找规律。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1 2 4 5 6 7 0</div><div class="line">2 4 5 6 7 0 1</div><div class="line">4 5 6 7 0 1 2</div><div class="line">5 6 7 0 1 2 4</div><div class="line">6 7 0 1 2 4 5</div><div class="line">7 0 1 2 4 5 6</div></pre></td></tr></table></figure><p>由于是旋转一次，所以肯定有一半及以上的序列仍然是具有递增性质的，我们观察到如果中间的数比左面的数大的话，那么左半部分序列是递增的，否则右半部分就是递增的，那么我们就可以确定给定值是否在递增序列中，从而决定取舍哪半边。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right = nums.size();</div><div class="line">        <span class="keyword">while</span>(left != right)&#123;</div><div class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</div><div class="line">            <span class="keyword">if</span>(nums[left]&lt;=nums[mid])&#123;</div><div class="line">                <span class="keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;=nums[mid])&#123;</div><div class="line">                    right = mid;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    left = mid+<span class="number">1</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[right<span class="number">-1</span>])&#123;</div><div class="line">                    left = mid+<span class="number">1</span>;</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    right = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15 3Sum"></a>15 3Sum</h3><p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">For example, given array S = [-1, 0, 1, 2, -1, -4],</div><div class="line"></div><div class="line">A solution set is:</div><div class="line">[</div><div class="line">  [-1, 0, 1],</div><div class="line">  [-1, -1, 2]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是让你从数组中找出所有三个和为0的元素构成的非重复序列，这样的话我们可以把数组先做下排序，然后遍历这个排序数组，用两个指针分别指向当前元素的下一个和数组尾部，判断三者和与0的大小来移动两个指针，其中细节操作就是注意去重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i&lt;nums.length-<span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>, right = nums.length-<span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</div><div class="line">                <span class="keyword">int</span> sum = nums[i]+nums[left]+nums[right];</div><div class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</div><div class="line">                    list.add(Arrays.asList(nums[i],nums[left++],nums[right--]));</div><div class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left-<span class="number">1</span>]) ++left;</div><div class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>]) --right;</div><div class="line">                    </div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span> ) ++left;</div><div class="line">                <span class="keyword">else</span> --right;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(nums[i] == nums[++i] &amp;&amp; i&lt;nums.length -<span class="number">2</span>);</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16. 3Sum Closest"></a>16. 3Sum Closest</h3><p>Given an array <em>S</em> of <em>n</em> integers, find three integers in <em>S</em> such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.</div><div class="line"></div><div class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是让我们求最接近给定值的三数之和，是在之前那道3Sum三数之和的基础上又增加了些许难度，那么这道题让我们返回这个最接近于给定值的值，即我们要保证当前三数和跟给定值之间的差的绝对值最小，所以我们需要定义一个变量Ａ用来记录差的绝对值，然后我们还是要先将数组排个序，然后开始遍历数组，思路跟那道三数之和很相似，都是先确定一个数，然后用两个指针left和right来滑动寻找另外两个数，每确定两个数，我们求出此三数之和，然后算和给定值的差的绝对值存在newＡ中，然后和Ａ比较并更新Ａ和结果closest即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> closest = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>];</div><div class="line">        <span class="keyword">int</span> A = <span class="built_in">abs</span>(closest-target);</div><div class="line">        sort(nums.begin(),nums.end());</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-2</span>; i++)&#123;</div><div class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>, right = nums.size()<span class="number">-1</span>;</div><div class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</div><div class="line">                <span class="keyword">int</span> sum = nums[i]+nums[left]+nums[right];</div><div class="line">                <span class="keyword">int</span> newA = <span class="built_in">abs</span>(sum-target);</div><div class="line">                <span class="keyword">if</span>(A&gt;newA)&#123;</div><div class="line">                    A = newA;</div><div class="line">                    closest = sum;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(sum&lt;target) ++left;</div><div class="line">                <span class="keyword">else</span> --right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> closest;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a>53. Maximum Subarray</h3><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p><p>For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br>the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.</p><p><strong>思路</strong></p><p>题意是求数组中子数组的最大和，利用动态规划的方法去求解。当部分序列和大于0的话就一直加下一个元素，并和当前最大值进行比较，如果出现部分序列小于０，那就需要从当前元素算起。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = nums.size(), init = nums[<span class="number">0</span>], max = init;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</div><div class="line">            init = nums[i]+(init&gt;<span class="number">0</span> ? init:<span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span>(init&gt;max) max = init;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38. Count and Say"></a>38. Count and Say</h3><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.     1</div><div class="line">2.     11</div><div class="line">3.     21</div><div class="line">4.     1211</div><div class="line">5.     111221</div></pre></td></tr></table></figure><p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2</code>, then <code>one 1&quot;</code> or <code>1211</code>.</p><p>Given an integer <em>n</em>, generate the <em>n</em>th term of the count-and-say sequence.</p><p>Note: Each term of the sequence of integers will be represented as a string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 1</div><div class="line">Output: &quot;1&quot;</div></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 4</div><div class="line">Output: &quot;1211&quot;</div></pre></td></tr></table></figure><h3 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h3><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>思想</strong></p><p>题意是用一个新链表来合并两个已排序的链表，那我们只需要从头开始比较已排序的两个链表，新链表指针每次指向值小的节点，依次比较下去，最后，当其中一个链表到达了末尾，我们只需要把新链表指针指向另一个没有到末尾的链表此时的指针即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * public class ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</div><div class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode tmp = head;</div><div class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</div><div class="line">                tmp.next = l1;</div><div class="line">                l1 = l1.next;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                tmp.next = l2;</div><div class="line">                l2 = l2.next;</div><div class="line">            &#125;</div><div class="line">            tmp = tmp.next;</div><div class="line">        &#125;</div><div class="line">        tmp.next = l1 !=<span class="keyword">null</span> ? l1:l2;</div><div class="line">        <span class="keyword">return</span> head.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h3><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>题意是让你从字符串数组中找出公共前缀，我的想法是找出最短的那个字符串的长度<code>minLen</code>，然后在<code>0...minLen</code>的范围比较所有字符串，如果比较到有不同的字符，那么直接返回当前索引长度的字符串即可，否则最后返回最短的字符串即可。</p><h3 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h3><p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and <em>n</em> is at least 2.</p><p><strong>思路</strong></p><p>木桶的容积取决于短板的高度。首先计算最左边（left）和最右边（right）组成的木桶的面积，并把它设置为maxArea。在left&lt;right的情况下，首先判断height[left]和height[right]值的大小，若height[left]&lt;height[right]，则height取值向右边移动，同时计算每移动一步后新的Area的面积并与maxArea做比较，得出新的最大面积；反之，则height取值向左边移动，重复上一步操作。最终得到最大的区域积。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right =height.size()<span class="number">-1</span>; </div><div class="line">        <span class="keyword">int</span> maxArea = (right-left)*min(height[left],height[right]);</div><div class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</div><div class="line">            <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</div><div class="line">                left++;</div><div class="line">                <span class="keyword">int</span> Area1 = (right-left)*min(height[left],height[right]);</div><div class="line">                <span class="keyword">if</span>(Area1&gt;maxArea)&#123;</div><div class="line">                    maxArea = Area1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                right--;</div><div class="line">                <span class="keyword">int</span> Area2 = (right-left)*min(height[left],height[right]);</div><div class="line">                <span class="keyword">if</span>(Area2&gt;maxArea)&#123;</div><div class="line">                    maxArea = Area2;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxArea;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="14-Longest-Common-Prefix-1"><a href="#14-Longest-Common-Prefix-1" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h3><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p><strong>思路</strong></p><p>题意是编写一个函数来查找字符串数组中最长的公共前缀字符串。利用纵向扫描，对每一个位置比较所以字符串，直到遇到一个不匹配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(strs.empty()) <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx&lt;strs[<span class="number">0</span>].size(); idx++)&#123;  <span class="comment">//纵向扫描数组</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;strs.size(); i++)&#123;</div><div class="line">                <span class="keyword">if</span>(strs[i][idx] != strs[<span class="number">0</span>][idx]) <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>,idx);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//strs = ['make fun','make love','main idea'];</span></div><div class="line"><span class="comment">//strs[0] = 'make fun' thus idx (0~8);</span></div><div class="line"><span class="comment">//strs.size() = 3; </span></div><div class="line"><span class="comment">//strs[i][idx],strs[0][idx]中，保持idx不变，比较纵列是否相同。</span></div><div class="line"><span class="comment">//strs[0].substr(0,idx)　substr(截取开始位置,截取长度)。</span></div></pre></td></tr></table></figure><h3 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a>9. Palindrome Number</h3><p>Determine whether an integer is a palindrome. Do this without extra space.</p><p><strong>Some hints:</strong></p><p>Could negative integers be palindromes? (ie, -1)</p><p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p><p>You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?</p><p>There is a more generic way of solving this problem.</p><p><strong>思路</strong></p><p>题意是判断一个有符号整型数是否是回文，也就是逆序过来的整数和原整数相同，首先负数肯定不是，接下来我们直接算出他的回文数，然后和给定值比较即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">int</span> s = x, reverse = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(s&gt;<span class="number">0</span>)&#123;</div><div class="line">            reverse = reverse*<span class="number">10</span>+s%<span class="number">10</span>;</div><div class="line">            s/=<span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> x == reverse;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//reverse = 1      reverse = 12      reverse=123      reverse=1234</span></div><div class="line"><span class="comment">//reverse = 12344  reverse = 123443  reverse=1234432  reverse=12344321</span></div></pre></td></tr></table></figure><h3 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35. Search Insert Position"></a>35. Search Insert Position</h3><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [1,3,5,6], 5</div><div class="line">Output: 2</div></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [1,3,5,6], 2</div><div class="line">Output: 1</div></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [1,3,5,6], 7</div><div class="line">Output: 4</div></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [1,3,5,6], 0</div><div class="line">Output: 0</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是给定一个有序数组和一个目标值，如果找到目标，则返回索引。如果没有，则返回按顺序插入的索引。解题思路：首先遍历数组，若当前数字大于或等于目标值，则返回当前坐标，如果遍历结束了，说明目标值比数组中任何一个数都要大，则返回数组长度n即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i]&gt;=target) <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums.size();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48.  Rotate Image"></a>48.  Rotate Image</h3><p>You are given an <em>n</em> x <em>n</em> 2D matrix representing an image.</p><p>Rotate the image by 90 degrees (clockwise).</p><p><strong>Note:</strong><br>You have to rotate the image <strong>in-place</strong>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Given input matrix = </div><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [4,5,6],</div><div class="line">  [7,8,9]</div><div class="line">],</div><div class="line"></div><div class="line">rotate the input matrix in-place such that it becomes:</div><div class="line">[</div><div class="line">  [7,4,1],</div><div class="line">  [8,5,2],</div><div class="line">  [9,6,3]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Given input matrix =</div><div class="line">[</div><div class="line">  [ 5, 1, 9,11],</div><div class="line">  [ 2, 4, 8,10],</div><div class="line">  [13, 3, 6, 7],</div><div class="line">  [15,14,12,16]</div><div class="line">], </div><div class="line"></div><div class="line">rotate the input matrix in-place such that it becomes:</div><div class="line">[</div><div class="line">  [15,13, 2, 5],</div><div class="line">  [14, 3, 4, 1],</div><div class="line">  [12, 6, 8, 9],</div><div class="line">  [16, 7,10,11]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是给定一个n*n个2维矩阵来表示一个图。在原矩阵上旋转图形90°。主要思路是，首先沿着矩阵副对角线翻转一次，然后沿着水平线翻转一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i, j, temp;</div><div class="line">        <span class="keyword">int</span> n = matrix.size();</div><div class="line">        # 沿着矩阵副对角线翻转</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n-i; ++j)&#123;</div><div class="line">                temp = matrix[i][j];</div><div class="line">                matrix[i][j] = matrix[n-j<span class="number">-1</span>][n-i<span class="number">-1</span>];</div><div class="line">                matrix[n-j<span class="number">-1</span>][n-i<span class="number">-1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        # 沿着水平线翻转</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n/<span class="number">2</span>; ++i)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</div><div class="line">                temp = matrix[i][j];</div><div class="line">                matrix[i][j] = matrix[n-i<span class="number">-1</span>][j];</div><div class="line">                matrix[n-i<span class="number">-1</span>][j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="34-Search-for-a-Range"><a href="#34-Search-for-a-Range" class="headerlink" title="34. Search for a Range"></a>34. Search for a Range</h3><p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p><p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p><p>If the target is not found in the array, return <code>[-1, -1]</code>.</p><p>For example,<br>Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>return <code>[3, 4]</code>.</p><p><strong>思路</strong></p><p>题意是给定按升序排序的整数数组，找到给定目标值的开始和结束位置。其中算法的运行时复杂度必须按照O（log n）的顺序。如果在数组中找不到目标，则返回[-1，-1]。首先，建立二元结果数组Ａ，左边left,右边right。二分法求左边界：当中点小于target，left移向中点，否则right移向中点；先判断左边，再判断右边是否等于target，如果是，赋值给Ａ[0]。二分法求右边界：当中点大于target，right移向中点，否则left移向中点；先判断右边，再判断左边是否等于target，如果是，赋值给Ａ[1]。返回Ａ。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">int</span>[] A = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right = n-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(nums[left]&lt;nums[right])&#123;</div><div class="line">            <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid]&lt;target) left = mid+<span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target) right = mid-<span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">if</span>(nums[left]&lt;target) left++;</div><div class="line">                <span class="keyword">if</span>(nums[right]&gt;target) right--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(nums[left] == target)&#123;</div><div class="line">            A[<span class="number">0</span>] = left;</div><div class="line">            A[<span class="number">1</span>] = right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> A;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66. Plus One"></a>66. Plus One</h3><p>Given a non-negative integer represented as a <strong>non-empty</strong> array of digits, plus one to the integer.</p><p>You may assume the integer do not contain any leading zero, except the number 0 itself.</p><p>The digits are stored such that the most significant digit is at the head of the list.</p><p><strong>思路</strong></p><p>题意是给定一个数组表示非负整数，其高位在数组的前面，对这个整数加1。使用大数加法，遍历数组的每一位，同时处理进位，如果最后还有进位，则在数组最前面插入１即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</div><div class="line">        <span class="keyword">int</span> c = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> n = digits.size();</div><div class="line">      　＃ 遍历数组的每一位</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</div><div class="line">            <span class="keyword">int</span> a = digits[i]+c;</div><div class="line">            digits[i] = a % <span class="number">10</span>;</div><div class="line">          　<span class="comment">// 做进位处理</span></div><div class="line">            c = a/<span class="number">10</span>; </div><div class="line">            <span class="comment">// 用于判断最后是否还有进位，值为０或１．</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(c == <span class="number">1</span>)&#123;</div><div class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</div><div class="line">            <span class="comment">// 在数组最前面插入１．</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> digits;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h3><p>Say you have an array for which the $i^{th}$ element is the price of a given stock on day <em>i</em>.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: [7, 1, 5, 3, 6, 4]</div><div class="line">Output: 5</div><div class="line"></div><div class="line">max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</div></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: [7, 6, 4, 3, 1]</div><div class="line">Output: 0</div><div class="line"></div><div class="line">In this case, no transaction is done, i.e. max profit = 0.</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是假设有一个数组，数组中的元素是第i天给定股票的价格，如果最多只能完成最多一笔交易（买入或者卖出一股股票），设计一个算法来找到最大的利润值。首先初始化利润值为０，假定当前的最小值cur_min为数组中的第一个数值，遍历当前数组，取初始化利润值与prices[i]-cur_min中较大值作为新的profit，取cur_min和prices[i]中较小的值作为新的cur_min，迭代最终得到最大的profit。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = prices.size();</div><div class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>; <span class="comment">// 初始化利润值.</span></div><div class="line">        <span class="keyword">int</span> cur_min = prices[<span class="number">0</span>];  <span class="comment">// 当前的最小股票值</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">            profit = max(profit, prices[i]-cur_min);</div><div class="line">            cur_min = min(cur_min, prices[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> profit;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h3><p>Say you have an array for which the $i^{th}$ element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><p><strong>思路</strong></p><p>题意是设计一个算法来找到最大的利润，可以根据需要完成尽可能多的交易（即多次买入和卖出一次股票）。但是不可以同时进行多笔交易（即您必须在再次购买之前出售股票）。因为买一次接着卖一次，所以只要计算买卖一次的利润值，对利润值大于０的进行求和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = prices.size();</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++)&#123;</div><div class="line">            <span class="keyword">int</span> profit = prices[i]-prices[i<span class="number">-1</span>];</div><div class="line">            <span class="keyword">if</span>(profit&gt;<span class="number">0</span>) sum += profit;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118.  Pascal’s Triangle"></a>118.  Pascal’s Triangle</h3><p>Given <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p><p>For example, given <em>numRows</em> = 5,<br>Return</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">     [1],</div><div class="line">    [1,1],</div><div class="line">   [1,2,1],</div><div class="line">  [1,3,3,1],</div><div class="line"> [1,4,6,4,1]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是生成帕斯卡三角形，我们可以发现，从第三行开始，该行中的值等于上一行的左上角和右上角之和，利用这个规律进行求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="comment">//在vector&lt;vector&lt;int&gt;&gt;中，因为vector是一个容器，最外层的vector容器中放着更小的             vector，而里层的vector里面放的是int型的数字。所以我们首先要对里层的vector容器赋           值，然后再把里层的vector作为元素插入到外层的vector中。</span></div><div class="line">        <span class="keyword">if</span>(numRows == <span class="number">0</span>) <span class="keyword">return</span> result; </div><div class="line">        result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">1</span>));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=numRows; i++)&#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; current(i,<span class="number">1</span>);  <span class="comment">//本行</span></div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pre = result[i<span class="number">-2</span>]; <span class="comment">//　上一行</span></div><div class="line">            </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i<span class="number">-1</span>; j++)&#123;</div><div class="line">                current[j] = pre[j<span class="number">-1</span>]+pre[j];　<span class="comment">//左上角和右上角之和</span></div><div class="line">            &#125;</div><div class="line">            result.push_back(current);　<span class="comment">//在vector类中作用为在vector尾部加入一个数据</span></div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="119. Pascal’s Triangle II"></a>119. Pascal’s Triangle II</h3><p>Given an index <em>k</em>, return the $k^th$ row of the Pascal’s triangle.</p><p>For example, given <em>k</em> = 3, Return <code>[1,3,3,1]</code>.</p><p><strong>思路</strong></p><p>题意是生成帕斯卡三角形中的某一列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=rowIndex; i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;<span class="number">0</span>; j--)&#123;</div><div class="line">                <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j<span class="number">-1</span>]+<span class="built_in">array</span>[j];</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">array</span>.push_back(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">array</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h3><p>Given a <strong>set</strong> of candidate numbers (<strong>C</strong>) <strong>(without duplicates)</strong> and a target number (<strong>T</strong>), find all unique combinations in <strong>C</strong> where the candidate numbers sums to <strong>T</strong>.</p><p>The <strong>same</strong> repeated number may be chosen from <strong>C</strong> unlimited number of times.</p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>For example, given candidate set <code>[2, 3, 6, 7]</code> and target <code>7</code>,<br>A solution set is: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [7],</div><div class="line">  [2, 2, 3]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意：给定一个正数集合和一个目标数，求出所有的子集合，使子集的和为target，要求子集合递增排列，且不包含重复的子集合，子集合中的数字可以重复。我们需要写一个递归函数，在这个函数中需要添加三个变量，result记录最终的结果，path记录中间的一个解，start记录当前递归到的下标。调用递归函数时，target要减去当前数组的数，为了减小计算量，进行相应的剪枝处理，即大于target,就减去。数组中的那个值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</div><div class="line">        sort(candidates.begin(), candidates.end());</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result; <span class="comment">//final result</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;   <span class="comment">// path result</span></div><div class="line">        combsum(candidates, path, result, target, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combsum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;     <span class="comment">// find the suitable solution</span></div><div class="line">            result.push_back(path);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;candidates.size(); i++)&#123;</div><div class="line">            <span class="keyword">if</span>(target&lt;candidates[i]) <span class="keyword">return</span> ;   <span class="comment">//pruning</span></div><div class="line">            </div><div class="line">            path.push_back(candidates[i]);</div><div class="line">            combsum(candidates, path, result, target-candidates[i],i);</div><div class="line">            path.pop_back();    </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a>40. Combination Sum II</h3><p>Given a collection of candidate numbers (<strong>C</strong>) and a target number (<strong>T</strong>), find all unique combinations in <strong>C</strong> where the candidate numbers sums to <strong>T</strong>.</p><p>Each number in <strong>C</strong> may only be used <strong>once</strong> in the combination.</p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>For example, given candidate set <code>[10, 1, 2, 7, 6, 1, 5]</code> and target <code>8</code>,<br>A solution set is: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [1, 7],</div><div class="line">  [1, 2, 5],</div><div class="line">  [2, 6],</div><div class="line">  [1, 1, 6]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意：给定一个正数集合和一个目标数，求出所有的子集合，使子集的和为target，要求子集合递增排列，且不包含重复的子集合，子集合中的数字也不可以重复。与上一个题目差不多，需要加一个判断，如果上一轮循环已经使用candidates[i]，本次循环就不能再选candidates[i]，确保candidates[i]最多循环一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</div><div class="line">        sort(candidates.begin(), candidates.end());</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</div><div class="line">        combsum(candidates, path, result, target, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combsum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</div><div class="line">            result.push_back(path);</div><div class="line">            <span class="keyword">return</span> ;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> previous = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;candidates.size(); i++)&#123;</div><div class="line">            <span class="comment">// if previous loop has used candidates[i], </span></div><div class="line">            <span class="comment">// in this loop candidates[i] can not be used</span></div><div class="line">            <span class="keyword">if</span>(previous == candidates[i]) <span class="keyword">continue</span>;    </div><div class="line">            <span class="keyword">if</span>(target&lt;candidates[i]) <span class="keyword">return</span> ;  <span class="comment">//pruning</span></div><div class="line">            </div><div class="line">            previous = candidates[i];</div><div class="line">            </div><div class="line">            path.push_back(candidates[i]);</div><div class="line">            combsum(candidates, path, result, target-candidates[i], i+<span class="number">1</span>);</div><div class="line">            path.pop_back();</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;leetcode&quot;&gt;&lt;a href=&quot;#leetcode&quot; class=&quot;headerlink&quot; title=&quot;leetcode&quot;&gt;&lt;/a&gt;leetcode&lt;/h2&gt;&lt;h3 id=&quot;1-Two-Sum&quot;&gt;&lt;a href=&quot;#1-Two-Sum&quot; class=&quot;headerlink&quot; title=&quot;1. Two Sum&quot;&gt;&lt;/a&gt;1. Two Sum&lt;/h3&gt;&lt;p&gt;Given an array of integers, return &lt;strong&gt;indices&lt;/strong&gt; of the two numbers such that they add up to a specific target.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have &lt;strong&gt;exactly&lt;/strong&gt; one solution, and you may not use the &lt;em&gt;same&lt;/em&gt; element twice.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Given nums = [2, 7, 11, 15], target = 9,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Because nums[0] + nums[1] = 2 + 7 = 9,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;return [0, 1].&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程，leetcode" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%EF%BC%8Cleetcode/"/>
    
  </entry>
  
  <entry>
    <title>Forward Neural Network</title>
    <link href="http://yoursite.com/2017/12/17/Forward%20Neural%20Network/"/>
    <id>http://yoursite.com/2017/12/17/Forward Neural Network/</id>
    <published>2017-12-17T12:57:56.157Z</published>
    <updated>2017-12-17T12:57:56.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深度学习应用于自然语言处理-前向神经网络"><a href="#深度学习应用于自然语言处理-前向神经网络" class="headerlink" title="深度学习应用于自然语言处理-前向神经网络"></a>深度学习应用于自然语言处理-前向神经网络</h2><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>深度学习的浪潮袭来，现已在各个领域中应用。深度学习的表现令人叹为观止，不得不说我们迎来了依靠深度学习的人工智能学习时代。</p><blockquote><p>　人工智能，让世界更美好。</p></blockquote><p>这一章主要是通过学习 <a href="http://cs224d.stanford.edu/" target="_blank" rel="external">Stanford cs224d</a> 课程已经阅读一些有些的博客所作出的总结。</p><a id="more"></a><h2 id="本章介绍"><a href="#本章介绍" class="headerlink" title="本章介绍"></a>本章介绍</h2><p>从数学的角度对前向神经网络数学模型进行介绍、推导和证明。</p><h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><p><a href="http://cs229.stanford.edu/section/cs229-linalg.pdf" target="_blank" rel="external">线性代数(Linear Algebra)</a><br><a href="http://cs229.stanford.edu/section/cs229-prob.pdf" target="_blank" rel="external">概率论(Probability Theory)</a><br><a href="http://cs229.stanford.edu/section/cs229-cvxopt.pdf" target="_blank" rel="external">凸优化(Convex Optimization)</a></p><h2 id="前向神经网络"><a href="#前向神经网络" class="headerlink" title="前向神经网络"></a>前向神经网络</h2><p>所谓神经网络就是将许多个单一“神经元”联结在一起，这样，一个“神经元”的输出就可以是另一个“神经元”的输入。以下是一个简单的<strong>三层前向全连接神经网络：</strong></p><p><img src="http://oddpnmpll.bkt.clouddn.com/2016-10-18-14%3A47%3A20.jpg" alt="neural networks"></p><p>图中<strong>x</strong>为输入层，<strong>h</strong>为隐藏层，$\hat{y}$为输出层。在全连接网络中，上一层和下一层的每个神经元都相连。隐藏层在接收到输入x后会进行一个非线性变化，再将输出信号传递给下一层。非线性变换由激活函数(activation function)实现。在数学上，我们可以用矩阵乘法（Matrix multiplication）来解释:</p><script type="math/tex; mode=display">\begin{align*}\boldsymbol{h} &= \text{sigmoid}(\boldsymbol{xW}_1+\boldsymbol{b}_1)\\\boldsymbol{\hat{y}} &= \text{softmax}(\boldsymbol{hW}_2+\boldsymbol{b}_2)\\\end{align*}</script><p>式中<strong>sigmoid</strong>和<strong>softmax</strong>都是一个激活函数,<strong>W</strong>是指两层之间的权重，<strong>b</strong>是偏置量。我们可以看到<strong>x</strong>进行了线性变换后，再做非线性变换，<strong>x</strong>输出的信号将作为<strong>b</strong>的输入。</p><h3 id="激活函数-Activation-fuction"><a href="#激活函数-Activation-fuction" class="headerlink" title="激活函数(Activation fuction)"></a>激活函数(Activation fuction)</h3><p>激活函数的作用是能够给神经网络加入一些非线性因素，使得神经网络可以更好地解决较为复杂的问题。激活函数的缺点是如果模型比较复杂，面对样本数不大的情况时容易出现<a href="http://blog.csdn.net/artprog/article/details/51278643" target="_blank" rel="external"><strong>过拟合</strong></a>。常用的激活函数还有<strong>tanh函数</strong>，<strong>RelU函数</strong>等等。</p><p><strong>sigmoid</strong>函数的数学形式：</p><script type="math/tex; mode=display">\sigma(x) = \dfrac{1}{1+e^{-x}}</script><p><strong>sigmoid</strong>函数求导：</p><script type="math/tex; mode=display">\sigma '(x)= \dfrac{e^{-x}}{(1+e^{-x})^2}=(1-\sigma)\sigma</script><p><strong>sigmoid</strong>函数和导数python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></div><div class="line">  x = <span class="number">1.</span>/(<span class="number">1</span>+np.exp(-x))</div><div class="line">  <span class="keyword">return</span> x</div><div class="line"><span class="comment"># grad</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_grad</span><span class="params">(f)</span>:</span></div><div class="line">  f = f*(<span class="number">1</span>-f)</div><div class="line">  <span class="keyword">return</span> f</div></pre></td></tr></table></figure><p><strong>softmax</strong>函数的数学形式：</p><script type="math/tex; mode=display">\text{softmax}(z_i) = \dfrac{e^{z_i}}{\sum_{j=1}^{c} e^{z_j}}      \quad 假设a_i=\text{softmax}(z_i)</script><p><strong>softmax</strong>函数求导：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial a_i}{\partial z_i}&=-\dfrac{e^{z_i}(\sum_{j} e^{z_j})-e^{z_i}e^{z_i}}{(\sum_{j} e^{z_j})^2}\\&=-\dfrac{e^{z_i}}{\sum_{j} e^{z_j}}+(\dfrac{e^{z_i}}{\sum_{j} e^{z_j}})^2\\&= a_i(1-a_i)\end{align*}</script><p><strong>softmax函数</strong>的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy</div><div class="line"><span class="comment"># 输出softmax函数值，输入向量或矩阵x</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(x.shape)&gt;<span class="number">1</span>:</div><div class="line">        max = np.max(x,axis=<span class="number">1</span>)[:,np.newaxis]</div><div class="line">        x -= max</div><div class="line">        x = np.exp(x)</div><div class="line">        softmax_deno = np.sum(x, axis=<span class="number">1</span>)[:,np.newaxis]</div><div class="line">        x = x/softmax_deno</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        max = np.max(x)</div><div class="line">        x -= max</div><div class="line">        x = np.exp(x)</div><div class="line">        softmax_deno = np.sum(x)</div><div class="line">        x = x/softmax_deno</div><div class="line">    <span class="keyword">return</span> x</div></pre></td></tr></table></figure><h3 id="目标函数-Objective-fuction"><a href="#目标函数-Objective-fuction" class="headerlink" title="　目标函数(Objective fuction)"></a>　目标函数(Objective fuction)</h3><p>目标函数，有时候又称<strong>损失函数（loss function），代价函数（cost function ）</strong>，是网络中的性能参数，也是编译一个模型必须的两个参数之一。在训练模型时，我们的最终目标就是最大化或者最小化目标函数，用$J$表示目标函数。</p><script type="math/tex; mode=display">\arg\min_{\theta}\ J</script><h4 id="交叉熵-Cross-entropy"><a href="#交叉熵-Cross-entropy" class="headerlink" title="交叉熵(Cross entropy)"></a>交叉熵(Cross entropy)</h4><p>一种常见的目标函数形式：</p><script type="math/tex; mode=display">J = -\sum_{i}y_i\log{\hat{y}_i}</script><p>其中$i$代表响应的类别，$y_i$是训练样本中的标签，而$\hat{y}_i$模型预测结果。</p><p>一般情况下，我们对$y_i$使用<strong>one-hot</strong>编码，而$\hat{y}$代表了对应类别的概率$p(y_i|w,x)$，因此，$\sum_i\hat{y_i}=1$,在这里我们称$y_i$为预测函数。</p><p>*对$\hat{y}$求导：    </p><script type="math/tex; mode=display">\dfrac{\partial{J}}{\partial{\hat{y}_i}}=-\dfrac{y_i}{\hat{y}_i}</script><p>对向量$\hat{\boldsymbol{y}}=(\hat{y}_1,\ \dots\ ,\hat{y}_c)$求导：</p><script type="math/tex; mode=display">\dfrac{\partial{J}}{\partial\hat{\boldsymbol{y}}}=(-\dfrac{y_1}{\hat{y}_1},\ \dots\ ,-\dfrac{y_c}{\hat{y}_c})</script><h3 id="预测函数-Predict-function"><a href="#预测函数-Predict-function" class="headerlink" title="　预测函数(Predict function)"></a>　预测函数(Predict function)</h3><p>对于预测函数$\hat{y}_i$,我们取$\hat{y}_i$最大的$i$作为模型最终预测的类别。使用softmax函数对输出层的输入进行归一化操作，数学表示为：</p><script type="math/tex; mode=display">\hat{y_i}=p(y_i|w,x)=\dfrac{e^{z_i}}{\sum_{j=1}^{c} e^{z_j}}</script><p>其中$c$表示类别个数，在这里即是输出层的神经元个数。$z_i$为输出层的输入。</p><p>根据softmax函数的求导可知，预测函数$\hat{y}_i$对$z_i$求导：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial \hat{y_i}}{\partial z_i} &= -\hat{y_i}(1-\hat{y_i})\\\dfrac{\partial \hat{y_k}}{\partial z_i} &= -\hat{y_k}\hat{y_i}\end{align*}</script><p>根据链式法则，目标函数$J$对$z_i$求导：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial J}{\partial z_i} &=\dfrac{\partial J}{\partial \hat{y_1}} \dfrac{\partial \hat{y_1}}{\partial z_i}+\dots+ \dfrac{\partial J}{\partial \hat{y_c}} \dfrac{\partial \hat{y_c}}{\partial z_i}\\&= y_1\hat{y_i}+\dots+y_i(\hat{y_i}-1)+\dots+y_c\hat{y_i}\\&=\hat{y}_i\sum_{j=1}^cy_c-y_i\\&=\hat{y}_i-y_i\end{align*}</script><p>目标函数$J$对向量$z$求导：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial J}{\partial \boldsymbol{z}} = {\boldsymbol{y}}-{\hat{\boldsymbol{y}}}\end{align*}</script><h3 id="前向传播-Forward-propagation"><a href="#前向传播-Forward-propagation" class="headerlink" title="前向传播(Forward propagation)"></a>前向传播(Forward propagation)</h3><p><strong>前向传播是求目标函数值的过程</strong>，从输入层开始，样本的特征向量$x$遍历模型，到达输出层$\hat{y}$，再将$\hat{y}$和  $y$进行比较，得到目标函数值$J$： </p><script type="math/tex; mode=display">\begin{align*}\boldsymbol{h} &= sigmoid(\boldsymbol{xW}_1+\boldsymbol{b}_1)\\\boldsymbol{\hat{y}} &= sigmoid(\boldsymbol{hW}_2+\boldsymbol{b}_2)\\J &= -\sum_{i}y_i\log{\hat{y}_i}\end{align*}</script><p>训练模型的过程就是优化目标函数的过程，我们需要最小化$J=J(\boldsymbol{W}_1,\boldsymbol{b}_1,\boldsymbol{W}_2,\boldsymbol{b_2})$,这歌优化过程我们可以使用<a href="http://www.cnblogs.com/pinard/p/5970503.html" target="_blank" rel="external">梯度下降法</a>,但是由于$J$是一个非凸函数，因此不能使用梯度下降法求得全局最优，也就是不能获得的$J$最小值。</p><h3 id="随机梯度下降-Stochastic-gradient-descent"><a href="#随机梯度下降-Stochastic-gradient-descent" class="headerlink" title="随机梯度下降(Stochastic gradient descent)"></a>随机梯度下降(Stochastic gradient descent)</h3><p>我们可以求目标函数的梯度，它代表目标函数变化增加最快的地方。相反，沿着梯度相反的方向，梯度减少最快，所以我们可以使用迭代的方法更新参数，使得目标函数往着最优的方向进行优化，找到目标函数的最小值：</p><script type="math/tex; mode=display">\boldsymbol{g}^{(t)} = \dfrac{\partial{J}}{\partial{\boldsymbol{W}^{(t)}}}\\\boldsymbol{W}^{(t+1)} =\boldsymbol{W}^{(t)}+ \alpha\boldsymbol{g}^{(t)}</script><p>$t$表示第$t$次进行迭代更新，$\alpha$表示学习率，代表着每一次迭代要走的步长，$Ｗ$表示我们需要更新的参数，在本例子中，我们需要对$W_1$,$b_2$,$W_2$,$b_2$进行参数更新，每次迭代都需要进行梯度的计算，每次迭代都要计算目标函数的值。</p><p>假设训练样本数量为$N$，如果每次迭代都使用所有的训练样本。这时的目标函数是：</p><script type="math/tex; mode=display">\mathbb{J}=\mathbb{E}(J)=\dfrac{1}{N}\sum_nJ_n</script><p>当$N$很大的时候，每次迭代都十分耗时，因此收敛的速度会较慢。我们可以使用一种逼近方法，称为<strong>mini-batch</strong>。</p><ul><li><strong>mini-batch</strong>很简单，就是每次迭代更新只使用$k$个训练样本，$k$可以是100这种相对较小的数。</li><li>而<strong>随机梯度下降(SGD)</strong>是每次更新迭代只使用$1$个训练样本，即$k=1$。<strong>SGD</strong>是<strong>mini-batch</strong>的特殊情况，但是我们一般说<strong>SGD</strong>就是指<strong>mini-batch</strong>。</li></ul><h3 id="后向传播-Backward-propagation"><a href="#后向传播-Backward-propagation" class="headerlink" title="后向传播(Backward propagation)"></a>后向传播(Backward propagation)</h3><p><strong>后向传播就是一个求梯度的过程</strong>从输出层开始往输入层传入误差。</p><p>我们将三层全连接神经网络模型的前向传播表示为：</p><script type="math/tex; mode=display">\begin{align*}&\boldsymbol{z}_1 = \boldsymbol{xW_1}+\boldsymbol{b}_1\\&\boldsymbol{h} = {\text sigmoid}(\boldsymbol{z}_1)\\&\boldsymbol{z}_2 = \boldsymbol{xW_2}+\boldsymbol{b}_2\\&\hat{\boldsymbol{y}} = softmax(\boldsymbol{z}_2)\\&J = -\sum_{i}y_i\log{\hat{y}_i}\end{align*}</script><p>计算后向传播：</p><script type="math/tex; mode=display">\begin{align*}&\boldsymbol{\delta}_1 = \dfrac{\partial J}{\partial \boldsymbol{z}_2} = \hat{\boldsymbol{y}}-\boldsymbol{y}\\&\boldsymbol{\delta}_2 = \dfrac{\partial J}{\partial \boldsymbol{h}} = \boldsymbol{\delta}_1\dfrac{\partial \boldsymbol{z}_2}{\partial \boldsymbol{h}} =\boldsymbol{\delta}_1\boldsymbol{W}^T_2 \\&\boldsymbol{\delta}_3 = \dfrac{\partial J}{\partial \boldsymbol{z}_1} = \boldsymbol{\delta}_2\dfrac{\partial \boldsymbol{h}}{\partial \boldsymbol{z}_1} =\boldsymbol{\delta}_2*\sigma'(\boldsymbol{z}_1) \\&\boldsymbol{\delta}_4 = \dfrac{\partial J}{\partial \boldsymbol{x}} = \boldsymbol{\delta}_3\dfrac{\partial \boldsymbol{z}_1}{\partial \boldsymbol{x}} =\boldsymbol{\delta}_3\boldsymbol{W}^T_1 \\\end{align*}</script><p>$\boldsymbol{\delta}_1$就是预测误差，得到上面传播的误差，我们对每一层的参数求梯度：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial J}{\partial \boldsymbol{W}_2}&= \boldsymbol{\delta}_1 \dfrac{\partial\boldsymbol{z}_2 }{\partial \boldsymbol{W}_2} = \boldsymbol{h}^T\boldsymbol{\delta}_1\\\dfrac{\partial J}{\partial \boldsymbol{b}_2} &= \boldsymbol{\delta}_1 \dfrac{\partial\boldsymbol{z}_2 }{\partial \boldsymbol{b}_2} = \boldsymbol{\delta}_1\\\dfrac{\partial J}{\partial \boldsymbol{W}_1} &= \boldsymbol{\delta}_3 \dfrac{\partial\boldsymbol{z}_1 }{\partial \boldsymbol{W}_1} = \boldsymbol{x}^T\boldsymbol{\delta}_3\\\dfrac{\partial J}{\partial \boldsymbol{b}_1} &= \boldsymbol{\delta}_3 \dfrac{\partial\boldsymbol{z}_1 }{\partial \boldsymbol{b}_1} = \boldsymbol{\delta}_3\\\end{align*}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;深度学习应用于自然语言处理-前向神经网络&quot;&gt;&lt;a href=&quot;#深度学习应用于自然语言处理-前向神经网络&quot; class=&quot;headerlink&quot; title=&quot;深度学习应用于自然语言处理-前向神经网络&quot;&gt;&lt;/a&gt;深度学习应用于自然语言处理-前向神经网络&lt;/h2&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;深度学习的浪潮袭来，现已在各个领域中应用。深度学习的表现令人叹为观止，不得不说我们迎来了依靠深度学习的人工智能学习时代。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;　人工智能，让世界更美好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一章主要是通过学习 &lt;a href=&quot;http://cs224d.stanford.edu/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stanford cs224d&lt;/a&gt; 课程已经阅读一些有些的博客所作出的总结。&lt;/p&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>词向量</title>
    <link href="http://yoursite.com/2017/12/17/word-embedding/"/>
    <id>http://yoursite.com/2017/12/17/word-embedding/</id>
    <published>2017-12-17T12:04:30.000Z</published>
    <updated>2017-12-17T12:58:15.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自然语言处理－词向量"><a href="#自然语言处理－词向量" class="headerlink" title="自然语言处理－词向量"></a>自然语言处理－词向量</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在计算机视觉中，作为输入的图片可以直接数值化。在语言识别中，作为输入的语音也可以直接数值化。而在自然语言处理中，我们无法将文字直接数值化，为了能够让计算机处理文字，我们需要将文字映射到一个数值空间。由于词是组成语义的基本单位，所以对词的表述就显得尤为重要，我们把词的数值（表征）表示为<strong>Word Representation</strong>，一般来说，词向量经常指<strong>Word Embedding</strong>，也称<strong>Distributed Word Representation</strong>。</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>从<strong>Word Representation</strong>的发展过程引入<strong>Word Embedding</strong>，先从简单的SVD介绍开始，再到NNLM,word2vec等词向量模型。</p><h3 id="one-hot编码"><a href="#one-hot编码" class="headerlink" title="one-hot编码"></a>one-hot编码</h3><p>one-hot编码也称独热编码，这是一种简单的词表征方式，每个词使用一个$R^{|V|}$的向量表示，$|V|$表示词表的大小。</p><script type="math/tex; mode=display">w^{address}=\begin{bmatrix}1\\0\\0\\\vdots\\0\end{bmatrix},w^{home}=\begin{bmatrix}0\\1\\0\\\vdots\\0\end{bmatrix},w^{at}=\begin{bmatrix}0\\0\\1\\\vdots\\0\end{bmatrix}</script><p>使用one-hot编码的词向量之间是相互独立的，因为对于每个词$(w^{i})^{T}w^j = 0$，这种编码方式并没有编码不同词之间的语义相似性。</p><a id="more"></a><h3 id="基于矩阵分解的词表征"><a href="#基于矩阵分解的词表征" class="headerlink" title="基于矩阵分解的词表征"></a>基于矩阵分解的词表征</h3><h4 id="词–文档矩阵-Word-Document-Matrix"><a href="#词–文档矩阵-Word-Document-Matrix" class="headerlink" title="词–文档矩阵(Word-Document Matrix)"></a>词–文档矩阵(Word-Document Matrix)</h4><p>如果我们有大量的文档，我们用一个矩阵来存储所有文档的词频信息。矩阵的行向量代表词，列向量代表文档，每个元素代表词在文档中出现的频数，比如我们现在有两篇文档：</p><p>$I \quad love \quad NLP \ I \quad love \quad deep \quad learningI$</p><p>经过统计次数，我们可以得到以下矩阵：</p><script type="math/tex; mode=display">\boldsymbol{X} = \begin{array}{c}&\tiny{d_1}&\tiny{d_2}\\\begin{array}{c}\tiny{I} \\\tiny{love} \\\tiny{NLP} \\\tiny{deep} \\\tiny{learning} \\\end{array}\left.\right[&\begin{array}{c}1 \\ 1 \\ 1 \\ 0 \\ 0\end{array}&\begin{array}{c}1 \\ 1 \\ 0 \\ 1 \\ 1\end{array}&\left.\right]\end{array}</script><p>如果两个文档有相似的主题，那么两个文档的列向量会趋于有相似类型的词数量。该模型主要用于衡量文档主题的相似性。</p><h4 id="基于窗口的词共现矩阵-Window-based-Co-occurrence-Matrix"><a href="#基于窗口的词共现矩阵-Window-based-Co-occurrence-Matrix" class="headerlink" title="基于窗口的词共现矩阵(Window based Co-occurrence Matrix)"></a>基于窗口的词共现矩阵(Window based Co-occurrence Matrix)</h4><p>给定一个词，计算在一个限定大小的窗口中出现的其他词的次数。我们将这些计数放在一个矩阵中，矩阵的行表示词，列也是词。假如窗口大小为1，我们需要计算当前词左右两边的两个词。比如,我们两个句子：</p><p>$I \quad love \quad NLP \ I \quad love \quad deep \quad learningI$</p><p>窗口长度为１，我们得到的矩阵为：</p><script type="math/tex; mode=display">\boldsymbol{X} = \begin{array}{c}&\tiny{I}&\tiny{love}&\tiny{NLP}&\tiny{deep}&\tiny{learning}\\\begin{array}{c}\tiny{I} \\\tiny{love} \\\tiny{NLP} \\\tiny{deep} \\\tiny{learning} \\\end{array}\left.\right[&\begin{array}{c}0 \\ 2 \\ 0 \\ 0 \\ 0\end{array}&\begin{array}{c}2 \\ 0 \\ 1 \\ 1 \\ 0\end{array}&\begin{array}{c}0 \\ 1 \\ 0 \\ 0 \\ 0\end{array}&\begin{array}{c}0 \\ 1 \\ 0 \\ 0 \\ 1\end{array}&\begin{array}{c}0 \\ 0 \\ 0 \\ 1 \\ 0\end{array}&\left.\right]\end{array}</script><p>以看到矩阵是对称矩阵，可以行或者列作为词表征。这个矩阵的意义在于假如两个词有相似的context则偏向于有相似的意思，也就是说相似的词有相似的词表征。</p><h4 id="SVD-Singular-Value-Decomposition"><a href="#SVD-Singular-Value-Decomposition" class="headerlink" title="SVD(Singular Value Decomposition)"></a>SVD(Singular Value Decomposition)</h4><p><strong>SVD，奇异值矩阵分解</strong>。对于任意一个矩阵$X$都可以做奇异值分解：</p><script type="math/tex; mode=display">\boldsymbol{X}_{m\times n}=\boldsymbol{U}_{m\times m}\boldsymbol{S}_{m\times n}\boldsymbol{V}^T_{n\times n}</script><p>其中$U$和$V$都是正交矩阵，$S$只有对角元素：</p><script type="math/tex; mode=display">\boldsymbol{S} = \begin{bmatrix}\boldsymbol{S}_1 & \boldsymbol{O}\\\boldsymbol{O} & \boldsymbol{O}\\\end{bmatrix}，\boldsymbol{S}_1=\begin{bmatrix}\sigma_1 &0&\dots&0\\0&\sigma_2 &&\vdots\\\vdots&&\ddots&0\\0&\dots&0&\sigma_r\end{bmatrix}</script><p>其中$\sigma_1…\sigma_r$是矩阵$X$的奇异值。</p><h4 id="LSA-Latent-Semantic-Analysis"><a href="#LSA-Latent-Semantic-Analysis" class="headerlink" title="LSA(Latent Semantic Analysis)"></a>LSA(Latent Semantic Analysis)</h4><p>上述描述的两种矩阵中，都存在一个明显的问题－当出现大量的文档和词的时候，我们得到的矩阵会十分庞大，而且会出现矩阵稀疏问题。后来，有人为了提高相似度的计算准确度，提出了对矩阵进行SVD分解，可以得到更好的词表征。这种方法称为<strong>LSA，潜在语义分析</strong>。LSA是为了研究词表征，另外还有类似的研究文档表征的方法叫<strong>LSI(Latent Semantic Index)</strong>。 我们通过计数统计得到了词-文档矩阵或者词共现矩阵$X$，然后对矩阵$X$使用SVD，取最大的$k$个奇异值，由于每个奇异值对应于$U$的列，因此得到$\hat{\boldsymbol{U}}_{n\times k}$，每一行代表一个词表征，因此可以得到$k$维的词表征。</p><p>优点：降低矩阵稀疏度　减少噪声</p><p>缺点：有新词或新的语料出现，矩阵需要重新计算　矩阵维度高　</p><p>　　　矩阵过于稀疏，很多词无法共现　会出现过高或过低的词频</p><p><strong>Word Embedding</strong> 出现解决了上述问题。</p><h3 id="基于迭代的词表征-词向量"><a href="#基于迭代的词表征-词向量" class="headerlink" title="基于迭代的词表征(词向量)"></a>基于迭代的词表征(词向量)</h3><p>迭代的词表征得到的是一个稠密的向量，与矩阵分解不同的是，词向量是通过迭代训练模型得到。</p><h4 id="NNLM"><a href="#NNLM" class="headerlink" title="NNLM"></a>NNLM</h4><p>这个<a href="http://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf" target="_blank" rel="external">模型</a>是由Bengio大神于2003年发表，可以说是Neural Language Model的开山之作。本来作者的主要目的是建立语言模型，结果发现了词向量这种副产品，由此引发了后人对词向量的火热研究。</p><p>模型使用了一个简单的前向神经网络，如下图所示： <img src="../../Pictures/datastructure/language_model_bengio.jpg" alt="language_model_bengio"></p><p>该模型通过上下文来预测下一个单词，图中所示的输入为上文的各个词$w_i$，然后将他们的词向量$C(w_i)$连接起来，输出是每个词的概率$P(w_t|content)$，虚线表示的是词向量层和输出层的直接连接。</p><h4 id="Word2vec"><a href="#Word2vec" class="headerlink" title="Ｗord2vec"></a>Ｗord2vec</h4><p>Ｗord2vec这个工具，是Tomas Mikolov在Google的时候开发的用来训练词向量的工具。Ｗord2vec这个工具中有两个模型（CBOW、Skip-Gram），还有两种加速训练的trick（层次Softmax、负采样），下面分别一一讲述。</p><ul><li>$w$表示词</li><li>$x$表示one-hot编码</li><li>$u$和$v$表示词向量</li><li>$x(w)$表示one-hot编码中对应词$w$位置的值，取值为0或1，只有一个位置上的值为1。</li></ul><h5 id="CBOW-Continuous-Bag-of-word-Model"><a href="#CBOW-Continuous-Bag-of-word-Model" class="headerlink" title="CBOW(Continuous Bag-of-word Model)"></a>CBOW(Continuous Bag-of-word Model)</h5><p>模型的网络结构如下：</p><p><img src="../../Pictures/datastructure/cbow.jpg" alt="cbow"></p><p><strong>说明</strong>: </p><p>模型中存在两套词向量。</p><p>一套称为Input词向量，用矩阵$V<em>{|V|\times d}=(v_1,\dots,v</em>{|V|})$表示，|V|指的是词表大小，ｄ指词向量维度</p><p>一套称为Output词向量，用矩阵$U<em>{|V|\times d}=(v_1,\dots,v</em>{|V|})$表示</p><p><strong>建模过程</strong></p><ul><li><p>确定一个窗口大小m</p></li><li><p>选定目标词位置t。得到该位置的上下文：</p><script type="math/tex; mode=display">(w^{(t−m)},...,w^{(t−1)},w^{(t+1)},...,w^{(t+m)})</script></li><li><p>得到上下文各个词的one-hot表示：</p><script type="math/tex; mode=display">(x^{(t−m)},...,x^{(t−1)},x^{(t+1)},...,x^{(t+m)})</script></li><li><p>使用矩阵$V$，计算$v = Vx$得到上下文的词向量（对于图中的<strong>INPUT层</strong>）</p><script type="math/tex; mode=display">(v^{(t−m)},...,v^{(t−1)},v^{(t+1)},...,v^{(t+m)})</script></li><li><p>将上下文的词向量相加或者平均，得到。<strong>（对应图中的PROJECTION层）</strong>： </p><script type="math/tex; mode=display">\hat{v} = \dfrac{v^{(t−m)}+\dots+v^{(t−1)}+v^{(t+1)}+\dots+v^{(t+m)}}{2m}</script></li><li><p>使用矩阵$U$，计算目的词的概率分布<strong>（对应图中的OUTPUT层）</strong>:</p><script type="math/tex; mode=display">P(w \mid w^{(t−m)},...,w^{(t−1)},w^{(t+1)},...,w^{(t+m)})=\text{softmax}(U\hat{v})=\dfrac{e^{u\hat{v}}}{\sum\limits_{u_i\in U}{e^{u_i\hat{v}}}}</script></li><li><p>使用负对数似然（又称交叉熵）损失函数$J$：</p><script type="math/tex; mode=display"><Empty \space Math \space Block></script><script type="math/tex; mode=display">\begin{align*}    J &= -\sum_{w} x^t(w)\log P(w \mid w^{(t−m)},...,w^{(t−1)},w^{(t+1)},...,w^{(t+m)})\\    &= -\log P(w^t \mid w^{(t−m)},...,w^{(t−1)},w^{(t+1)},...,w^{(t+m)})    \end{align*}</script></li></ul><p><strong>训练过程</strong></p><ul><li><p>选取batch的大小n</p></li><li><p>使用SGD训练，对于每个训练样本的损失函数$J_i$，构造batch的损失函数：</p><script type="math/tex; mode=display">J_{batch} = \sum_i^n J_i</script></li><li><p>每一轮迭代更新$U$和$V$</p></li></ul><h5 id="Skip-Gram-Continuous-Skip-gram-Model"><a href="#Skip-Gram-Continuous-Skip-gram-Model" class="headerlink" title="Skip-Gram(Continuous Skip-gram Model)"></a>Skip-Gram(Continuous Skip-gram Model)</h5><p>既然可以用上下文来预测目标词，反过来也能用目标词来预测上下文，Skip-Gram因此应运而生。</p><p><img src="../../Pictures/datastructure/Skip-Gram.jpg" alt="Skip-Gram"></p><p>与CBOW一样，模型中存在两套词向量$U$和$V$。</p><p><strong>建模过程</strong></p><ul><li><p>确定Context的窗口大小$m$。</p></li><li><p>选取一个目标词$w^t$，然后在目标词的Context中的选择一个词$w^c$，组成训练样本： </p><script type="math/tex; mode=display">(w^t, w^c)</script></li><li><p>得到训练样本one-hot表示为：$(x^t,x^c)$</p></li><li><p>使用矩阵$V$，得到目标词的词向量<strong>（对应图中INPUT层）</strong>：$v^t = c^tV$</p></li><li><p>由于只有一个词，所以不需要相加或者平均，直接复制到下一层<strong>（对应PROJECTION层）</strong>： $\hat{v} = v^t$</p></li><li><p>使用矩阵$U$，计算上下文中的词的概率分布<strong>（对应图中的OUTPUT层）</strong>： </p><script type="math/tex; mode=display">P(w \mid w^t) = \text{softmax}(U\hat{v}) = \dfrac{e^{u\hat{v}}}{\sum\limits_{u_i\in U}{e^{u_i\hat{v}}}}</script></li><li><p>使用负对数似然（又称交叉熵）损失函数$J$：</p><script type="math/tex; mode=display">J = -\sum_{w} x^c(w)\log P(w \mid w^t) = -\log P(w^c \mid w^t)</script></li></ul><p><strong>训练过程</strong></p><ul><li><p>选取batch的大小n</p></li><li><p>使用SGD训练，对于每个训练样本的损失函数$J_i$，构造batch的损失函数：</p><script type="math/tex; mode=display">J_{batch} = \sum_i^n J_i</script></li><li><p>每一轮迭代更新$U$和$V$</p></li></ul><h5 id="加速技巧"><a href="#加速技巧" class="headerlink" title="加速技巧"></a>加速技巧</h5><p>Word2vec的训练是无监督的，我们只需要分好词，在训练的时候像有监督一样进行梯度下降。因此，在训练模型的时候，我们需要同时更新$U$和$V$。</p><p>从公式可以看出，每次迭代只需要更新矩阵中的少量向量（Skip-Gram中是一个）。然而如果我们使用简单的Softmax，我们就要每次都更新整个$U$，假如词表大小到达千万级以上，可想而知这是多么耗时。因此，我们需要一些Trick来加速训练。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自然语言处理－词向量&quot;&gt;&lt;a href=&quot;#自然语言处理－词向量&quot; class=&quot;headerlink&quot; title=&quot;自然语言处理－词向量&quot;&gt;&lt;/a&gt;自然语言处理－词向量&lt;/h2&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在计算机视觉中，作为输入的图片可以直接数值化。在语言识别中，作为输入的语音也可以直接数值化。而在自然语言处理中，我们无法将文字直接数值化，为了能够让计算机处理文字，我们需要将文字映射到一个数值空间。由于词是组成语义的基本单位，所以对词的表述就显得尤为重要，我们把词的数值（表征）表示为&lt;strong&gt;Word Representation&lt;/strong&gt;，一般来说，词向量经常指&lt;strong&gt;Word Embedding&lt;/strong&gt;，也称&lt;strong&gt;Distributed Word Representation&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;从&lt;strong&gt;Word Representation&lt;/strong&gt;的发展过程引入&lt;strong&gt;Word Embedding&lt;/strong&gt;，先从简单的SVD介绍开始，再到NNLM,word2vec等词向量模型。&lt;/p&gt;
&lt;h3 id=&quot;one-hot编码&quot;&gt;&lt;a href=&quot;#one-hot编码&quot; class=&quot;headerlink&quot; title=&quot;one-hot编码&quot;&gt;&lt;/a&gt;one-hot编码&lt;/h3&gt;&lt;p&gt;one-hot编码也称独热编码，这是一种简单的词表征方式，每个词使用一个$R^{|V|}$的向量表示，$|V|$表示词表的大小。&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
w^{address}=\begin{bmatrix}
1\\0\\0\\\vdots\\0
\end{bmatrix},w^{home}=\begin{bmatrix}
0\\1\\0\\\vdots\\0
\end{bmatrix},w^{at}=\begin{bmatrix}
0\\0\\1\\\vdots\\0
\end{bmatrix}&lt;/script&gt;&lt;p&gt;使用one-hot编码的词向量之间是相互独立的，因为对于每个词$(w^{i})^{T}w^j = 0$，这种编码方式并没有编码不同词之间的语义相似性。&lt;/p&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="word_embedding" scheme="http://yoursite.com/tags/word-embedding/"/>
    
  </entry>
  
  <entry>
    <title>王家卫电影台词</title>
    <link href="http://yoursite.com/2017/12/17/Wong/"/>
    <id>http://yoursite.com/2017/12/17/Wong/</id>
    <published>2017-12-17T09:05:26.000Z</published>
    <updated>2017-12-17T11:47:48.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="东邪西毒"><a href="#东邪西毒" class="headerlink" title="东邪西毒"></a>东邪西毒</h2><p>从小我就懂得保护自己，我知道要想不被人拒绝，最好的办法就是先拒绝别人。<br>我曾经听人说过，当你不可以再拥有的时候。你唯一可以做的，就是让自己不要忘记。<br>你越想忘记一个人时，其实你越会记得他。人的烦恼就是记性太好，如果可以把所有事都忘掉，以后每一日都是个新开始，你说多好。<br>每个人都会经过这个阶段，见到一座山，就想知道山后面是什么。我很想告诉他，可能翻过山后面，你会发现没什么特别。回望之下，可能会觉得这一边更好。<br>多年之后，我有个绰号叫西毒，任何人都可以变得狠毒，只要你尝试过什么叫做嫉妒。<br>其实“醉生梦死”只不过是她跟我开的一个玩笑，你越想知道自己是不是忘记的时候，你反而记得更清楚。我曾经听人说过，当你不能够再拥有，你唯一可以做的，就是令自己不要忘记。<br>知不知道饮酒和饮水有什么区别？酒越饮越暖，水越喝越寒。</p><a id="more"></a><p>有些人是离开之后，才会发现离开了的人才是自己的最爱。<br>每个人都会坚持自己的信念，在别人来看是浪费时间，她却觉得很重要。<br>不久前，我遇上一个人，送给我一坛酒，她说那叫“醉生梦死”，喝了之后，可以叫你忘掉以前做过的任何事。我很奇怪，为什么会有这样的酒。她说人最大的烦恼，就是记性太好，如果什么都可以忘掉，以后的每一天将会是一个新的开始，那你说这有多开心。<br>虽然我很喜欢她，但是我不想让她知道，因为我明白得不到的东西永远是最好的。每次她凝望着那小孩子，我知道她心里其实在想另一个人。我很妒忌欧阳峰，我很想知道被人喜欢的感觉是怎样的，结果我伤害了很多人。<br>有些事情你越想忘记，就会记得越牢。当有些事情你无法得到时，你惟一能做的，就是不要忘记。<br>以前我认为那句话很重要 因为我觉得有些话说出来就是一生一世 现在想一想 说不说也没有什么分别 有些事会变的。<br>以前也这么想，但是看着他一天天长大，我知道他早晚会离开我。现在我觉得什么都无所谓啦。以前我认为那句话很重要，因为我觉得有些话说出来就是一生一世，现在想一想，说不说也没有什么分别，有些事会变的。我一直以为是我自己赢了，直到有一天看着镜子，才知道自己输了，在我最美好的时候，我最喜欢的人都不在我身边。如果能重新开始那该多好啊！<br>我曾经问过自己，你最喜欢的女人是不是我，现在我已经不想再知道啦。如果有一天我忍不住问起，你一定要骗我，就算你心里有多么不愿意，也不要告诉我你最喜欢的人不是我。<br>我知道那个人不会再来，可是我还是再等。我在门口坐了两天两夜，看着天空在不断的变化，我才发现原来我到这里这么久，却从来没有看清楚这片天空。<br>告诉你，你这样看着我，可是非常有危险的。因为你随时可能爱上我。<br>每个人都会坚持自己的信念，在别人来看是浪费时间，她却觉得很重要。</p><h2 id="春光乍泄"><a href="#春光乍泄" class="headerlink" title="春光乍泄"></a>春光乍泄</h2><p>一直以为我跟何宝荣不一样，原来寂寞的时候，所有的人都一样。<br>我终于来到瀑布，我突然想起何宝荣，我觉得好难过，我始终认为站在这儿的应该是两个人。<br>一个人可以假装开心，但声音就装不了，仔细一听就知道了。<br>跟他接近得多了，我什么也听不到，只听见自己的心在跳，不知他可有听到？<br>我终于明白，他为什么那么开心在外面走来走去，是因为他知道自己有个地方让他回去。<br>很多事情我都没有告诉何宝荣，我并不希望他赶快好起来，他受伤的那段日子，是我们最快乐的时光。<br>愈是期待愈是美丽来让这夜春光代替难道要等青春全枯萎 至得到一切<br>黎耀辉，不如我们由头来过吧。</p><h2 id="重庆森林"><a href="#重庆森林" class="headerlink" title="重庆森林"></a>重庆森林</h2><p>我和她接近的时候，我们之间的距离只有0.01公分，我对她一无所知，57个小时之后，我爱上了她。<br>每天你都有机会和很多人擦身而过，而你或者对他们一无所知，不过也许有一天他会变成你的朋友或是知己， 我是一个警察，我的名字叫何志武，编号223。<br>每个人都有失恋的时候，而每一次我失恋呢，我就会去跑步，因为跑步可以将你身体里面的水分蒸发掉，而让我不那么容易流泪，我怎么可以流泪呢？在阿美的心中里面，我可是一个很酷的男人。<br> 从分手的那一天开始，我每天买一罐5月1号到期的凤梨罐头，因为凤梨是阿美最爱吃的东西，而5月1号是我的生日。 我告诉我自己，当我买满30罐的时候， 她如果还不回来，这段感情就会过期。<br>不知道从什么时候开始，在什么东西上面都有个日期，秋刀鱼会过期，肉罐头会过期，连保鲜纸都会过期，我开始怀疑，在这个世界上，还有什么东西是不会过期的？<br>在1994年的5月1号，有一个女人跟我讲了一声“生日快乐”，因为这一句话，我会一直记住这个女人。如果记忆也是一个罐头的话，我希望这罐罐头不会过期；如果一定要加一个日子的话，我希望她是一万年。<br>其实了解一个人并不代表什么，人是会变的，今天他喜欢凤梨，明天他可以喜欢别的。<br>不知道什么时候开始，我变成一个很小心的人，每次我穿雨衣的时候，我都会戴太阳眼镜，你永远都不会知道什么时候会下雨，什么时候出太阳。<br>我没有想到她说的休息就是真正的休息，整个晚上我看了两套粤语长片，吃了四次厨师沙拉。当天差不多快亮的时候，我知道我该走了。在我要走的时候，我帮她脱了鞋子。我记得我妈说过，如果女人穿着高跟鞋睡觉，第二天会脚肿。她昨天晚上一定是走了很长的路，象她这样漂亮的女人，高跟鞋应该是要很干净的才对。<br>有时候，耳朵比眼睛还重要，很多东西用耳朵听比用眼睛看好，一个人可以假装开心，但声音就装不了，仔细一听就知道了。<br>不知道是我忘了关水龙头，还是房子越来越有感情。我一直以为它是最坚强的，没想到它哭得最厉害。一个人哭，你只需要给他一包纸巾，可是一个房子哭，你可要做多很多功夫。<br>那天下午我做了个梦，我到了他的家，走出那房子的时候，我以为我会醒来，谁知道，原来有些梦是永远不会醒的。<br>看着它哭的时候，我很开心，因为它外表好像改变了，可是它的本质没有变，它依然是一条感情丰富的毛巾。<br>也对，宵夜都有那么多选择，何况男朋友。</p><h2 id="花样年华"><a href="#花样年华" class="headerlink" title="花样年华"></a>花样年华</h2><p>那是一种难堪的相对。她一直低着头，给他一个接近的机会。他没有勇气接近，她掉转头，走了……<br> 我从来没有想到，婚姻会这么复杂。还以为一个人，做的好就行了。可是两个人在一起，单是自己做的好是不够的。<br>其实我跟你一样。只是我不去想。又不是我的错，为什么老是问自己做错什么，何必浪费时间呢。我不想这样下去。<br>如果我有一张船票，你，会不会跟我走？<br>那些消失了的岁月，仿佛隔着一块积着灰尘的玻璃，看得到，抓不着。他一直在怀念着过去的一切。如果他能冲破那块积着灰尘的玻璃，他会走回早已消失的岁月。<br>本来我也这么想，所以不怕别人说什么，我相信自己不会跟他们一样，可是原来我会。<br>以前的人，心中如果有什么不可告人的秘密，他们会跑到山上，找一棵树，在树上挖一个洞，然后把秘密全说进去，再用泥巴把洞封上，那秘密就会永远留在那棵树里，没有人会知道。<br>如果我有一张船票，你，会不会跟我走？</p><h2 id="阿飞正传"><a href="#阿飞正传" class="headerlink" title="阿飞正传"></a>阿飞正传</h2><p>我听别人说这世界上有一种鸟是没有脚的，它只能够一直的飞呀飞呀，飞累了就在风里面睡觉，这种鸟一辈子只能下地一次，那一次就是它死亡的时候。<br>十六号，四月十六号。一九六零年四月十六号下午三点之前的一分钟你和我在一起，因为你我会记住这一分钟。从现在开始我们就是一分钟的朋友，这是事实，你改变不了，因为已经过去了。我明天会再来。<br>我以前以为一分钟很快就会过去，其实是可以很长的。有一天有个人指着手表跟我说，他说会因为那一分钟而永远记住我，那时候我觉得很动听……但现在我看着时钟，我就告诉自己，我要从这一分钟开始忘掉这个人。</p><h2 id="堕落天使"><a href="#堕落天使" class="headerlink" title="堕落天使"></a>堕落天使</h2><p>当你年轻时，以为什么都有答案，可是老了的时候，你可能又觉得其实人生并没有所谓的答案。每天你都有机会和很多人擦身而过，有些人可能会变成你的朋友或者是知己，所以我从来没有放弃任何跟人磨擦的机会。有时候搞得自己头破血流，管他呢！开心就行了。<br>跟一个人合作久了，你的习惯或多或少会受他的影响。虽然我很熟悉这种香水，可是我怎么也不习惯从别的女人身上闻到。<br>做拍档，除了要了解她外，还要给机会让她了解你。<br>有些人是不适合太接近的，知道得太多反而没有兴趣。我是一个很现实的人，我知道怎样可以让自己更加快乐。</p><h2 id="一代宗师"><a href="#一代宗师" class="headerlink" title="一代宗师"></a>一代宗师</h2><p>念念不忘，必有回响。<br>叶里藏花一度，梦里踏雪几回。<br>人生如棋，落子无悔。<br>有时候我昨天遇到一个人，感觉他非常有意思，印象深刻。但后来就再也碰不上了，人生就是这样。</p><script type="math/tex; mode=display">从此只有眼前路，没有身后身。</script><p>我在最好的时候碰到你,是我的运气。可惜我没时间了。想想,说人生无悔,都是赌气的话。人生若无悔,那该多无趣啊。我心里有过你。可我也只能到喜欢为止了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;东邪西毒&quot;&gt;&lt;a href=&quot;#东邪西毒&quot; class=&quot;headerlink&quot; title=&quot;东邪西毒&quot;&gt;&lt;/a&gt;东邪西毒&lt;/h2&gt;&lt;p&gt;从小我就懂得保护自己，我知道要想不被人拒绝，最好的办法就是先拒绝别人。&lt;br&gt;我曾经听人说过，当你不可以再拥有的时候。你唯一可以做的，就是让自己不要忘记。&lt;br&gt;你越想忘记一个人时，其实你越会记得他。人的烦恼就是记性太好，如果可以把所有事都忘掉，以后每一日都是个新开始，你说多好。&lt;br&gt;每个人都会经过这个阶段，见到一座山，就想知道山后面是什么。我很想告诉他，可能翻过山后面，你会发现没什么特别。回望之下，可能会觉得这一边更好。&lt;br&gt;多年之后，我有个绰号叫西毒，任何人都可以变得狠毒，只要你尝试过什么叫做嫉妒。&lt;br&gt;其实“醉生梦死”只不过是她跟我开的一个玩笑，你越想知道自己是不是忘记的时候，你反而记得更清楚。我曾经听人说过，当你不能够再拥有，你唯一可以做的，就是令自己不要忘记。&lt;br&gt;知不知道饮酒和饮水有什么区别？酒越饮越暖，水越喝越寒。&lt;/p&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="书名" scheme="http://yoursite.com/tags/%E4%B9%A6%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>springMVC</title>
    <link href="http://yoursite.com/2017/11/04/springMVC/"/>
    <id>http://yoursite.com/2017/11/04/springMVC/</id>
    <published>2017-11-04T11:00:32.000Z</published>
    <updated>2017-12-17T11:53:12.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="springMVC-框架原理"><a href="#springMVC-框架原理" class="headerlink" title="springMVC 框架原理"></a>springMVC 框架原理</h2><h3 id="前端控制器-DispatcherServlet"><a href="#前端控制器-DispatcherServlet" class="headerlink" title="前端控制器(DispatcherServlet)"></a>前端控制器(DispatcherServlet)</h3><p>接受请求，响应结果，相当于转发器，中央处理器。</p><p>有了DispatcherServlet减少了其他组件之间的耦合度。</p><h3 id="处理器映射器-HandlerMapping"><a href="#处理器映射器-HandlerMapping" class="headerlink" title="处理器映射器(HandlerMapping)"></a>处理器映射器(HandlerMapping)</h3><p>根据请求的url查找Handler。</p><h3 id="处理器适配器-HandlerAdapter"><a href="#处理器适配器-HandlerAdapter" class="headerlink" title="处理器适配器(HandlerAdapter)"></a>处理器适配器(HandlerAdapter)</h3><p>按照特定的规则(HandlerAdapter要求的规则)去执行Handler。</p><p>注意：编写Handler需要按照HandlerAdapter的要求去做，这样适配器才能正确的执行Handler。</p><h3 id="视图解析器-View-resolver"><a href="#视图解析器-View-resolver" class="headerlink" title="视图解析器(View resolver)"></a>视图解析器(View resolver)</h3><p>进行视图解析，根据逻辑视图解析成真正的视图（view）</p><a id="more"></a><p>第一步：发起请求到前端控制器(DispatcherServlet)。</p><p>第二步：前端控制器请求HandlerMapping查找handler(根据xml配置或注解查找)</p><p>第三步：处理器映射器HandlerMapping向前端控制器返回Handler</p><p>第四步：向前端控制器调用处理器适配器执行Handler</p><p>第五步：处理器适配器开始执行Handler</p><p>第六步：Handler执行完给处理器适配器返回Model and View</p><p>第七步：处理器适配器向前端控制器返回Model and View(springMVC框架底层对象)</p><p>第八步：前端控制器请求视图解析器去进行视图解析(根据逻辑视图名解析成真正的视图jsp)</p><p>第九步：视图解析器向前端控制器返回View</p><p>第十步：前端控制器进行视图渲染，视图渲染将模型数据(在Model and View对象中)填充到request域</p><p>第十一步：前端控制器向用户响应结果</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;springMVC-框架原理&quot;&gt;&lt;a href=&quot;#springMVC-框架原理&quot; class=&quot;headerlink&quot; title=&quot;springMVC 框架原理&quot;&gt;&lt;/a&gt;springMVC 框架原理&lt;/h2&gt;&lt;h3 id=&quot;前端控制器-DispatcherServlet&quot;&gt;&lt;a href=&quot;#前端控制器-DispatcherServlet&quot; class=&quot;headerlink&quot; title=&quot;前端控制器(DispatcherServlet)&quot;&gt;&lt;/a&gt;前端控制器(DispatcherServlet)&lt;/h3&gt;&lt;p&gt;接受请求，响应结果，相当于转发器，中央处理器。&lt;/p&gt;
&lt;p&gt;有了DispatcherServlet减少了其他组件之间的耦合度。&lt;/p&gt;
&lt;h3 id=&quot;处理器映射器-HandlerMapping&quot;&gt;&lt;a href=&quot;#处理器映射器-HandlerMapping&quot; class=&quot;headerlink&quot; title=&quot;处理器映射器(HandlerMapping)&quot;&gt;&lt;/a&gt;处理器映射器(HandlerMapping)&lt;/h3&gt;&lt;p&gt;根据请求的url查找Handler。&lt;/p&gt;
&lt;h3 id=&quot;处理器适配器-HandlerAdapter&quot;&gt;&lt;a href=&quot;#处理器适配器-HandlerAdapter&quot; class=&quot;headerlink&quot; title=&quot;处理器适配器(HandlerAdapter)&quot;&gt;&lt;/a&gt;处理器适配器(HandlerAdapter)&lt;/h3&gt;&lt;p&gt;按照特定的规则(HandlerAdapter要求的规则)去执行Handler。&lt;/p&gt;
&lt;p&gt;注意：编写Handler需要按照HandlerAdapter的要求去做，这样适配器才能正确的执行Handler。&lt;/p&gt;
&lt;h3 id=&quot;视图解析器-View-resolver&quot;&gt;&lt;a href=&quot;#视图解析器-View-resolver&quot; class=&quot;headerlink&quot; title=&quot;视图解析器(View resolver)&quot;&gt;&lt;/a&gt;视图解析器(View resolver)&lt;/h3&gt;&lt;p&gt;进行视图解析，根据逻辑视图解析成真正的视图（view）&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>HTML知识点</title>
    <link href="http://yoursite.com/2017/10/11/html/"/>
    <id>http://yoursite.com/2017/10/11/html/</id>
    <published>2017-10-11T12:30:52.000Z</published>
    <updated>2017-12-17T11:52:57.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="HTML文档结构"><a href="#HTML文档结构" class="headerlink" title="HTML文档结构"></a>HTML文档结构</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line">－－<span class="meta">&lt;!DOCTYPE&gt;</span> 标签没有结束标签！</div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>（头部部分）</div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>显示在浏览器标题栏中的标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>（主体部分） </div><div class="line">（页面内容）</div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>bgcolor = 背景颜色　background = 背景图片路经</p><a id="more"></a><h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">H1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">H1</span>&gt;</span>     <span class="tag">&lt;<span class="name">H2</span>&gt;</span> 二级标题<span class="tag">&lt;/<span class="name">H2</span>&gt;</span>    <span class="tag">&lt;<span class="name">H3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">H3</span>&gt;</span>  <span class="tag">&lt;<span class="name">H4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">H4</span>&gt;</span>     <span class="tag">&lt;<span class="name">H5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">H5</span>&gt;</span>     <span class="tag">&lt;<span class="name">H6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">H6</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="font标签"><a href="#font标签" class="headerlink" title="font标签"></a>font标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">"字体大小"</span>  <span class="attr">color</span>=<span class="string">"字体颜色"</span> <span class="attr">face</span>=<span class="string">"字体类型"</span>&gt;</span>要设置的文字<span class="tag">&lt;/<span class="name">font</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="行控制标签"><a href="#行控制标签" class="headerlink" title="行控制标签"></a>行控制标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">"left"</span>/"<span class="attr">right</span>"/"<span class="attr">center</span>"&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>      换行<span class="tag">&lt;<span class="name">br</span> /&gt;</span></div></pre></td></tr></table></figure><h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">"图片地址"</span> <span class="attr">width</span> = <span class="string">"图片宽度"</span> <span class="attr">height</span> = <span class="string">"图片高度"</span> </span></div><div class="line"><span class="tag"><span class="attr">alt</span> = <span class="string">"图片的提示文字"</span> <span class="attr">align</span>=<span class="string">"top/bottom/middle/left/right"</span> <span class="attr">border</span>=<span class="string">"图片的边框宽度"</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="文字布局"><a href="#文字布局" class="headerlink" title="文字布局"></a>文字布局</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">１）<span class="tag">&lt;<span class="name">hr</span>  <span class="attr">size</span>=<span class="string">"厚度"</span>  <span class="attr">width</span>=<span class="string">"宽度"</span>  <span class="attr">color</span>=<span class="string">"颜色"</span>&gt;</span>　　水平线</div><div class="line"></div><div class="line">２）<span class="tag">&lt;<span class="name">ol</span>  <span class="attr">type</span>=<span class="string">序号类型</span>&gt;</span>（序号类型有：1、a、A、ⅰ、I）</div><div class="line"> 　　　　　<span class="tag">&lt;<span class="name">li</span>&gt;</span>填写信息<span class="tag">&lt;/<span class="name">li</span>&gt;</span>（必须用<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>将内容包括起来）   </div><div class="line"> 　　　　 ......</div><div class="line">   <span class="tag">&lt;/<span class="name">ol</span>&gt;</span>　　　　　　　  有序列表</div><div class="line">   </div><div class="line">３）<span class="tag">&lt;<span class="name">ul</span>  <span class="attr">type</span> = <span class="string">""</span>&gt;</span>(序号类型有：disc(默认值,实心圆点)、circle、square)</div><div class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>所写内容<span class="tag">&lt;<span class="name">li</span>&gt;</span></div><div class="line">         .......</div><div class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span>             无序列表</div></pre></td></tr></table></figure><h2 id="页面链接语法"><a href="#页面链接语法" class="headerlink" title="页面链接语法"></a>页面链接语法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"链接地址"</span>&gt;</span>连接标志<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto: 邮件地址"</span>&gt;</span>站长邮箱<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="滚动标签"><a href="#滚动标签" class="headerlink" title="滚动标签"></a>滚动标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">marquee</span>  </span></div><div class="line"><span class="tag">　　　　　　<span class="attr">scrolldelay</span>=<span class="string">滚动延迟时间</span>  </span></div><div class="line"><span class="tag">　　　　　　<span class="attr">direction</span>=<span class="string">up/down/left/right(滚动方向)</span> </span></div><div class="line"><span class="tag">　　　　　　<span class="attr">onmouseover</span>=<span class="string">“this.stop()”(当鼠标指在上面时停止滚动)</span>  　　</span></div><div class="line"><span class="tag">　　　　　　<span class="attr">onmouseout</span>=<span class="string">“this.start()”(当鼠标离开时继续滚动)</span> &gt;</span> </div><div class="line">　　　　　　滚动的文字和图像 </div><div class="line"><span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="表格基本框架"><a href="#表格基本框架" class="headerlink" title="表格基本框架"></a>表格基本框架</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span>  </span></div><div class="line"><span class="tag">      <span class="attr">border</span>=<span class="string">表格的边框的宽度(一般不超过5)</span> </span></div><div class="line"><span class="tag">      <span class="attr">width</span>=<span class="string">表格的宽度</span>  <span class="attr">height</span>=<span class="string">表格的高度</span>  </span></div><div class="line"><span class="tag">      <span class="attr">bordercolor</span>=<span class="string">表格边框线的颜色</span>  <span class="attr">bgcolor</span>=<span class="string">整个表格的背景颜色</span></span></div><div class="line"><span class="tag">      <span class="attr">background</span>=<span class="string">表格的背景图片地址(背景图片)</span> <span class="attr">align</span>=<span class="string">表格对齐方式</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">tr</span>  <span class="attr">bgcolor</span>=<span class="string">行的背景颜色</span>&gt;</span>(行)  </div><div class="line">           <span class="tag">&lt;<span class="name">td</span>  </span></div><div class="line"><span class="tag">              <span class="attr">colspan</span>=<span class="string">跨的列数</span>  <span class="attr">rowspan</span>=<span class="string">跨的行数</span>  <span class="attr">bgcolor</span>=<span class="string">本单元格的背景颜色</span>      </span></div><div class="line"><span class="tag">              <span class="attr">background</span>=<span class="string">本单元格的背景图片地址(背景图片)</span>  </span></div><div class="line"><span class="tag">              <span class="attr">align</span>=<span class="string">单元格中的内容对齐方式(right/left/center/)</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">td</span>&gt;</span>(单元格)  </div><div class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="表单的基本结构"><a href="#表单的基本结构" class="headerlink" title="表单的基本结构"></a>表单的基本结构</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span>  <span class="attr">action</span>=<span class="string">"URL"</span> <span class="attr">name</span>=<span class="string">表单名字</span>  <span class="attr">method</span>=<span class="string">提交数据的方式（post/get）</span>&gt;</span> 具体的内容 <span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="表单中元素"><a href="#表单中元素" class="headerlink" title="表单中元素"></a>表单中元素</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span>元素  </div><div class="line"></div><div class="line">　　　 <span class="tag">&lt;<span class="name">input</span>  <span class="attr">name</span>=<span class="string">“”</span> <span class="attr">type</span>=<span class="string">text</span>  <span class="attr">size</span>=<span class="string">文本框的大小</span>  <span class="attr">maxlenght</span>=<span class="string">限制输入的最大字符</span>&gt;</span>(单行文本框)  </div><div class="line">　　　 <span class="tag">&lt;<span class="name">input</span>  <span class="attr">name</span>=<span class="string">“”</span> <span class="attr">type</span>=<span class="string">password</span>  <span class="attr">size</span>=<span class="string">文本框的大小</span>  <span class="attr">maxlenght</span>=<span class="string">限制输入的最大字符</span>&gt;</span>(单行文本框——设置密码)  </div><div class="line">　　　 <span class="tag">&lt;<span class="name">input</span>  <span class="attr">name</span>=<span class="string">“name”</span> <span class="attr">type</span>=<span class="string">radio</span>  <span class="attr">value</span>=<span class="string">“男”</span>  <span class="attr">checked</span>(默认选定)&gt;</span>(单选按钮——男)(设置单选按钮的时候名字一定要一样)  </div><div class="line">　　　 <span class="tag">&lt;<span class="name">input</span>  <span class="attr">name</span>=<span class="string">“name”</span> <span class="attr">type</span>=<span class="string">radio</span>  <span class="attr">value</span>=<span class="string">“女”</span>&gt;</span>(单选按钮——女) </div><div class="line">　　　 <span class="tag">&lt;<span class="name">input</span>  <span class="attr">name</span>=<span class="string">“”</span> <span class="attr">type</span>=<span class="string">submit</span>  <span class="attr">value</span>=<span class="string">提交</span>&gt;</span>(按钮——提交) </div><div class="line">　　　 <span class="tag">&lt;<span class="name">input</span>  <span class="attr">name</span>=<span class="string">“”</span> <span class="attr">type</span>=<span class="string">reset</span>  <span class="attr">value</span>=<span class="string">重置</span>&gt;</span>(按钮——重置)  </div><div class="line">　　　 <span class="tag">&lt;<span class="name">input</span>  <span class="attr">name</span>=<span class="string">“”</span> <span class="attr">type</span>=<span class="string">checkbox</span>  <span class="attr">value</span>=<span class="string">play(必须有)</span>  <span class="attr">checked</span>&gt;</span>玩游戏(复选框)</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span>下拉列表元素 语法：</div><div class="line">　　　<span class="tag">&lt;<span class="name">select</span>  <span class="attr">name</span>=<span class="string">“”</span>&gt;</span>  </div><div class="line">　　　　　　<span class="tag">&lt;<span class="name">option</span>  <span class="attr">value</span>=<span class="string">“”(必须有)</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">option</span>&gt;</span> </div><div class="line">　　　　　　<span class="tag">&lt;<span class="name">option</span>  <span class="attr">value</span>=<span class="string">“”(必须有)</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">option</span>&gt;</span> </div><div class="line">　　　　　　<span class="tag">&lt;<span class="name">option</span>  <span class="attr">value</span>=<span class="string">“”(必须有)</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">option</span>&gt;</span> </div><div class="line">　　　　　　<span class="tag">&lt;<span class="name">option</span>  <span class="attr">value</span>=<span class="string">“”(必须有)</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">option</span>&gt;</span> </div><div class="line">　　　　　　…… </div><div class="line">　　　<span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span>多行文本框元素  语法：</div><div class="line">　　　<span class="tag">&lt;<span class="name">textarea</span>  <span class="attr">name</span>=<span class="string">“”</span> <span class="attr">cols</span>=<span class="string">“宽度”</span> <span class="attr">rows</span>=<span class="string">“高度”(不要和合并单元格的rowspan和colspan相混淆)</span>&gt;</span>  具体的内容  <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="样式类型"><a href="#样式类型" class="headerlink" title="样式类型"></a>样式类型</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">1）标签选择器  语法：  </div><div class="line">   标签&#123;    </div><div class="line">        属性:属性值; </div><div class="line">       &#125;  </div><div class="line">       <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">”text/css”</span>&gt;</span><span class="undefined">  P&#123;font-size:20px;color:blue&#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>  不需要调用，直接创建标签就能使用   </div><div class="line">2）class选择器  语法：  </div><div class="line">   .类名&#123;   </div><div class="line">        属性:属性值;  </div><div class="line">        &#125;  </div><div class="line">       <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">”text/css”</span>&gt;</span><span class="undefined">  .my&#123;font-size:20px;color:blue&#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>  调用：在需要使用的地方做为属性来调用（class=类名）</div><div class="line">3）ID选择器 语法： </div><div class="line">   #名称&#123;  </div><div class="line">        属性:属性值; &#125;  </div><div class="line">       <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">”text/css”</span>&gt;</span><span class="undefined">  #my&#123;font-size:20px;color:blue&#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>  调用：在需要使用的地方做为属性来调用（ID=名称）</div></pre></td></tr></table></figure><h2 id="常用的样式属性"><a href="#常用的样式属性" class="headerlink" title="常用的样式属性"></a>常用的样式属性</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">1)文本属性  </div><div class="line">　　　font-size:字体大小 </div><div class="line">　　　font-family:字体类型  </div><div class="line">　　　font-style:字体样式（斜体） </div><div class="line">　　　color:字体颜色  </div><div class="line">　　　text-algin:文本的对齐方式（left/right/center） </div><div class="line">2)背景属性  </div><div class="line">　　　background-color:背景颜色  </div><div class="line">　　　background-image:url(“图片地址”)背景图片  </div><div class="line">　　　background-repeat:（repeat/no-repeat/repeat-x/repeat-y）背景图片如何被重复显示 </div><div class="line">3)方框属性 </div><div class="line">　　　(1)边界属性 </div><div class="line">　　　 margin-left:设置对象的左边距 </div><div class="line">　　 　margin-right: 设置对象的右边距 </div><div class="line">　　 　margin-top: 设置对象的上边距 </div><div class="line">　　 　margin-bottom: 设置对象的下边距 </div><div class="line">　　 (2)填充属性  </div><div class="line">　　　 padding-left:设置内容与左边框之间的距离 </div><div class="line">　　 　padding-right: 设置内容与右边框之间的距离 </div><div class="line">　　 　padding-top: 设置内容与上边框之间的距离 </div><div class="line">　　 　padding-bottom: 设置内容与下边框之间的距离 </div><div class="line">　　 (3)边框属性 </div><div class="line">　　  　border-style:(soild细边框/dashed/虚边框)边框样式 </div><div class="line">　　 　 border-width:边框宽度 </div><div class="line">　　 　 border-color:边框颜色 </div><div class="line">4)超链接样式 </div><div class="line">　　　 A:link&#123;&#125;未被访问的链接样式 </div><div class="line">　　　 A:visited&#123;&#125;被访问过的链接样式  </div><div class="line">　　　 A:hover&#123;&#125;鼠标悬浮在链接上时的样式  </div><div class="line">　　　 A:active&#123;&#125;鼠标下在按下时链接文字的样式</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;&lt;h2 id=&quot;HTML文档结构&quot;&gt;&lt;a href=&quot;#HTML文档结构&quot; class=&quot;headerlink&quot; title=&quot;HTML文档结构&quot;&gt;&lt;/a&gt;HTML文档结构&lt;/h2&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;－－&lt;span class=&quot;meta&quot;&gt;&amp;lt;!DOCTYPE&amp;gt;&lt;/span&gt; 标签没有结束标签！&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;lang&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;en&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;（头部部分）&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;charset&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;显示在浏览器标题栏中的标题&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;（主体部分） &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;（页面内容）&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;bgcolor = 背景颜色　background = 背景图片路经&lt;/p&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo-NexT搭建个人博客（一）</title>
    <link href="http://yoursite.com/2017/10/11/hexo-next-one/"/>
    <id>http://yoursite.com/2017/10/11/hexo-next-one/</id>
    <published>2017-10-11T05:25:24.000Z</published>
    <updated>2017-12-17T08:57:24.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo</a> 是一个快速、简洁且高效的静态站点生成框架，它基于 <a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a> 。 它有以下特点：</p><ul><li><i class="fa fa-bolt">&lt;/i&gt;<h6 style="display: inline;">　超快速度</h6><br><i>Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</i></i></li><li><i class="fa fa-pencil">&lt;/i&gt;<h6 style="display: inline;">　支持Markdown</h6><br><i>Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</i></i></li><li><i class="fa fa-cloud-upload">&lt;/i&gt;<h6 style="display: inline;">　一键部署</h6><br><i>只需一条指令即可部署到Github Pages，或其他网站</i></i></li><li><i class="fa fa-cog">&lt;/i&gt;<h6 style="display: inline;">　丰富的插件</h6><br><i>Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</i></i></li></ul><p>通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 <a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="external">标签插件</a> 来快速的插入特定形式的内容。</p><p>基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的<a href="https://hexo.io/themes/" target="_blank" rel="external">主题</a>。<br><a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT</a> 因其 <span id="yu-1">精于心，简于形</span> 的风格，一直被广大用户所喜爱。</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装 Hexo 只需几分钟时间，若你在安装过程中遇到问题或无法找到解决方式，请<a href="https://neveryu.github.io/guestbook/" target="_blank" rel="external">提交问题</a>，我会尽力解决你的问题。</p><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序:</p><blockquote><p><a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a><br><a href="http://git-scm.com/" target="_blank" rel="external">Git</a></p></blockquote><p>如果您的电脑中已经安装上述必备程序，那么恭喜你！接下来只需要使用 npm 即可完成 Hexo 的安装。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure></p><p>如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。</p><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><ul><li>Windows：下载安装 git 。<a id="download" href="https://git-scm.com/download/win" target="_blank" rel="external"><i class="fa fa-download"></i><span> Download Now</span></a></li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="external">Homebrew</a>，<a href="http://www.macports.org/" target="_blank" rel="external">MacPorts</a> 或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="external">安装程序</a> 安装</li><li>Linux（Ubuntu，Debian）：<code>sudo apt-get install git-core</code></li><li>Linux（Fedora，Red Hat，CentOS）：<code>sudo yum install git-core</code></li></ul><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a>。（nvm：Node Version Manager）<br>windows 下使用 nvm 请看这里： <a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="external">nvm-windows</a> ，首先需要下载安装 nvm 。<a id="download" href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="external"><i class="fa fa-download"></i><span> Download Now</span></a><br>windows下安装完nvm以后，我们可以打开命令行中执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ nvm</div><div class="line">$ nvm install latest</div></pre></td></tr></table></figure></p><p>执行完以后，重启命令行，执行命令 <code>node -v</code> ，如果出现版本号，那么 <code>Node.js</code> 就安装成功了。</p><p id="div-border-left-red">如果没有安装成功，那可能就是墙的原因。建议下载 `Node.js` 直接安装。<a id="download" href="https://nodejs.org/en/download/" target="_blank" rel="external"><i class="fa fa-download"></i><span> Download Now</span></a> </p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>有了 Node.js ，我们可以使用 npm 安装 Hexo。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure></p><p>安装 Hexo 完成后，我们首先需要为我们的项目创建一个<span id="inline-green">指定文件夹</span>（例如我在 D 盘目录下创建了一个文件夹 blog 。<code>D:\blog</code> ），在指定文件夹中执行下列命令， Hexo 将会在指定文件夹中新建所需要的文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init</div></pre></td></tr></table></figure></p><p>等待安装，安装完成后，<span id="inline-green">指定文件夹</span> 的目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── _config.yml</div><div class="line">├── package.json</div><div class="line">├── scaffolds</div><div class="line">├── source</div><div class="line">|   ├── _drafts</div><div class="line">|   └── _posts</div><div class="line">└──</div></pre></td></tr></table></figure></p><p>我们继续执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g</div><div class="line">$ hexo s --debug</div></pre></td></tr></table></figure></p><p>Hexo 将 source 文件夹中除 <em>posts 文件夹之外，开头命名为 </em>(下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件夹会被拷贝过去。<br>这个时候，我们在浏览器中访问 <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> ，就可以看到基于 Hexo 的默认主题的原型：<br><img src="http://p1.bqimg.com/567571/27324b740c9e91e2.png" alt="hexo-next-one-1"></p><h2 id="安装-NexT-主题"><a href="#安装-NexT-主题" class="headerlink" title="安装 NexT 主题"></a>安装 NexT 主题</h2><h3 id="下载-NexT-主题"><a href="#下载-NexT-主题" class="headerlink" title="下载 NexT 主题"></a>下载 NexT 主题</h3><p>依旧是在当前目录下，使用 Git checkout 代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure></p><p>等待下载完成。</p><p id="div-border-left-yellow">在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。  我们约定，将前者称为 <span id="inline-blue">站点配置文件</span>，后者称为 <span id="inline-purple">主题配置文件</span></p><h3 id="启用-NexT-主题"><a href="#启用-NexT-主题" class="headerlink" title="启用 NexT 主题"></a>启用 NexT 主题</h3><p>打开 <span id="inline-blue">站点配置文件</span> ，找到 theme 字段，并将其值更改为 next 。<br>到此， NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存。</p><h3 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h3><p>首先启动 Hexo 本地站点，并开启调试模式（即加上 <code>--debug</code>），整个命令是 <code>hexo s --debug</code>。在服务启动的过程，注意观察命令行输出是否有任何异常信息。当命令行输出中提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</div></pre></td></tr></table></figure><p>此时即可使用浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> ，检查站点是否正确运行。</p><p id="div-border-left-green">当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse</p>![hexo-next-one-1](http://p1.bqimg.com/567571/8333728b5eaab526.png)现在，我们已经成功安装并启用了 NexT 主题。<p id="div-border-top-blue">关于更多基本操作和基础知识，请查阅 [Hexo](https://hexo.io/zh-cn/) 与 [NexT](http://theme-next.iissnan.com/) 官方文档.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="本地调试步骤"><a href="#本地调试步骤" class="headerlink" title="本地调试步骤"></a>本地调试步骤</h2><p>三部曲：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div><div class="line">$ hexo g</div><div class="line">$ hexo s --debug</div></pre></td></tr></table></figure></p><p>这种带 debug 的运行，如果出现错误，可以在命令行中看到错误提示信息。</p><h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h2><p>三部曲：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div><div class="line">$ hexo g</div><div class="line">$ hexo d</div></pre></td></tr></table></figure></p><p>当然在部署之前，需要先配置好配置文件中的 deploy。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"postName"</span>  <span class="comment">#新建文章</span></div><div class="line">$ hexo new page <span class="string">"pageName"</span> <span class="comment"># 新建页面</span></div><div class="line">$ hexo generate <span class="comment"># 生成静态页面至public目录</span></div><div class="line">$ hexo server <span class="comment"># 开启预览访问端口(默认端口4000，'ctrl+c'关闭server)</span></div><div class="line">$ hexo deploy <span class="comment"># 项目部署</span></div><div class="line">$ hexo <span class="built_in">help</span> <span class="comment"># 查看帮助</span></div><div class="line">$ hexo version <span class="comment"># 查看Hexo的版本</span></div></pre></td></tr></table></figure><h2 id="简写命令"><a href="#简写命令" class="headerlink" title="简写命令"></a>简写命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ hexo new == hexo n</div><div class="line">$ hexo generate == hexo g</div><div class="line">$ hexo server == hexo s</div><div class="line">$ hexo deploy == hexo d</div></pre></td></tr></table></figure><h2 id="常见问题1"><a href="#常见问题1" class="headerlink" title="常见问题1"></a>常见问题1</h2><p>在 hexo 的配置和设置文件中，在冒号后面没留空格会导致出问题：<br>错误的设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">author:Neveryu</div><div class="line">email:react.dong.yu@gmail.com</div><div class="line">language:zh-CN</div></pre></td></tr></table></figure></p><p>正确的设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">author: Neveryu</div><div class="line">email: react.dong.yu@gmail.com</div><div class="line">language: zh-CN</div></pre></td></tr></table></figure></p><h2 id="常见问题2"><a href="#常见问题2" class="headerlink" title="常见问题2"></a>常见问题2</h2><p>关于 Git 提交中用户名和 Email 的设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;Your name&quot;</div><div class="line">git config --global user.email &quot;Your email&quot;</div></pre></td></tr></table></figure></p><h2 id="常见问题3"><a href="#常见问题3" class="headerlink" title="常见问题3"></a>常见问题3</h2><p>Hexo 中的图标使用的是 <a href="http://fontawesome.io/" target="_blank" rel="external">Font Awesome</a> ，所以，我们的博客已经自带了 Font Awesome 中的所有图标，基本可以满足我们的所有需求，我们可以去 Font Awesome 中查找我们想要使用的图标。<br><i class="fa fa-github">&lt;/i&gt; `<i class="fa fa-github"></i><code>&lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt;</code><i class="fa fa-github fa-lg">&lt;/i&gt;`<br><i class="fa fa-github fa-2x"></i> <code>&lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt;</code></i></i></p><p></p><h5 style="color:#f63;"><i>最后要说的是：</i></h5><p></p><p id="div-border-top-green"><i>[博客源码](https://github.com/Neveryu/Neveryu.github.io) ， 欢迎 star</i></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt; 是一个快速、简洁且高效的静态站点生成框架，它基于 &lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node.js&lt;/a&gt; 。 它有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;i class=&quot;fa fa-bolt&quot;&gt;&amp;lt;/i&amp;gt;&lt;h6 style=&quot;display: inline;&quot;&gt;　超快速度&lt;/h6&gt;&lt;br&gt;&lt;i&gt;Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。&lt;/i&gt;&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=&quot;fa fa-pencil&quot;&gt;&amp;lt;/i&amp;gt;&lt;h6 style=&quot;display: inline;&quot;&gt;　支持Markdown&lt;/h6&gt;&lt;br&gt;&lt;i&gt;Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。&lt;/i&gt;&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=&quot;fa fa-cloud-upload&quot;&gt;&amp;lt;/i&amp;gt;&lt;h6 style=&quot;display: inline;&quot;&gt;　一键部署&lt;/h6&gt;&lt;br&gt;&lt;i&gt;只需一条指令即可部署到Github Pages，或其他网站&lt;/i&gt;&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=&quot;fa fa-cog&quot;&gt;&amp;lt;/i&amp;gt;&lt;h6 style=&quot;display: inline;&quot;&gt;　丰富的插件&lt;/h6&gt;&lt;br&gt;&lt;i&gt;Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。&lt;/i&gt;&lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 &lt;a href=&quot;https://hexo.io/zh-cn/docs/tag-plugins.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;标签插件&lt;/a&gt; 来快速的插入特定形式的内容。&lt;/p&gt;
&lt;p&gt;基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的&lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;主题&lt;/a&gt;。&lt;br&gt;&lt;a href=&quot;http://theme-next.iissnan.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NexT&lt;/a&gt; 因其 &lt;span id=&quot;yu-1&quot;&gt;精于心，简于形&lt;/span&gt; 的风格，一直被广大用户所喜爱。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Next" scheme="http://yoursite.com/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://yoursite.com/2017/09/20/hello-world/"/>
    <id>http://yoursite.com/2017/09/20/hello-world/</id>
    <published>2017-09-20T07:23:54.000Z</published>
    <updated>2017-12-18T14:00:33.683Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to sysuNie! It is my first try to share the intereseting things to all of you . If you get any problems while looking my blog,  you can ask me on <a href="https://github.com/sysuNie" target="_blank" rel="external">GitHub</a>.</p><h2 id="Coding-Change-World"><a href="#Coding-Change-World" class="headerlink" title="Coding Change World"></a>Coding Change World</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line">import matplotlib.pyplot as plt</div><div class="line">x = np.linspace(-8 , 8, 1024)</div><div class="line">y1 = 0.618*np.abs(x) - 0.8* np.sqrt(64-x**2)</div><div class="line">y2 = 0.618*np.abs(x) + 0.8* np.sqrt(64-x**2) </div><div class="line">plt.plot(x, y1, color = <span class="string">'r'</span>)</div><div class="line">plt.plot(x, y2, color = <span class="string">'r'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="/home/miacher/Documents/love.jpg" alt=""> </p>]]></content>
    
    <summary type="html">
    
      welcome to my blog
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔，开博" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94%EF%BC%8C%E5%BC%80%E5%8D%9A/"/>
    
  </entry>
  
</feed>
