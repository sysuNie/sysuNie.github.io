<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sysuNie</title>
  
  <subtitle>Gotta to change</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-27T05:45:39.079Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JiKang Nie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>data_augmentation</title>
    <link href="http://yoursite.com/2017/12/27/data-augmentation/"/>
    <id>http://yoursite.com/2017/12/27/data-augmentation/</id>
    <published>2017-12-27T05:20:58.000Z</published>
    <updated>2017-12-27T05:45:39.079Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据扩充"><a href="#数据扩充" class="headerlink" title="数据扩充"></a>数据扩充</h3><p>深度卷积网络自身拥有强大的表达能力，网络本身更需要大量的数据来驱动模型训练，否则极有可能陷入过拟合的窘境．实际中，并不是所有数据集都拥有海量样本．因此，在实践中数据扩充是非常有必要的．偶晓得数据扩充不仅能扩充训练样本数量，还能增加训练样本额多样性，一方面可以避免过拟合，另一方面提升模型的性能．</p><h4 id="简单的数据扩充方式"><a href="#简单的数据扩充方式" class="headerlink" title="简单的数据扩充方式"></a>简单的数据扩充方式</h4><p>在数据扩充方面，简单的方法有图像水平翻转、随机扣取、尺寸变换和旋转．在此基础上，对原图或已变化的图像进行色彩抖动也是一种常用的数据扩充手段．</p><h4 id="特殊的数据扩充方式"><a href="#特殊的数据扩充方式" class="headerlink" title="特殊的数据扩充方式"></a>特殊的数据扩充方式</h4><ul><li><strong>Fancy PCA</strong></li></ul><p>Fancy PCA首先对所有训练数据的R,G,B像素值进行主成分分析（PCA）操作，得到对应的特征向量和特征值,然后根据特征向量和特征值可以计算一组随机值，将其作为扰动加到原像素值中即可．</p><ul><li>监督式数据扩充</li></ul><p>借助图像标记信息的新型数据扩充方式．首先根据元数据训练一个分类的初始模型，利用该模型对每张生成对应的特征图或热力图．这张图可指示图像区域与场景标记之间的相关概率，之后根据此概率映射回原图选择较强相关的图像区域作为扣取的图像块．适用于高层予以图像分类任务．</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据扩充&quot;&gt;&lt;a href=&quot;#数据扩充&quot; class=&quot;headerlink&quot; title=&quot;数据扩充&quot;&gt;&lt;/a&gt;数据扩充&lt;/h3&gt;&lt;p&gt;深度卷积网络自身拥有强大的表达能力，网络本身更需要大量的数据来驱动模型训练，否则极有可能陷入过拟合的窘境．实际中，并不是所有
      
    
    </summary>
    
      <category term="论文" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="论文，数据扩充" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%89%A9%E5%85%85/"/>
    
  </entry>
  
  <entry>
    <title>Sort_Algorithms</title>
    <link href="http://yoursite.com/2017/12/26/Sort-Algorithms/"/>
    <id>http://yoursite.com/2017/12/26/Sort-Algorithms/</id>
    <published>2017-12-26T11:20:38.000Z</published>
    <updated>2017-12-26T14:05:30.623Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　查找和排序是算法的入门知识，因为实现代码较短，应用较常见．面试中经常会问到排序算法及相关的问题．一般在面试中最常考的是快速排序和归并排序，并且要求现场写出这两种排序的代码．对这两种排序的代码一定要信手拈来才行。还有插入排序、冒泡排序、堆排序、基数排序、桶排序等。面试官对于这些排序可能会要求比较各自的优劣、各种算法的思想及其使用场景。还有要会分析算法的时间和空间复杂度。通常查找和排序算法的考察是面试的开始，如果这些问题回答不好，估计面试官都没有继续面试下去的兴趣都没了。所以想开个好头就要把常见的排序算法思想及其特点要熟练掌握，有必要时要熟练写出代码。接下来我们就分析一下常见的排序算法及其使用场景。</p><a id="more"></a><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>　　冒泡排序是最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此二得名．举个例子：对5,3,8,6,4这个无序序列进行冒泡排序．首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6,3和4无需交换。5和3交换，变成3,5,4,8,6,3.这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列依次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为<strong>O(n^2)</strong>。</p><p>C++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> data[<span class="number">1000</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_sort</span><span class="params">(<span class="keyword">int</span> *d, <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;n; k++)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i＜n; i++)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">if</span>(d[i]&lt;d[i<span class="number">-1</span>])</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">int</span> temp = d[i];</div><div class="line">        d[i] = d[i<span class="number">-1</span>];</div><div class="line">        d[i<span class="number">-1</span>] = temp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</div><div class="line">  &#123;</div><div class="line">    data[i] = rand();</div><div class="line">  &#125;</div><div class="line">  Bubble_sort(data, <span class="number">1000</span>);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, data[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>java实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble_sort</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Bubble_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length = <span class="number">0</span>)</div><div class="line">      <span class="keyword">return</span> ; </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr.length; j++)</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</div><div class="line">        &#123;</div><div class="line">          <span class="keyword">int</span> temp = arr[j];</div><div class="line">          arr[j] = arr[j+<span class="number">1</span>];</div><div class="line">          arr[j+<span class="number">1</span>] = temp;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的思想和冒泡排序有些类似，都是在一次排序后吧最小的元素放在最前面．但是过程不同，冒泡排序是通过相邻的比较和交换，选择排序是通过对整体的选择．举个例子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，依次排序后就编程3,5,8,6,4.对剩下的序列一次进行选择和交换，最终会得到一个有序序列．选择排序可以看作是冒泡排序的优化，其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数．选择排序的时间复杂度为<strong>O(n^2)</strong>。</p><p>C++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT_COUNT 10000;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, k, d[ELEMENT_COUNT];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">int</span> x = d[r];</div><div class="line">  <span class="keyword">int</span> j = l<span class="number">-1</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=r; i++)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span>(d[i]&lt;=x)</div><div class="line">    &#123;</div><div class="line">      j++;</div><div class="line">      <span class="keyword">int</span> temp = d[i];</div><div class="line">      d[i] = d[j];</div><div class="line">      d[j] = temp;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> j+<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</div><div class="line">  <span class="keyword">while</span>(l&lt;r)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">int</span> par = partition(l, r);</div><div class="line">    <span class="keyword">if</span>(par &lt; k)</div><div class="line">    &#123;</div><div class="line">      l = par;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(par&gt;k)</div><div class="line">    &#123;</div><div class="line">      r = par<span class="number">-2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> d[par<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> d[l];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">inr <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> ktg = select(k);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>, kth);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>java实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Select_sort</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Select_sort</span><span class="params">(<span class="keyword">int</span>[], arr)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length = <span class="number">0</span>)</div><div class="line">      <span class="keyword">return</span> ; </div><div class="line">    <span class="keyword">int</span> minIndex = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)  <span class="comment">//只需要比较n-1次</span></div><div class="line">    &#123;</div><div class="line">      minIndex = i;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++)  </div><div class="line">      &#123;                          <span class="comment">//从i+1开始比较，因为minIndex默认为i了，i就没必要比了。</span></div><div class="line">        <span class="keyword">if</span>(arr[j]&lt;arr[minIndex])</div><div class="line">        &#123;</div><div class="line">          minIndex = j;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(minIndex != i)　　　<span class="comment">//如果minIndex不为i，说明找到了更小的值，交换之。</span></div><div class="line">      &#123;</div><div class="line">        <span class="keyword">int</span> temp = arr[i];</div><div class="line">        arr[i] = arr[minIndex];</div><div class="line">        arr[minIndex] = temp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序表示通过交换位置而是通过比较找到合适的位置插入元素来达到怕徐的目的．举个例子：对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一位数的位置是正确的，然后3要插到5前面，把5后移一位，变成3,5,8,6,4.然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序。简单插入排序的时间复杂度也是<strong>O(n^2)</strong>。</p><p>C++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT_COUNT 10000;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, d[ELEMENT_COUNT];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insertion_sort</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">if</span>(d[j]&gt;d[j+<span class="number">1</span>])</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">int</span> temp = d[j];</div><div class="line">        d[j] = d[j+<span class="number">1</span>];</div><div class="line">        d[j+<span class="number">1</span>] = temp;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span></div><div class="line">      &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d[i]);</div><div class="line">  &#125;</div><div class="line">  Insertion_sort();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i0; i&lt;n; i++)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, d[i])</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span> ;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>java实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion_sort</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Insertion_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span></div><div class="line"><span class="function">  </span>&#123;                              <span class="comment">//假设第一个数位置时正确的；要往后移，必须要假设第一个。</span></div><div class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</div><div class="line">      <span class="keyword">return</span> ; </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.lengt; i++)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">int</span> j = i;</div><div class="line">      <span class="keyword">int</span> target = arr[i];   <span class="comment">//待插入的</span></div><div class="line">      <span class="comment">//后移</span></div><div class="line">      <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; target &lt; arr[j-<span class="number">1</span>])</div><div class="line">      &#123;</div><div class="line">        arr[j] = arr[j-<span class="number">1</span>];</div><div class="line">        j--;</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="comment">//插入</span></div><div class="line">      arr[j] = target;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>在实际应用中，快速排序是表现最好的排序算法．快速排序思想来自于冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换大数和小数，这样一来不仅吧小数冒泡到上面同时也把大数沉到下面．</p><p>举个例子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。</p><ul><li>5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。</li><li>5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。</li><li>5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。</li><li>4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。</li></ul><p>上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。</p><p>快速排序是不稳定的，其时间平均时间复杂度是<strong>O(nlgn)</strong>。</p><p>C++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ELEMENT_COUNT 1000000</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> d[MAX_ELEMENT_COUNT];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Qucik_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">if</span>(l&lt;r)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">int</span> x = d[r];</div><div class="line">    <span class="keyword">int</span> j= l<span class="number">-1</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=r; i++)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">if</span>(d[i]&lt;=x)</div><div class="line">      &#123;</div><div class="line">        j++;</div><div class="line">        <span class="keyword">int</span> temp = d[i];</div><div class="line">        d[i] = d[j];</div><div class="line">        d[j] = temp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    Qucik_sort(l, j<span class="number">-1</span>);</div><div class="line">    Qucik_sort(j+<span class="number">1</span>, r)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_ELEMENT_COUNT; i++)</div><div class="line">&#123;</div><div class="line">d[i] = rand();</div><div class="line">&#125;</div><div class="line"></div><div class="line">Qucik_sort(<span class="number">0</span>, MAX_ELEMENT_COUNT - <span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_ELEMENT_COUNT; i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, d[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>java实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick_sort</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment"> * 从left到right排序数组array</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></div><div class="line"><span class="comment"> */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">int</span> pivotkey = arr[left];</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(left&lt;right)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[right]&gt;=pivotkey)</div><div class="line">        right--;</div><div class="line">      arr[left] = arr[right]; <span class="comment">//把小的移动到左边</span></div><div class="line">      <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[left]&lt;=pivotkey)</div><div class="line">        left++;</div><div class="line">      arr[right] = arr[left]; <span class="comment">//把大的移动到右边</span></div><div class="line">    &#125;</div><div class="line">    arr[left] = pivotkey; <span class="comment">//最后把pivot赋值到中间</span></div><div class="line">    <span class="keyword">return</span> left;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">     * 递归划分子序列</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></div><div class="line"><span class="comment">     */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">if</span>(left &gt;= right)</div><div class="line">      <span class="keyword">return</span> ;</div><div class="line">    <span class="keyword">int</span> pivotPos = partition(arr, left, right);</div><div class="line">    quick_sort(arr, left, pivotPos-<span class="number">1</span>);</div><div class="line">    quick_sort(arr, pivotPos+<span class="number">1</span>, right);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</div><div class="line">      <span class="keyword">return</span> ;</div><div class="line">    quick_sort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  　　</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是借助堆来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。</p><p>　　首先，实现堆排序需要解决两个问题：</p><p>  　　1. 如何由一个无序序列键成一个堆？</p><p>  　　2. 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？</p><p>　　第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。</p><p>　　第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。</p><p>　　从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举个栗子：</p><p>49,38,65,97,76,13,27,49序列的堆排序建初始堆和调整的过程如下：</p><p><img src="http://images2015.cnblogs.com/blog/735119/201603/735119-20160305133553205-2143614528.png" alt="堆"></p><p><img src="http://images2015.cnblogs.com/blog/735119/201603/735119-20160305133644815-347392695.png" alt="堆去"></p><p>C++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_HEAP_SIZE 10000;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> n, H[MAX_HEAP_SIZE], heapsize;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heapify</span><span class="params">(<span class="keyword">int</span> i)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">int</span> smallest = i;</div><div class="line">  <span class="keyword">int</span> lch = i &lt;&lt;<span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> rch = lch+<span class="number">1</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">if</span>(lch &lt;= heapsize &amp;&amp; H[smallest]&gt;H[lch])</div><div class="line">  &#123;</div><div class="line">    smallest = lch;</div><div class="line">  &#125;</div><div class="line">   <span class="keyword">if</span>(rch &lt;= heapsize &amp;&amp; H[smallest]&gt;H[rch])</div><div class="line">  &#123;</div><div class="line">    smallest = rch;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(smallest != i )</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">int</span> temp = H[smallest];</div><div class="line">    H[smallest] = H[i];</div><div class="line">    H[i] = temp;</div><div class="line">    min_heapify(smallest);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = heapsize &gt;&gt;<span class="number">1</span>; i&gt;=<span class="number">1</span>; i--)</div><div class="line">  &#123;</div><div class="line">    min_heapify(i)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">extract_min</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">int</span> res = H[<span class="number">1</span>];</div><div class="line">  H[<span class="number">1</span>] = H[heapsize--];</div><div class="line">  min_heapify(<span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line">heapsize = n;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;H[i]);</div><div class="line">&#125;</div><div class="line">build_heap();</div><div class="line"><span class="keyword">while</span> (heapsize &gt; <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, extract_min());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>java实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> &#123;</span></div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 堆筛选，除了start之外，start~end均满足大顶堆的定义。</span></div><div class="line"><span class="comment">     * 调整之后start~end称为一个大顶堆。</span></div><div class="line"><span class="comment">     * @param arr 待调整数组</span></div><div class="line"><span class="comment">     * @param start 起始指针</span></div><div class="line"><span class="comment">     * @param end 结束指针</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = arr[start];</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*start+<span class="number">1</span>; i&lt;=end; i*=<span class="number">2</span>) &#123;</div><div class="line">            <span class="comment">//左右孩子的节点分别为2*i+1,2*i+2</span></div><div class="line">            </div><div class="line">            <span class="comment">//选择出左右孩子较小的下标</span></div><div class="line">            <span class="keyword">if</span>(i &lt; end &amp;&amp; arr[i] &lt; arr[i+<span class="number">1</span>]) &#123;</div><div class="line">                i ++; </div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(temp &gt;= arr[i]) &#123;</div><div class="line">                <span class="keyword">break</span>; <span class="comment">//已经为大顶堆，=保持稳定性。</span></div><div class="line">            &#125;</div><div class="line">            arr[start] = arr[i]; <span class="comment">//将子节点上移</span></div><div class="line">            start = i; <span class="comment">//下一轮筛选</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        arr[start] = temp; <span class="comment">//插入正确的位置</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(arr == null || arr.length == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> ;</div><div class="line">        </div><div class="line">        <span class="comment">//建立大顶堆</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">            heapAdjust(arr, i, arr.length<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">            swap(arr, <span class="number">0</span>, i);</div><div class="line">            heapAdjust(arr, <span class="number">0</span>, i<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = arr[i];</div><div class="line">        arr[i] = arr[j];</div><div class="line">        arr[j] = temp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。希尔排序就利用了这个特点。基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。</p><p>举个例子：</p><p><img src="http://images2015.cnblogs.com/blog/735119/201603/735119-20160305135104830-1351755091.png" alt="希尔"></p><p>从上述排序过程可见，希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。</p><p>　　希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到<strong>O(n^1.3)</strong>。</p><p>C++实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT_COUNT 100000</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n, d[ELEMENT_COUNT];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shell_sort</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> gc = n&gt;&gt;<span class="number">1</span>; gc&gt;=<span class="number">1</span>; gc&gt;&gt;=<span class="number">1</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s&lt;gc; s++)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i-gc; j&gt;=<span class="number">0</span> &amp;&amp; d[j]&gt;d[j+gc]; j-= gc)</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">int</span> temp = d[j];</div><div class="line">        d[j] = d[j+gc];</div><div class="line">        d[j+gc] = temp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d[i]);</div><div class="line">&#125;</div><div class="line">Shell_sort();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, d[i]);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>java实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell_sort</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> d)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=d; i&lt;arr.length; i++)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">int</span> j = i-d;</div><div class="line">      <span class="keyword">int</span> temp = arr[i];   <span class="comment">//记录要插入的数据</span></div><div class="line">      <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;temp)  <span class="comment">//从后向前，找到比其小的数的位置 </span></div><div class="line">      &#123;</div><div class="line">        arr[j+d] = arr[j];  <span class="comment">//向后挪动 </span></div><div class="line">        j -= d;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(j != i-d)  <span class="comment">//存在比其小的数</span></div><div class="line">        arr[j+d] = temp;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> ;</div><div class="line">    <span class="keyword">int</span> d = arr.length / <span class="number">2</span>;</div><div class="line">    <span class="keyword">while</span>(d&gt;=<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">      shell_sort(arr, d);</div><div class="line">      d /= <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;　　查找和排序是算法的入门知识，因为实现代码较短，应用较常见．面试中经常会问到排序算法及相关的问题．一般在面试中最常考的是快速排序和归并排序，并且要求现场写出这两种排序的代码．对这两种排序的代码一定要信手拈来才行。还有插入排序、冒泡排序、堆排序、基数排序、桶排序等。面试官对于这些排序可能会要求比较各自的优劣、各种算法的思想及其使用场景。还有要会分析算法的时间和空间复杂度。通常查找和排序算法的考察是面试的开始，如果这些问题回答不好，估计面试官都没有继续面试下去的兴趣都没了。所以想开个好头就要把常见的排序算法思想及其特点要熟练掌握，有必要时要熟练写出代码。接下来我们就分析一下常见的排序算法及其使用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程，排序" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>operating_system</title>
    <link href="http://yoursite.com/2017/12/21/operating-system/"/>
    <id>http://yoursite.com/2017/12/21/operating-system/</id>
    <published>2017-12-21T12:32:34.000Z</published>
    <updated>2017-12-26T11:11:09.272Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作系统导论"><a href="#操作系统导论" class="headerlink" title="操作系统导论"></a>操作系统导论</h3><p>　　操作系统是管理和控制计算机硬件和软件资源的计算机程序．计算机系统大致可以分为四个组成部分：计算机硬件、操作系统、系统程序与应用程序和用户．计算机系统的组成部分包括硬件、软件和数据．操作系统是一直运行在计算机上的程序（通常称为内核kernel）．</p><p><strong>操作系统基本特征：</strong></p><ul><li>并发：同一段时间内多个程序执行</li><li>共享：系统中的资源可以被内存中多个并发执行的进线程共同使用  </li><li>虚拟：通过分时复用以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个  </li><li>异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进  </li></ul><a id="more"></a><h4 id="计算机系统组织"><a href="#计算机系统组织" class="headerlink" title="计算机系统组织"></a>计算机系统组织</h4><p>　　现在通用计算机系统有一个或多个cpu和若干设备控制器通过共同的总线相连而成，该总线提供了对共享内存的访问．每个设备控制器负责一种特定类型的设备（磁盘驱动器、音频设备、视频显示器），cpu与设备控制器可以并发工作，并竞争内存周期．</p><p>　　当启动计算机时，它需要一个初始化程序．该初始化程序通常位于ROM或EEPROM中，称为计算机硬件中的固件．他初始化系统中的cpu寄存器、设备控制器和内存内容．</p><p>　　计算机程序必须在内存（或随机访问内存RAM）中以便于运行．通过地特定内存地址执行一系列load或store指令来实现交互．指令load将内存中的子移到cpu的寄存器，指令store将寄存器的内容移到内存．存储设备层次：寄存器，高速缓存、驻村、电子磁盘、磁盘、光盘、磁带．</p><h4 id="计算机系统体系结构"><a href="#计算机系统体系结构" class="headerlink" title="计算机系统体系结构"></a>计算机系统体系结构</h4><p>　　单处理系统（只要一个人同cpu）、多处理系统（增加吞吐量、规模经济、可靠性）、集群系统．</p><h4 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h4><p>　　操作系统具有多道程序处理能力，多道程序设计通过组织作业是cpu总有一个作业可执行，从而提高了cpu的利用率．分时系统是多道程序设计的延伸，分时操作系统允许许多用户同时共享计算机．</p><h4 id="操作系统操作"><a href="#操作系统操作" class="headerlink" title="操作系统操作"></a>操作系统操作</h4><p>　　双重模式操作：用户模式和监督程序模式．</p><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><p>　　处于执行中的程序称为进程，进程需要一定的资源（cpu时间、内存、文件、I/O设备）以完成其任务．程序本身并不是进程，程序是被动的实体，如同储存在磁盘上的内容，进程是一个活动的实体．进程是系统工作的单元，操作系统负责下述与进程管理相关的活动：</p><blockquote><p>创建和删除用户进程和系统进程</p><p>挂起和重启进程</p><p>提供进同步机制</p><p>提供进程通信机制</p><p>提供死锁处理机制　　</p></blockquote><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>　操作系统负责下列有关内存管理的活动：</p><blockquote><p>记录内存的那部分在使用及被谁使用</p><p>当有内存空间时，决定奶写进程可以装入内存</p><p>根据需要分配和释放内存空间</p></blockquote><h4 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h4><p>　文件系统管理，操作系统负责下列有关文件管理的活动：</p><blockquote><p>创建和删除文件</p><p>创建和删除目录来组织文件</p><p>提供操作文件和目录的原语</p><p>将文件映射到二级存储上</p><p>在稳定存储介质上备份文件</p></blockquote><p>　操作系统负责系列有关硬盘管理的活动：</p><blockquote><p>空闲空间管理</p><p>存储空间分配</p><p>硬盘调度</p></blockquote><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>　　信息通常保存在内存中，当他使用时，他会被临时复制到赶快的存储系统－高速缓存．当需要特定的信息时，首先检查他是否在高速缓存红，如果是，可直接使用高速缓存的信息，否则使用位于内存的信息，同事将其复制到高速缓存一片下次使用．索引寄存器为内存提供了高速缓存．</p><h4 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I/O系统"></a>I/O系统</h4><p>　　操作系统的目的之一在于对用户隐藏具体硬件设备的特性．I/O子系统摆阔如下几个部分：</p><blockquote><p>一个包括缓存、高速缓存和假脱机的内存管理部分</p><p>通用设备驱动器接口</p><p>特定硬件设备的驱动程序</p></blockquote><h3 id="操作系统结构-1"><a href="#操作系统结构-1" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><ul><li>用户界面：命令行界面、图形用户界面、</li><li>程序执行：系统必须将程序装入内存中并运行程序</li><li>I/O操作：操作系统必须提供I/O操作的方法</li><li>文件系统操作：</li><li>通信：进程之间的信息交换</li><li>错误检测：</li><li>资源分配：</li><li>统计:</li><li>保护和安全</li></ul><h4 id="系统调用类型"><a href="#系统调用类型" class="headerlink" title="系统调用类型"></a>系统调用类型</h4><p>　　系统调用大致分为五类：进程控制、文件管理、设备管理、信息维护和通信．</p><h3 id="进程管理-1"><a href="#进程管理-1" class="headerlink" title="进程管理"></a>进程管理</h3><p>　　处于执行中的程序称为进程，进程需要一定的资源（cpu时间、内存、文件、I/O设备）以完成其任务．程序本身并不是进程，程序是被动的实体，如同储存在磁盘上的内容，进程是一个活动的实体．进程是系统工作的单元．</p><p>　　<strong>进程状态：</strong></p><ul><li><p>新的：进程正在被创建</p></li><li><p>运行：指令正在被执行</p></li><li><p>等待：进程等待某个事件的发生</p></li><li><p>就绪：进程等待分配处理器</p></li><li><p>终止：进程完成执行</p><p><strong>进程控制块：（PCB）</strong></p></li><li><p>进程状态：前述状态</p></li><li><p>程序计数器：表示进程要执行的下个指令的地址</p></li><li><p>CPU寄存器：包括累加器、索引寄存器、堆栈指针、通用寄存器和其他条件码信息寄存器</p></li><li><p>CPU调度信息：进程优先级、调度队列的指正和其他调度参数</p></li><li><p>内存管理信息：基址和界限寄存器的值顿号页表或段表</p></li><li><p>记账信息：CPU事件、实际使用时间、时间界限、记账数据、作业或进程数量</p></li><li><p>I/O状态信息：分配给进程的I/O设备列表、打开的文件列表</p></li></ul><h4 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h4><p>　　进程创建：创建进程称为父进程，新进程称为子进程，新进程可以再创建其他进程，形成进程树．</p><p>　　大多数操作系统根据唯一的进程标示符(pid)来识别进程，pid通常是一个整数值．在进程创建时，除了得到各种物理和罗技资源外，初始化数据由父进传递给子进程．</p><p>　　当进程创建新进程是，有两种执行可能：</p><ul><li>父进程与子进程并发执行</li><li>父进程等待，直到某个或者去全部子进程执行完</li></ul><p>　　新进程的地址空间也有两种可能：</p><ul><li>子进程是父进程的复制品</li><li>子进程装入另外一个程序</li></ul><h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><p>　　当进程完成执行最后的语句后用exit()请求操作系统删除自身时，进程终止．进程可以返回状态值到父进程，所有进程资源会被操作系统释放．</p><p>　　父进程终止子进程的原因：</p><ul><li>子进程使用了超过他所分配到的一些资源</li><li>分配给子进程的任务已经不再需要</li><li>父进程退出</li></ul><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><p>　　操作系统内并发执行的进程可以是独立进程或协作进程．协作进程需要进程间通信机制来允许进程相互交换数据与信息．进程间通信有两种基本模式：共享内存、消息传递．</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>　　线程是CPU使用的基本单元，它有线程ID、陈旭计数器都闹寄存器集合和堆栈组成．它与属于同于进程的其他线程共享代码段、数据段和其他操作系统资源．单线程、多线程．</p><p>　　多线程编程优点：</p><ul><li>响应度高：即使部分阻塞或者执行叫冗长的操作，陈旭仍然继续执行</li><li>资源共享：现成默认共享他们所属进程的内存和资源</li><li>经济：进程创建所需要的内存和资源的分配比较昂贵</li><li>多处理器体系结构的利用：充分使用多处理器体系结构，以便每个进程能并行运行在不同的处理器</li></ul><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><blockquote><p>多对一模型：将许多用户线程映射到一个内核线程．</p><p>一对一模型：将每个用户线程映射到一个内核线程．</p><p>多对多模型：多路复用许多用户线程到同样数量或更小数量的内核线程上．</p></blockquote><p>现线程是进程内的控制流．多线程进程在同一地址被包括多个不同的控制流．</p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>　　每当服务器收到请求，他就创建一个独立线程以处理请求．虽然创建一个独立线程显然要比传建一个独立进程好，但是多线程服务器存在一些潜在的问题：（１）处理请求之前用以创建线程的时间，以及线程在完成工作后就要被丢弃这一事实；（２）如果允许所有并发请求都通过新线程来处理，那么将无法限制在系统中并发执行的线程的数量．无限制的线程会耗尽系统资源，如CPU时间和内存．</p><p>　　<strong>线程池</strong>是解决这个问题的一种方法，主要思想是：<strong>在进程开始时创建一定数量的线程，并放入池中等待工作．当服务器收到请求时，他会唤醒池红的一个线程，并将要处理的请求传递给它．一旦线程完成任务，他会返回到池中再等待工作．如果池中没有可以使用的线程，那么服务器会一直等待到有空线程为止．</strong>线程池的优点如下：</p><ul><li>通常用现有线程处理请求要比等待创建新的线程要快．</li><li>线程池限制了在任何时候可用线程的数量．</li></ul><h4 id="调度程序激活"><a href="#调度程序激活" class="headerlink" title="调度程序激活"></a>调度程序激活</h4><p>　　一种解决用户线程库与内核间通信的方法被称为调度器激活．工作方式：内核提供一组虚拟处理器给应用程序，应用程序可调度用户线程到一个可用的虚拟处理器上．</p><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><blockquote><p>进程是系统分配资源的单位，每一个进程对应一个活动的程序，当进程激活时，操作系统将系统的资源（内存、I/O和CPU等分配给它，使它执行）．</p><p>线程是CPU分配时间的单位，每一个线程对应于它在进程中的一个函数，也就是内存中的代码段，多个线程执行是CPU会根据他们的优先级分配时间，使它们完成自己的功能．</p></blockquote><ul><li>线程是比进程更小的能独立运行的单位，通常一个进程都有若干个线程，至少也需要一个线程．</li></ul><blockquote><p>调度：线程是调度和分派的基本单位，进程是资源拥有的单位．</p><p>并发性：进程之间可以并发执行，在一个线程中的多个线程之间也可以并发执行．</p><p>拥有资源：进程是拥有资源的一个独立单元，线程自己不拥有系统单元可以访问其隶属进程资源</p><p>系统开销：创建和撤销进程时，系统需要为之分配或回收资源，OS所付出的开销显著大于在创建或撤销线程时的开销；进程切换的开销也远大于线程切换的开销．</p></blockquote><ul><li>进程是指在系统中正在运行的一个应用程序；</li><li>线程是系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元。</li></ul><h3 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h3><p>　　CPU调度是多道程序操作系统的基础，在进程之间切换CPU,操作系统可以提高计算机的吞吐率．</p><p>　　CPU调度决策发生情景：</p><ul><li>当一个进程从运行状态切换到等待状态．</li><li>当一个进程从运行状态切换到就绪状态．</li><li>当一个进程从等待状态切换到就绪状态．</li><li>当一个进程终止时．</li></ul><h4 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h4><ul><li>CPU使用率：需要使CPU尽可能忙．</li><li>吞吐量：测量工作量的方法称为吞吐量，它指一个单元内所完成进程的数量．</li><li>周转时间：进程提交到进程完成的时间段．</li><li>等待时间：就绪队列中等待所花费的时间之和．</li><li>响应时间：从提交请求到产生第一想要的时间．</li></ul><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p><strong>单处理器系统CPU调度</strong></p><blockquote><p>先到先服务调度：先请求CPU的进程先分配到CPU，平均等待时间较长．</p><p>最短作业优先调度算法：将每个进程与下一个CPU区间段相关联．当CPU为空闲时，他会付给具有最短CPU区间的进程．</p><p>优先级调度：每一个进程都有一个优先级与其关联，具有最好优先级的进程会分配到CPU.</p><p>轮转法调度：为分时系统设计，类似于先到先服务调度，但是增加了抢占以切换进程．</p><p>多级队列调度：将就绪队列分成多个独立队列．根据进程的属性，如内存大小、进程优先级、一个进程被永久的分配到一个队列，每个队列有自己的调度算法．</p><p>多级反馈队列调度：允许进程在队列之间移动，根据不同CPU区间的特点以区分进程，如果进程使用过多CPU时间，他会被转移到更低优先级队列．</p></blockquote><p><strong>多处理器调度方法</strong></p><ul><li>非对称多处理：让一个处理器处理所有的调度决定、I/O处理以及其他系统活动，其他处理器只执行用户代码．</li><li>对称多处理：每个处理器自我调度，调度通过每个处理器检查共同就绪队列并选择一个进程来执行．</li></ul><p>　负载平衡设法将工作服在平均分配到对称多处理系统的所有处理器上．</p><h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>　　用户线程和内核线程的区别之一在于他们是如何被调度的．</p><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>　　协作进程是可以与在系统内执行的其他进程互相影响的进程．互相协作的进程可以直接共享逻辑地址空间（代码和数据），或者只通过文件或消息来共享数据．</p><h4 id="临界区问题"><a href="#临界区问题" class="headerlink" title="临界区问题"></a>临界区问题</h4><p>　　每个进程有一个代码段称为临界区，在该区中进程可能改变共同变量、更新一个表、写一个文件等．当一个进程进入临界区，没有其他进程可悲允许在临界区执行．</p><p>　　临界区满足三项要求：互斥、前进、有限等待．</p><p>　　处理操作系统内的临界区问题：抢占内核和非抢占内核．抢占内核更适合实时编程，因为它允许实时进程抢占处于内核模式运行的其他进程．抢占内核的相应更快，因为处于内核模式的进程在释放CPU之前不会运行过久．</p><h4 id="硬件同步"><a href="#硬件同步" class="headerlink" title="硬件同步"></a>硬件同步</h4><p>　　临界区的问题都需要一个简单的工具：锁．通过要求临界区用锁来防护，就可以避免竞争条件，即一个进程在进入临界区之前必须得到锁，而在其退出临界区时释放锁．</p><h4 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h4><ul><li>有限缓存问题</li><li>读者－写者问题</li><li>哲学家进餐问题</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>　　在多道程序环境下，多个进程可能竞争一定数量的资源．某个进程申请资源，如果这时资源不可用，那么该进程进入等待状态．若谷神奇的资源被其他等待进程占用，那么该等待进程有可能再也无法改变其状态．这种情况称为<strong>死锁(deadclock)</strong>.</p><h4 id="死锁特征"><a href="#死锁特征" class="headerlink" title="死锁特征"></a>死锁特征</h4><p>　<strong>　必要条件</strong></p><ul><li>互斥：至少一个资源必须处于非共享模式，即一次只有一个进程使用．如果了一个进程申请该资源，那么申请进程必须等到该资源被释放为止．</li><li>占有并等待：一个进程必须占有至少一个资源，并等待另一资源，二该资源为其他进程所占有．</li><li>非抢占：资源不能被抢占，即资源只能在进程完成任务后自动释放．</li><li>循环等待：有一组等待进程{p0,p1,…,pn}，p0等待的资源为p1占有，p1等待的资源为p2占有，．．．，pn等待的资源为p0占有．</li></ul><p>　上述四个条件必须全部满足才会出现死锁．循环等待条件意味着占有并等待条件，这样4个条件并不</p><p>完全独立．</p><h4 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h4><ul><li>使用协议以预防或避免死锁，确保系统不会进入死锁状态．</li><li>可允许系统进入死锁状态，然后检测它，并加以恢复．</li><li>可忽视这个问题，认为死锁不可能在系统内发生．</li></ul><p>为了确保思索不会发生，系统可采用死锁预防或死锁避免方案．</p><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p><strong>互斥</strong></p><p>对于非共享资源，必须要有互斥条件．例如：一台打印机不能同事为多个进程所共享．共享资源不要求互斥访问，一次不会死锁．</p><p><strong>占有并等待</strong></p><p>当一个进程申请一个资源时，它不能占有其他资源．一种可以使用的协议时每个进程在执行前申请并获得所以资源．另一种协议允许进程在没有资源时才可以申请资源．这两种协议的主要缺点：第一，资源利用率可能比较低，因为许多资源可能已分配，但是长时间没有被使用．第二，可能发生饥饿，一个进程如需要多个常用资源，可能会永久等待，因为其所需要的资源中至少有一个已分配给其他进程．</p><p><strong>非抢占</strong></p><p>如果一个进程占有资源并申请了一个不能立即分配的资源，那么其现已分配的资源都可能被强占．换句话说，这些资源都被隐式地释放了．如果一个进程申请一些资源，那么首先检查它们是否可用．如果可用，那么就分配它们；如果不可用，那么检查这些资源是否已分配给其他等待额外资源的进程．</p><p><strong>循环等待</strong></p><p>对所有资源类型进行完全排序，且要求每个进程按递增顺序来申请资源．</p><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>获得以后如何申请资源的附加信息，每次申请要求系统考虑现有可用资源、现已分配给每个进程的资源和每个进程将来申请与释放的资源，以决定当前申请是否满足或必须等待，从而避免死锁发生的可能性</p><p><strong>安全状态</strong></p><p>如果系统能按某个顺序诶每个进程分配资源（不超过其最大值）并能避免死锁，那么系统状态就是安全的．准确的说，如果存在一个安全写，那么系统处于安全状态．</p><ul><li><strong>资源分配图算法</strong> 　每种资源类型只有一个实例</li><li><strong>银行家算法</strong>　每种资源类型有多个实例</li></ul><h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><p>允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大 ．</p><h4 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h4><p>与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大．</p><h3 id="内存管理方式-段式页式和段页式"><a href="#内存管理方式-段式页式和段页式" class="headerlink" title="内存管理方式-段式页式和段页式"></a>内存管理方式-段式页式和段页式</h3><p>　　由于连续内存分配方式(单一连续分配，固定分区分配，动态分区分配，动态重定位分区分配)导致的内存利用率偏低以及内存碎片的问题，进而引出离散的内存分配方式。离散内存分配可以从OS的内存管理角度引出页式(离散分配的基本单位是页)管理，也可以从程序编制角度引出段式(离散分配的基本单位是段)管理。</p><h4 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h4><p>   　 基本分页存储管理中不具备页面置换功能(即没有实现虚拟内存的功能)，因此需要整个程序的所有页面都装入内存之后才可以运行。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个<strong>页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射</strong>。由于页表也是存储在内存中的，因此和不适用分页管理的存储方式相比，访问分页系统中内存数据需要两次的内存访问(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。<br>　　为了<strong>减少两次访问内存导致的效率影响，分页管理中引入了快表(或者联想寄存器)机制</strong>，包含快表机制的内存管理中，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中(可能存在快表换出算法)。<br>　　在某些<strong>计算机中如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间。为了解决这个问题，可以采用两级页表或者多级页表的方法</strong>，其中外层页表一次性调入内存且连续存放，内层页表离散存放。相应的访问内存页表的时候需要一次地址变换，访问逻辑地址对应的物理地址的时候也需要一次地址变换，而且一共需要访问内存3次才可以读取一次数据。</p><h4 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h4><p>　　分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。<br>　　分段内存管理当中，地址是二维的，一维是段号，一维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。段表中的每一个表项记录了该段在内存中的起始地址和该段的长度。段表可以放在内存中也可以放在寄存器中。<br>　　访问内存的时候根据段号和段表项的长度计算当前访问段在段表中的位置，然后访问段表，得到该段的物理地址，根据该物理地址以及段内偏移量就可以得到需要访问的内存。由于也是两次内存访问，所以分段管理中同样引入了联想寄存器。</p><h4 id="分页和分段对比"><a href="#分页和分段对比" class="headerlink" title="分页和分段对比"></a>分页和分段对比</h4><ul><li>页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；</li><li>段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制 </li><li>页的大小是固定的，由系统决定；</li><li>段的大小是不确定的，由用户决定 </li><li>页地址空间是一维的；</li><li>段地址空间是二维的</li></ul><h4 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h4><p>　　先将用户程序分为若干个段，然后再把每个段分成若干个页，并且为每一个段赋予一个段名称。这样在段页式管理中，一个内存地址就由段号，段内页号以及页内地址三个部分组成。<br>　　段页式内存访问：系统中设置了一个段表寄存器，存放段表的起始地址和段表的长度。地址变换时，根据给定的段号（还需要将段号和寄存器中的段表长度进行比较防止越界）以及寄存器中的段表起始地址，就可以得到该段对应的段表项，从段表项中得到该段对应的页表的起始地址，然后利用逻辑地址中的段内页号从页表中找到页表项，从该页表项中的物理块地址以及逻辑地址中的页内地址拼接出物理地址，最后用这个物理地址访问得到所需数据。由于访问一个数据需要三次内存访问，所以段页式管理中也引入了高速缓冲寄存器。</p><h3 id="虚拟内存及页面置换算法"><a href="#虚拟内存及页面置换算法" class="headerlink" title="虚拟内存及页面置换算法"></a>虚拟内存及页面置换算法</h3><p>　　如果存在一个程序，所需内存空间超过了计算机可以提供的实际内存，那么由于该程序无法装入内存所以也就无法运行。单纯的增加物理内存只能解决一部分问题，但是仍然会出现无法装入单个或者无法同时装入多个程序的问题。但是可以从逻辑的角度扩充内存容量，即可解决上述两种问题。</p><p>　　<strong>虚拟存储器就是具有请求调入功能和置换功能，可以从逻辑上对内存容量加以扩充的一种存储器系统。虚拟存储器都是建立在离散内存管理的基础上．</strong></p><p>虚拟存储器的特征：</p><ul><li>多次性：一个作业可以分多次被调入内存。多次性是虚拟存储特有的属性 ．</li><li>对换性：作业运行过程中存在换进换出的过程(换出暂时不用的数据换入需要的数据) ．</li><li>虚拟性：虚拟性体现在其从逻辑上扩充了内存的容量(可以运行实际内存需求比物理内存大的应用程序)。虚拟性是虚拟存储器的最重要特征也是其最终目标。虚拟性建立在多次性和对换性的基础上行，多次性和对换性又建立在离散分配的基础上．</li></ul><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ul><li>最佳置换算法：只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。</li><li>先进先出置换算法：简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面.</li><li>最近最久未使用算法LRU：算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现).</li><li>时钟算法clock(也被称为是最近未使用算法NRU)：页面设置一个访问为，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面.</li><li>改进型Clock算法：在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问为何修改位都是0的页面，其次是访问位为0修改位为1的页面。</li><li>最少使用算法LFU：设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。存在问题是该访问寄存器并不能真正反映当前页面访问次数，因为访问速度比较快，所以在更新寄存器的时间间隔内访问1次和访问100次都是一样的。另外，LFU和LRU是很类似的，支持硬件也是一样的，但是区分两者的关键在于一个以时间为标准，一个以次数为标准(例如对于寄存器 pa 001111 和pb 111000，两个页面，如果采用LRU，那么被淘汰的是pa，如果采用LFU那么被淘汰的是pb)。</li><li>页面缓冲算法PBA：置换的时候，页面无论是否被修改过，都不被置换到磁盘，而是先暂留在内存中的页面链表(已修改页面链表和未修改页面链表，也可以不区分)里面，当其再次被访问的时候可以直接从这些链表中取出而不必进行磁盘IO，当链表中已修改也难数目达到一定数量之后，进行依次写磁盘操作(相当于将多次IO合并为一次).</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;操作系统导论&quot;&gt;&lt;a href=&quot;#操作系统导论&quot; class=&quot;headerlink&quot; title=&quot;操作系统导论&quot;&gt;&lt;/a&gt;操作系统导论&lt;/h3&gt;&lt;p&gt;　　操作系统是管理和控制计算机硬件和软件资源的计算机程序．计算机系统大致可以分为四个组成部分：计算机硬件、操作系统、系统程序与应用程序和用户．计算机系统的组成部分包括硬件、软件和数据．操作系统是一直运行在计算机上的程序（通常称为内核kernel）．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作系统基本特征：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发：同一段时间内多个程序执行&lt;/li&gt;
&lt;li&gt;共享：系统中的资源可以被内存中多个并发执行的进线程共同使用  &lt;/li&gt;
&lt;li&gt;虚拟：通过分时复用以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个  &lt;/li&gt;
&lt;li&gt;异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="阅读" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读，操作系统" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>weight normalization</title>
    <link href="http://yoursite.com/2017/12/20/normalization/"/>
    <id>http://yoursite.com/2017/12/20/normalization/</id>
    <published>2017-12-20T10:49:25.000Z</published>
    <updated>2017-12-20T10:50:23.594Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>Weight normalization: a reparameterization of the weight vectors in a neural network that decouples the length of those weight vectors from their direction. Weight normalization does not introduce any dependencies between the training sets in a minibatch. It can be applied to RNN, DQN and GAN. It is a useful way to improve the conditioning of the optimization problem and speed up convergence of stochastic gradient descent.</p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>The practical success of first-order gradient based optimization is highly dependent on the curvature of the objective that is optimized. If the condition number of the Hessian matrix of the bojective at the optimum is low, the problem is said to exhibit pathological curvature, and first-order gradient descent will have trouble making progress . </p><a id="more"></a><h3 id="Weight-normalization"><a href="#Weight-normalization" class="headerlink" title="Weight normalization"></a>Weight normalization</h3><p>For an elementwise nonlinearity:</p><p><img src="../../../Pictures/datastructure/nonlinearity.png" alt="nonlinearity"></p><p>After associating  a loss function to one or more neuron outputs, such a neural netword is commonly trained by stochastic gradient descent in the parameters <strong>w</strong>, <strong>b</strong> of each neuron. In order to speef up the convergence of this optimization procedure, reparameterize each weight vector <strong>w</strong> in terms of a <strong>parameter vector v</strong> and a <strong>scalar parameter g</strong> and to o perform stochastic gradient descent with respect to those parameters instead.</p><p><img src="../../../Pictures/datastructure/weight_norm.png" alt="weight_norm"></p><p>||v|| denotes the Euclidean norm of <strong>v</strong>, fixing the  Euclidean norm of the weight vector <strong>w</strong>: we now have ||w|| = <strong>g</strong>, independent of the parameters  <strong>v</strong> . By decoupling the norm of the weight vector ( <strong>g</strong>) from the direction of the weight vector (<strong>v</strong>/||<strong>v</strong>||), we speed up convergence of our stochastic gradient descent optimization.</p><h4 id="Gradients"><a href="#Gradients" class="headerlink" title="Gradients"></a>Gradients</h4><p>Use standard stochastic gradient descent methods to obtain the gradient of a loss function L with respect to the new parameters <strong>v, g</strong> :</p><p><img src="../../../Pictures/datastructure/gradient.png" alt="gradient"></p><p><img src="../../../Pictures/datastructure/gradient_g.png" alt="gradient_g"></p><p><img src="../../../Pictures/datastructure/gradient_v.png" alt="gradient_v"></p><p><img src="../../../Pictures/datastructure/gradient_al.png" alt="gradient_al"></p><p> Weight normalization accomplishes two things:  it scales the weight gradient by **g/||v||＊＊,and it project the gradient away from the current weight vector.</p><p>Due to projecting away from <strong>w</strong>, the norm of <strong>v</strong> grows monotonically with the number of weight<br>updates when learning a neural network with weight normalization using standard gradient descent without momentum: </p><p><img src="../../../Pictures/datastructure/gradient_update.png" alt="gradient_update"></p><p>if <strong>||&amp;v||/||v||= c</strong>:</p><p><img src="../../../Pictures/datastructure/gradient_new_v.png" alt="gradient_new_v"></p><p>The rate of increase will depend on the the variance of the weight gradient. If our gradients are noisy, c will be high and the norm of v will quickly increase, which in turn will decrease the scaling factor  <strong>g/||v||</strong>; If the norm of the gradients is small, we get <strong>sqrt(1+ c*c)</strong> approximately equal to 1.</p><h3 id="pytorch-weight-norm"><a href="#pytorch-weight-norm" class="headerlink" title="pytorch weight_norm"></a>pytorch weight_norm</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch.utils.hooks <span class="keyword">as</span> hooks</div><div class="line"><span class="keyword">from</span> torch.nn.parameter <span class="keyword">import</span> Parameter</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeightNorm</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, dim)</span>:</span></div><div class="line">        self.name =name</div><div class="line">        self.dim = dim</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">computer_weight</span><span class="params">(self, module)</span>:</span></div><div class="line">        g = getattr(module, self.name+<span class="string">'_g'</span>)</div><div class="line">        v = getattr(module, self.name+<span class="string">'_v'</span>)</div><div class="line">        <span class="keyword">return</span> (g/self.norm(v))*v</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">norm</span><span class="params">(self, p)</span>:</span></div><div class="line">        <span class="string">"""Computes the norm over all dimensions except dim"""</span></div><div class="line">        <span class="keyword">if</span> self.dim <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> p.norm()</div><div class="line">        <span class="keyword">if</span> self.dim != <span class="number">0</span>:</div><div class="line">            p = p.transpose(<span class="number">0</span>, self.dim)</div><div class="line">        output_size = (p.size(<span class="number">0</span>),)+(<span class="number">1</span>,)*(p.dim()<span class="number">-1</span>)  <span class="comment"># delete dim dimension</span></div><div class="line">        p = p.contiguous().view(p.size(<span class="number">0</span>), <span class="number">-1</span>).norm(dim=<span class="number">1</span>).view(*output_size)</div><div class="line">        <span class="keyword">if</span> self.dim != <span class="number">0</span>:</div><div class="line">            p = p.transpose(<span class="number">0</span>, self.dim)</div><div class="line">        <span class="keyword">return</span> p</div><div class="line"></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span><span class="params">(modula, name, dim)</span>:</span></div><div class="line">        fn = WeightNorm(name, dim)</div><div class="line"></div><div class="line">        weight = getattr(module, name)</div><div class="line"></div><div class="line">        <span class="comment"># remove w from parameter list</span></div><div class="line">        <span class="keyword">del</span> module._parameters[name]</div><div class="line"></div><div class="line">        <span class="comment"># add g and v as new parameters and express w as g/||v|| * v</span></div><div class="line">        module.register_parameter(name + <span class="string">'_g'</span>, Parameter(fn.norm(weight).data))</div><div class="line">        module.register_parameter(name + <span class="string">'_v'</span>, Parameter(weight.data))</div><div class="line">        setattr(module, name, fn.computer_weight(module))</div><div class="line"></div><div class="line">        handle = hooks.RemovableHandle(module._forward_pre_hooks)</div><div class="line">        module._forward_pre_hooks[handle.id] = fn</div><div class="line">        fn.handle = handle</div><div class="line"></div><div class="line">        <span class="keyword">return</span>  fn</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, module, inputs)</span>:</span></div><div class="line">        setattr(module, self.name, self.computer_weight(module))</div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line"><span class="string">   example</span></div><div class="line"><span class="string">'''</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight_norm</span><span class="params">(module, name=<span class="string">'weight'</span>, dim=<span class="number">0</span>)</span>:</span></div><div class="line"></div><div class="line">    WeightNorm.apply(module, name, dim)</div><div class="line">    <span class="keyword">return</span> module</div><div class="line"></div><div class="line"><span class="string">''' </span></div><div class="line"><span class="string">    &gt;&gt;&gt; import torch.nn as nn</span></div><div class="line"><span class="string">    &gt;&gt;&gt; m = weight_norm(nn.Linear(20, 40), name='weight')</span></div><div class="line"><span class="string">        Linear (20 -&gt; 40)</span></div><div class="line"><span class="string">    &gt;&gt;&gt; m.weight_g.size()</span></div><div class="line"><span class="string">        torch.Size([40, 1])</span></div><div class="line"><span class="string">    &gt;&gt;&gt; m.weight_v.size()</span></div><div class="line"><span class="string">        torch.Size([40, 20])</span></div><div class="line"><span class="string">'''</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;Weight normalization: a reparameterization of the weight vectors in a neural network that decouples the length of those weight vectors from their direction. Weight normalization does not introduce any dependencies between the training sets in a minibatch. It can be applied to RNN, DQN and GAN. It is a useful way to improve the conditioning of the optimization problem and speed up convergence of stochastic gradient descent.&lt;/p&gt;
&lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;The practical success of first-order gradient based optimization is highly dependent on the curvature of the objective that is optimized. If the condition number of the Hessian matrix of the bojective at the optimum is low, the problem is said to exhibit pathological curvature, and first-order gradient descent will have trouble making progress . &lt;/p&gt;
    
    </summary>
    
      <category term="论文" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="论文，deep learning" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87%EF%BC%8Cdeep-learning/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode</title>
    <link href="http://yoursite.com/2017/12/18/leetcode/"/>
    <id>http://yoursite.com/2017/12/18/leetcode/</id>
    <published>2017-12-18T14:00:54.000Z</published>
    <updated>2017-12-18T14:34:11.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h2><h3 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h3><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Given nums = [2, 7, 11, 15], target = 9,</div><div class="line"></div><div class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line">return [0, 1].</div></pre></td></tr></table></figure><a id="more"></a><p><strong>思路</strong></p><p>题意是让你从给定的数组中找到两个元素的和为指定值的两个索引，<strong>利用HashMap作为存储，键为目标值减去当前元素值，索引为值</strong>，比如<code>i = 0</code>时，此时首先要判断<code>nums[0] = 2</code>是否在map中，如果不存在，那么插入键值对<code>key = 9 - 2 = 7, value = 0</code>，之后当<code>i = 1</code>时，此时判断<code>nums[1] = 7</code>已存在于map中，那么取出该<code>value = 0</code>作为第一个返回值，当前<code>i</code>作为第二个返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">int</span> len = nums.length;　　　　<span class="comment">//数组长度</span></div><div class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="comment">//新建HashMap</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;len; i++)&#123;</div><div class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;　　　　<span class="comment">//遍历数组中的元素是否在HashMap中</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(nums[i]),i&#125;;</div><div class="line">            &#125;</div><div class="line">            map.put(target - nums[i],i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a>26. Remove Duplicates from Sorted Array</h3><p>Given a sorted array, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="external"><strong>in-place</strong></a> such that each element appear only <em>once</em> and return the new length.Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p>For example,<br>Given input array <em>nums</em> = <code>[1,1,2]</code>,</p><p>Your function should return length = <code>2</code>, with the first two elements of <em>nums</em> being <code>1</code> and <code>2</code> respectively. It doesn’t matter what you leave beyond the new length.</p><p><strong>思路</strong></p><p>题意是让你从一个有序的数组中移除重复的元素，并返回之后数组的长度。我的思路是：首先判断如果数组长度等于0的话直接返回原长度即可，否则的话遍历一遍数组，用一个<code>index</code>变量指向尾部，如果后面的元素和前面的元素不同，就让<code>index</code>变量加1，最后返回<code>index</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = nums.size();    <span class="comment">//输出数组长度</span></div><div class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> len;</div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;　　　　　　 <span class="comment">//index</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;　　　　<span class="comment">//遍历数组</span></div><div class="line">            <span class="keyword">if</span>(nums[index]!=nums[i])&#123;　　</div><div class="line">                nums[++index] = nums[i];  <span class="comment">//判断后面的元素是否和前面的相同</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> index+<span class="number">1</span>;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a>27. Remove Element</h3><p>Given an array and a value, remove all instances of that value <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="external"><strong>in-place</strong></a> and return the new length.</p><p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array in-place</strong> with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Given nums = [3,2,2,3], val = 3,</div><div class="line"></div><div class="line">Your function should return length=2, with the first two elements of nums being 2.</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是移除数组中值等于<code>val</code>的元素，并返回之后数组的长度，并且题目中指定空间复杂度为O(1)，我的思路是用<code>index</code>标记尾部，遍历该数组时当索引元素不等于<code>val</code>时，<code>index</code>加一，尾部指向当前元素，最后返回<code>index</code>即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i]!= val)&#123;</div><div class="line">                nums[index++]=nums[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> index;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a>33. Search in Rotated Sorted Array</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>0 1 2 4 5 6 7</code> might become <code>4 5 6 7 0 1 2</code>).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p><p><strong>思路</strong></p><p>题意是让你从一个旋转过后的递增序列中寻找给定值，找到返回索引，找不到返回-1，我们在下面这组数据中寻找规律。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1 2 4 5 6 7 0</div><div class="line">2 4 5 6 7 0 1</div><div class="line">4 5 6 7 0 1 2</div><div class="line">5 6 7 0 1 2 4</div><div class="line">6 7 0 1 2 4 5</div><div class="line">7 0 1 2 4 5 6</div></pre></td></tr></table></figure><p>由于是旋转一次，所以肯定有一半及以上的序列仍然是具有递增性质的，我们观察到如果中间的数比左面的数大的话，那么左半部分序列是递增的，否则右半部分就是递增的，那么我们就可以确定给定值是否在递增序列中，从而决定取舍哪半边。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> left=<span class="number">0</span>, right = nums.size();</div><div class="line">        <span class="keyword">while</span>(left != right)&#123;</div><div class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</div><div class="line">            <span class="keyword">if</span>(nums[left]&lt;=nums[mid])&#123;</div><div class="line">                <span class="keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;=nums[mid])&#123;</div><div class="line">                    right = mid;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    left = mid+<span class="number">1</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[right<span class="number">-1</span>])&#123;</div><div class="line">                    left = mid+<span class="number">1</span>;</div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    right = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h3><p>Given an array <em>S</em> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <em>S</em> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">For example, given array S = [-1, 0, 1, 2, -1, -4],</div><div class="line"></div><div class="line">A solution set is:</div><div class="line">[</div><div class="line">  [-1, 0, 1],</div><div class="line">  [-1, -1, 2]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是让你从数组中找出所有三个和为0的元素构成的非重复序列，这样的话我们可以把数组先做下排序，然后遍历这个排序数组，用两个指针分别指向当前元素的下一个和数组尾部，判断三者和与0的大小来移动两个指针，其中细节操作就是注意去重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</div><div class="line">        Arrays.sort(nums);</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i&lt;nums.length-<span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>, right = nums.length-<span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</div><div class="line">                <span class="keyword">int</span> sum = nums[i]+nums[left]+nums[right];</div><div class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</div><div class="line">                    list.add(Arrays.asList(nums[i],nums[left++],nums[right--]));</div><div class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left-<span class="number">1</span>]) ++left;</div><div class="line">                    <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>]) --right;</div><div class="line">                    </div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span> ) ++left;</div><div class="line">                <span class="keyword">else</span> --right;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(nums[i] == nums[++i] &amp;&amp; i&lt;nums.length -<span class="number">2</span>);</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16. 3Sum Closest"></a>16. 3Sum Closest</h3><p>Given an array <em>S</em> of <em>n</em> integers, find three integers in <em>S</em> such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.</div><div class="line"></div><div class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是让我们求最接近给定值的三数之和，是在之前那道3Sum三数之和的基础上又增加了些许难度，那么这道题让我们返回这个最接近于给定值的值，即我们要保证当前三数和跟给定值之间的差的绝对值最小，所以我们需要定义一个变量Ａ用来记录差的绝对值，然后我们还是要先将数组排个序，然后开始遍历数组，思路跟那道三数之和很相似，都是先确定一个数，然后用两个指针left和right来滑动寻找另外两个数，每确定两个数，我们求出此三数之和，然后算和给定值的差的绝对值存在newＡ中，然后和Ａ比较并更新Ａ和结果closest即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> closest = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>];</div><div class="line">        <span class="keyword">int</span> A = <span class="built_in">abs</span>(closest-target);</div><div class="line">        sort(nums.begin(),nums.end());</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size()<span class="number">-2</span>; i++)&#123;</div><div class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>, right = nums.size()<span class="number">-1</span>;</div><div class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</div><div class="line">                <span class="keyword">int</span> sum = nums[i]+nums[left]+nums[right];</div><div class="line">                <span class="keyword">int</span> newA = <span class="built_in">abs</span>(sum-target);</div><div class="line">                <span class="keyword">if</span>(A&gt;newA)&#123;</div><div class="line">                    A = newA;</div><div class="line">                    closest = sum;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(sum&lt;target) ++left;</div><div class="line">                <span class="keyword">else</span> --right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> closest;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a>53. Maximum Subarray</h3><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p><p>For example, given the array <code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br>the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.</p><p><strong>思路</strong></p><p>题意是求数组中子数组的最大和，利用动态规划的方法去求解。当部分序列和大于0的话就一直加下一个元素，并和当前最大值进行比较，如果出现部分序列小于０，那就需要从当前元素算起。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = nums.size(), init = nums[<span class="number">0</span>], max = init;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</div><div class="line">            init = nums[i]+(init&gt;<span class="number">0</span> ? init:<span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span>(init&gt;max) max = init;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> max;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38. Count and Say"></a>38. Count and Say</h3><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.     1</div><div class="line">2.     11</div><div class="line">3.     21</div><div class="line">4.     1211</div><div class="line">5.     111221</div></pre></td></tr></table></figure><p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2</code>, then <code>one 1&quot;</code> or <code>1211</code>.</p><p>Given an integer <em>n</em>, generate the <em>n</em>th term of the count-and-say sequence.</p><p>Note: Each term of the sequence of integers will be represented as a string.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 1</div><div class="line">Output: &quot;1&quot;</div></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 4</div><div class="line">Output: &quot;1211&quot;</div></pre></td></tr></table></figure><h3 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h3><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>思想</strong></p><p>题意是用一个新链表来合并两个已排序的链表，那我们只需要从头开始比较已排序的两个链表，新链表指针每次指向值小的节点，依次比较下去，最后，当其中一个链表到达了末尾，我们只需要把新链表指针指向另一个没有到末尾的链表此时的指针即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * public class ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</div><div class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode tmp = head;</div><div class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</div><div class="line">                tmp.next = l1;</div><div class="line">                l1 = l1.next;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                tmp.next = l2;</div><div class="line">                l2 = l2.next;</div><div class="line">            &#125;</div><div class="line">            tmp = tmp.next;</div><div class="line">        &#125;</div><div class="line">        tmp.next = l1 !=<span class="keyword">null</span> ? l1:l2;</div><div class="line">        <span class="keyword">return</span> head.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h3><p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em>, where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and <em>n</em> is at least 2.</p><p><strong>思路</strong></p><p>木桶的容积取决于短板的高度。首先计算最左边（left）和最右边（right）组成的木桶的面积，并把它设置为maxArea。在left&lt;right的情况下，首先判断height[left]和height[right]值的大小，若height[left]&lt;height[right]，则height取值向右边移动，同时计算每移动一步后新的Area的面积并与maxArea做比较，得出新的最大面积；反之，则height取值向左边移动，重复上一步操作。最终得到最大的区域积。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right =height.size()<span class="number">-1</span>; </div><div class="line">        <span class="keyword">int</span> maxArea = (right-left)*min(height[left],height[right]);</div><div class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</div><div class="line">            <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</div><div class="line">                left++;</div><div class="line">                <span class="keyword">int</span> Area1 = (right-left)*min(height[left],height[right]);</div><div class="line">                <span class="keyword">if</span>(Area1&gt;maxArea)&#123;</div><div class="line">                    maxArea = Area1;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                right--;</div><div class="line">                <span class="keyword">int</span> Area2 = (right-left)*min(height[left],height[right]);</div><div class="line">                <span class="keyword">if</span>(Area2&gt;maxArea)&#123;</div><div class="line">                    maxArea = Area2;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxArea;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h3><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p><strong>思路</strong></p><p>题意是编写一个函数来查找字符串数组中最长的公共前缀字符串。利用纵向扫描，对每一个位置比较所以字符串，直到遇到一个不匹配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(strs.empty()) <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx&lt;strs[<span class="number">0</span>].size(); idx++)&#123;  <span class="comment">//纵向扫描数组</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;strs.size(); i++)&#123;</div><div class="line">                <span class="keyword">if</span>(strs[i][idx] != strs[<span class="number">0</span>][idx]) <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>,idx);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//strs = ['make fun','make love','main idea'];</span></div><div class="line"><span class="comment">//strs[0] = 'make fun' thus idx (0~8);</span></div><div class="line"><span class="comment">//strs.size() = 3; </span></div><div class="line"><span class="comment">//strs[i][idx],strs[0][idx]中，保持idx不变，比较纵列是否相同。</span></div><div class="line"><span class="comment">//strs[0].substr(0,idx)　substr(截取开始位置,截取长度)。</span></div></pre></td></tr></table></figure><h3 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a>9. Palindrome Number</h3><p>Determine whether an integer is a palindrome. Do this without extra space.</p><p><strong>Some hints:</strong></p><p>Could negative integers be palindromes? (ie, -1)</p><p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p><p>You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?</p><p>There is a more generic way of solving this problem.</p><p><strong>思路</strong></p><p>题意是判断一个有符号整型数是否是回文，也就是逆序过来的整数和原整数相同，首先负数肯定不是，接下来我们直接算出他的回文数，然后和给定值比较即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">int</span> s = x, reverse = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(s&gt;<span class="number">0</span>)&#123;</div><div class="line">            reverse = reverse*<span class="number">10</span>+s%<span class="number">10</span>;</div><div class="line">            s/=<span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> x == reverse;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//reverse = 1      reverse = 12      reverse=123      reverse=1234</span></div><div class="line"><span class="comment">//reverse = 12344  reverse = 123443  reverse=1234432  reverse=12344321</span></div></pre></td></tr></table></figure><h3 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35. Search Insert Position"></a>35. Search Insert Position</h3><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [1,3,5,6], 5</div><div class="line">Output: 2</div></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [1,3,5,6], 2</div><div class="line">Output: 1</div></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [1,3,5,6], 7</div><div class="line">Output: 4</div></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [1,3,5,6], 0</div><div class="line">Output: 0</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是给定一个有序数组和一个目标值，如果找到目标，则返回索引。如果没有，则返回按顺序插入的索引。解题思路：首先遍历数组，若当前数字大于或等于目标值，则返回当前坐标，如果遍历结束了，说明目标值比数组中任何一个数都要大，则返回数组长度n即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[i]&gt;=target) <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums.size();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48.  Rotate Image"></a>48.  Rotate Image</h3><p>You are given an <em>n</em> x <em>n</em> 2D matrix representing an image.</p><p>Rotate the image by 90 degrees (clockwise).</p><p><strong>Note:</strong><br>You have to rotate the image <strong>in-place</strong>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Given input matrix = </div><div class="line">[</div><div class="line">  [1,2,3],</div><div class="line">  [4,5,6],</div><div class="line">  [7,8,9]</div><div class="line">],</div><div class="line"></div><div class="line">rotate the input matrix in-place such that it becomes:</div><div class="line">[</div><div class="line">  [7,4,1],</div><div class="line">  [8,5,2],</div><div class="line">  [9,6,3]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Given input matrix =</div><div class="line">[</div><div class="line">  [ 5, 1, 9,11],</div><div class="line">  [ 2, 4, 8,10],</div><div class="line">  [13, 3, 6, 7],</div><div class="line">  [15,14,12,16]</div><div class="line">], </div><div class="line"></div><div class="line">rotate the input matrix in-place such that it becomes:</div><div class="line">[</div><div class="line">  [15,13, 2, 5],</div><div class="line">  [14, 3, 4, 1],</div><div class="line">  [12, 6, 8, 9],</div><div class="line">  [16, 7,10,11]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是给定一个n*n个2维矩阵来表示一个图。在原矩阵上旋转图形90°。主要思路是，首先沿着矩阵副对角线翻转一次，然后沿着水平线翻转一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i, j, temp;</div><div class="line">        <span class="keyword">int</span> n = matrix.size();</div><div class="line">        # 沿着矩阵副对角线翻转</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n-i; ++j)&#123;</div><div class="line">                temp = matrix[i][j];</div><div class="line">                matrix[i][j] = matrix[n-j<span class="number">-1</span>][n-i<span class="number">-1</span>];</div><div class="line">                matrix[n-j<span class="number">-1</span>][n-i<span class="number">-1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        # 沿着水平线翻转</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n/<span class="number">2</span>; ++i)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</div><div class="line">                temp = matrix[i][j];</div><div class="line">                matrix[i][j] = matrix[n-i<span class="number">-1</span>][j];</div><div class="line">                matrix[n-i<span class="number">-1</span>][j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="34-Search-for-a-Range"><a href="#34-Search-for-a-Range" class="headerlink" title="34. Search for a Range"></a>34. Search for a Range</h3><p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p><p>Your algorithm’s runtime complexity must be in the order of <em>O</em>(log <em>n</em>).</p><p>If the target is not found in the array, return <code>[-1, -1]</code>.</p><p>For example,<br>Given <code>[5, 7, 7, 8, 8, 10]</code> and target value 8,<br>return <code>[3, 4]</code>.</p><p><strong>思路</strong></p><p>题意是给定按升序排序的整数数组，找到给定目标值的开始和结束位置。其中算法的运行时复杂度必须按照O（log n）的顺序。如果在数组中找不到目标，则返回[-1，-1]。首先，建立二元结果数组Ａ，左边left,右边right。二分法求左边界：当中点小于target，left移向中点，否则right移向中点；先判断左边，再判断右边是否等于target，如果是，赋值给Ａ[0]。二分法求右边界：当中点大于target，right移向中点，否则left移向中点；先判断右边，再判断左边是否等于target，如果是，赋值给Ａ[1]。返回Ａ。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">        <span class="keyword">int</span>[] A = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</div><div class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right = n-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(nums[left]&lt;nums[right])&#123;</div><div class="line">            <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid]&lt;target) left = mid+<span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target) right = mid-<span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">if</span>(nums[left]&lt;target) left++;</div><div class="line">                <span class="keyword">if</span>(nums[right]&gt;target) right--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(nums[left] == target)&#123;</div><div class="line">            A[<span class="number">0</span>] = left;</div><div class="line">            A[<span class="number">1</span>] = right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> A;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66. Plus One"></a>66. Plus One</h3><p>Given a non-negative integer represented as a <strong>non-empty</strong> array of digits, plus one to the integer.</p><p>You may assume the integer do not contain any leading zero, except the number 0 itself.</p><p>The digits are stored such that the most significant digit is at the head of the list.</p><p><strong>思路</strong></p><p>题意是给定一个数组表示非负整数，其高位在数组的前面，对这个整数加1。使用大数加法，遍历数组的每一位，同时处理进位，如果最后还有进位，则在数组最前面插入１即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</div><div class="line">        <span class="keyword">int</span> c = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> n = digits.size();</div><div class="line">      　＃ 遍历数组的每一位</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</div><div class="line">            <span class="keyword">int</span> a = digits[i]+c;</div><div class="line">            digits[i] = a % <span class="number">10</span>;</div><div class="line">          　<span class="comment">// 做进位处理</span></div><div class="line">            c = a/<span class="number">10</span>; </div><div class="line">            <span class="comment">// 用于判断最后是否还有进位，值为０或１．</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(c == <span class="number">1</span>)&#123;</div><div class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</div><div class="line">            <span class="comment">// 在数组最前面插入１．</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> digits;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h3><p>Say you have an array for which the $i^{th}$ element is the price of a given stock on day <em>i</em>.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: [7, 1, 5, 3, 6, 4]</div><div class="line">Output: 5</div><div class="line"></div><div class="line">max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</div></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: [7, 6, 4, 3, 1]</div><div class="line">Output: 0</div><div class="line"></div><div class="line">In this case, no transaction is done, i.e. max profit = 0.</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是假设有一个数组，数组中的元素是第i天给定股票的价格，如果最多只能完成最多一笔交易（买入或者卖出一股股票），设计一个算法来找到最大的利润值。首先初始化利润值为０，假定当前的最小值cur_min为数组中的第一个数值，遍历当前数组，取初始化利润值与prices[i]-cur_min中较大值作为新的profit，取cur_min和prices[i]中较小的值作为新的cur_min，迭代最终得到最大的profit。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = prices.size();</div><div class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>; <span class="comment">// 初始化利润值.</span></div><div class="line">        <span class="keyword">int</span> cur_min = prices[<span class="number">0</span>];  <span class="comment">// 当前的最小股票值</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</div><div class="line">            profit = max(profit, prices[i]-cur_min);</div><div class="line">            cur_min = min(cur_min, prices[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> profit;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h3><p>Say you have an array for which the $i^{th}$ element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><p><strong>思路</strong></p><p>题意是设计一个算法来找到最大的利润，可以根据需要完成尽可能多的交易（即多次买入和卖出一次股票）。但是不可以同时进行多笔交易（即您必须在再次购买之前出售股票）。因为买一次接着卖一次，所以只要计算买卖一次的利润值，对利润值大于０的进行求和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = prices.size();</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++)&#123;</div><div class="line">            <span class="keyword">int</span> profit = prices[i]-prices[i<span class="number">-1</span>];</div><div class="line">            <span class="keyword">if</span>(profit&gt;<span class="number">0</span>) sum += profit;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="118-Pascal’s-Triangle"><a href="#118-Pascal’s-Triangle" class="headerlink" title="118.  Pascal’s Triangle"></a>118.  Pascal’s Triangle</h3><p>Given <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p><p>For example, given <em>numRows</em> = 5,<br>Return</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">     [1],</div><div class="line">    [1,1],</div><div class="line">   [1,2,1],</div><div class="line">  [1,3,3,1],</div><div class="line"> [1,4,6,4,1]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意是生成帕斯卡三角形，我们可以发现，从第三行开始，该行中的值等于上一行的左上角和右上角之和，利用这个规律进行求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="comment">//在vector&lt;vector&lt;int&gt;&gt;中，因为vector是一个容器，最外层的vector容器中放着更小的             vector，而里层的vector里面放的是int型的数字。所以我们首先要对里层的vector容器赋           值，然后再把里层的vector作为元素插入到外层的vector中。</span></div><div class="line">        <span class="keyword">if</span>(numRows == <span class="number">0</span>) <span class="keyword">return</span> result; </div><div class="line">        result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">1</span>));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=numRows; i++)&#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; current(i,<span class="number">1</span>);  <span class="comment">//本行</span></div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pre = result[i<span class="number">-2</span>]; <span class="comment">//　上一行</span></div><div class="line">            </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i<span class="number">-1</span>; j++)&#123;</div><div class="line">                current[j] = pre[j<span class="number">-1</span>]+pre[j];　<span class="comment">//左上角和右上角之和</span></div><div class="line">            &#125;</div><div class="line">            result.push_back(current);　<span class="comment">//在vector类中作用为在vector尾部加入一个数据</span></div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="119-Pascal’s-Triangle-II"><a href="#119-Pascal’s-Triangle-II" class="headerlink" title="119. Pascal’s Triangle II"></a>119. Pascal’s Triangle II</h3><p>Given an index <em>k</em>, return the $k^th$ row of the Pascal’s triangle.</p><p>For example, given <em>k</em> = 3, Return <code>[1,3,3,1]</code>.</p><p><strong>思路</strong></p><p>题意是生成帕斯卡三角形中的某一列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=rowIndex; i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;<span class="number">0</span>; j--)&#123;</div><div class="line">                <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j<span class="number">-1</span>]+<span class="built_in">array</span>[j];</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">array</span>.push_back(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">array</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h3><p>Given a <strong>set</strong> of candidate numbers (<strong>C</strong>) <strong>(without duplicates)</strong> and a target number (<strong>T</strong>), find all unique combinations in <strong>C</strong> where the candidate numbers sums to <strong>T</strong>.</p><p>The <strong>same</strong> repeated number may be chosen from <strong>C</strong> unlimited number of times.</p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>For example, given candidate set <code>[2, 3, 6, 7]</code> and target <code>7</code>,<br>A solution set is: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [7],</div><div class="line">  [2, 2, 3]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意：给定一个正数集合和一个目标数，求出所有的子集合，使子集的和为target，要求子集合递增排列，且不包含重复的子集合，子集合中的数字可以重复。我们需要写一个递归函数，在这个函数中需要添加三个变量，result记录最终的结果，path记录中间的一个解，start记录当前递归到的下标。调用递归函数时，target要减去当前数组的数，为了减小计算量，进行相应的剪枝处理，即大于target,就减去。数组中的那个值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</div><div class="line">        sort(candidates.begin(), candidates.end());</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result; <span class="comment">//final result</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;   <span class="comment">// path result</span></div><div class="line">        combsum(candidates, path, result, target, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combsum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;     <span class="comment">// find the suitable solution</span></div><div class="line">            result.push_back(path);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;candidates.size(); i++)&#123;</div><div class="line">            <span class="keyword">if</span>(target&lt;candidates[i]) <span class="keyword">return</span> ;   <span class="comment">//pruning</span></div><div class="line">            </div><div class="line">            path.push_back(candidates[i]);</div><div class="line">            combsum(candidates, path, result, target-candidates[i],i);</div><div class="line">            path.pop_back();    </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a>40. Combination Sum II</h3><p>Given a collection of candidate numbers (<strong>C</strong>) and a target number (<strong>T</strong>), find all unique combinations in <strong>C</strong> where the candidate numbers sums to <strong>T</strong>.</p><p>Each number in <strong>C</strong> may only be used <strong>once</strong> in the combination.</p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>For example, given candidate set <code>[10, 1, 2, 7, 6, 1, 5]</code> and target <code>8</code>,<br>A solution set is: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [1, 7],</div><div class="line">  [1, 2, 5],</div><div class="line">  [2, 6],</div><div class="line">  [1, 1, 6]</div><div class="line">]</div></pre></td></tr></table></figure><p><strong>思路</strong></p><p>题意：给定一个正数集合和一个目标数，求出所有的子集合，使子集的和为target，要求子集合递增排列，且不包含重复的子集合，子集合中的数字也不可以重复。与上一个题目差不多，需要加一个判断，如果上一轮循环已经使用candidates[i]，本次循环就不能再选candidates[i]，确保candidates[i]最多循环一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</div><div class="line">        sort(candidates.begin(), candidates.end());</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</div><div class="line">        combsum(candidates, path, result, target, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combsum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</div><div class="line">            result.push_back(path);</div><div class="line">            <span class="keyword">return</span> ;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> previous = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;candidates.size(); i++)&#123;</div><div class="line">            <span class="comment">// if previous loop has used candidates[i], </span></div><div class="line">            <span class="comment">// in this loop candidates[i] can not be used</span></div><div class="line">            <span class="keyword">if</span>(previous == candidates[i]) <span class="keyword">continue</span>;    </div><div class="line">            <span class="keyword">if</span>(target&lt;candidates[i]) <span class="keyword">return</span> ;  <span class="comment">//pruning</span></div><div class="line">            </div><div class="line">            previous = candidates[i];</div><div class="line">            </div><div class="line">            path.push_back(candidates[i]);</div><div class="line">            combsum(candidates, path, result, target-candidates[i], i+<span class="number">1</span>);</div><div class="line">            path.pop_back();</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode&quot;&gt;&lt;a href=&quot;#Leetcode&quot; class=&quot;headerlink&quot; title=&quot;Leetcode&quot;&gt;&lt;/a&gt;Leetcode&lt;/h2&gt;&lt;h3 id=&quot;1-Two-Sum&quot;&gt;&lt;a href=&quot;#1-Two-Sum&quot; class=&quot;headerlink&quot; title=&quot;1. Two Sum&quot;&gt;&lt;/a&gt;1. Two Sum&lt;/h3&gt;&lt;p&gt;Given an array of integers, return &lt;strong&gt;indices&lt;/strong&gt; of the two numbers such that they add up to a specific target.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have &lt;strong&gt;exactly&lt;/strong&gt; one solution, and you may not use the &lt;em&gt;same&lt;/em&gt; element twice.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Given nums = [2, 7, 11, 15], target = 9,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Because nums[0] + nums[1] = 2 + 7 = 9,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;return [0, 1].&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程，Leetcode" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%EF%BC%8CLeetcode/"/>
    
  </entry>
  
  <entry>
    <title>Forward Neural Network</title>
    <link href="http://yoursite.com/2017/12/17/Forward%20Neural%20Network/"/>
    <id>http://yoursite.com/2017/12/17/Forward Neural Network/</id>
    <published>2017-12-17T12:57:56.157Z</published>
    <updated>2017-12-17T12:57:56.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深度学习应用于自然语言处理-前向神经网络"><a href="#深度学习应用于自然语言处理-前向神经网络" class="headerlink" title="深度学习应用于自然语言处理-前向神经网络"></a>深度学习应用于自然语言处理-前向神经网络</h2><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>深度学习的浪潮袭来，现已在各个领域中应用。深度学习的表现令人叹为观止，不得不说我们迎来了依靠深度学习的人工智能学习时代。</p><blockquote><p>　人工智能，让世界更美好。</p></blockquote><p>这一章主要是通过学习 <a href="http://cs224d.stanford.edu/" target="_blank" rel="external">Stanford cs224d</a> 课程已经阅读一些有些的博客所作出的总结。</p><a id="more"></a><h2 id="本章介绍"><a href="#本章介绍" class="headerlink" title="本章介绍"></a>本章介绍</h2><p>从数学的角度对前向神经网络数学模型进行介绍、推导和证明。</p><h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><p><a href="http://cs229.stanford.edu/section/cs229-linalg.pdf" target="_blank" rel="external">线性代数(Linear Algebra)</a><br><a href="http://cs229.stanford.edu/section/cs229-prob.pdf" target="_blank" rel="external">概率论(Probability Theory)</a><br><a href="http://cs229.stanford.edu/section/cs229-cvxopt.pdf" target="_blank" rel="external">凸优化(Convex Optimization)</a></p><h2 id="前向神经网络"><a href="#前向神经网络" class="headerlink" title="前向神经网络"></a>前向神经网络</h2><p>所谓神经网络就是将许多个单一“神经元”联结在一起，这样，一个“神经元”的输出就可以是另一个“神经元”的输入。以下是一个简单的<strong>三层前向全连接神经网络：</strong></p><p><img src="http://oddpnmpll.bkt.clouddn.com/2016-10-18-14%3A47%3A20.jpg" alt="neural networks"></p><p>图中<strong>x</strong>为输入层，<strong>h</strong>为隐藏层，$\hat{y}$为输出层。在全连接网络中，上一层和下一层的每个神经元都相连。隐藏层在接收到输入x后会进行一个非线性变化，再将输出信号传递给下一层。非线性变换由激活函数(activation function)实现。在数学上，我们可以用矩阵乘法（Matrix multiplication）来解释:</p><script type="math/tex; mode=display">\begin{align*}\boldsymbol{h} &= \text{sigmoid}(\boldsymbol{xW}_1+\boldsymbol{b}_1)\\\boldsymbol{\hat{y}} &= \text{softmax}(\boldsymbol{hW}_2+\boldsymbol{b}_2)\\\end{align*}</script><p>式中<strong>sigmoid</strong>和<strong>softmax</strong>都是一个激活函数,<strong>W</strong>是指两层之间的权重，<strong>b</strong>是偏置量。我们可以看到<strong>x</strong>进行了线性变换后，再做非线性变换，<strong>x</strong>输出的信号将作为<strong>b</strong>的输入。</p><h3 id="激活函数-Activation-fuction"><a href="#激活函数-Activation-fuction" class="headerlink" title="激活函数(Activation fuction)"></a>激活函数(Activation fuction)</h3><p>激活函数的作用是能够给神经网络加入一些非线性因素，使得神经网络可以更好地解决较为复杂的问题。激活函数的缺点是如果模型比较复杂，面对样本数不大的情况时容易出现<a href="http://blog.csdn.net/artprog/article/details/51278643" target="_blank" rel="external"><strong>过拟合</strong></a>。常用的激活函数还有<strong>tanh函数</strong>，<strong>RelU函数</strong>等等。</p><p><strong>sigmoid</strong>函数的数学形式：</p><script type="math/tex; mode=display">\sigma(x) = \dfrac{1}{1+e^{-x}}</script><p><strong>sigmoid</strong>函数求导：</p><script type="math/tex; mode=display">\sigma '(x)= \dfrac{e^{-x}}{(1+e^{-x})^2}=(1-\sigma)\sigma</script><p><strong>sigmoid</strong>函数和导数python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(x)</span>:</span></div><div class="line">  x = <span class="number">1.</span>/(<span class="number">1</span>+np.exp(-x))</div><div class="line">  <span class="keyword">return</span> x</div><div class="line"><span class="comment"># grad</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_grad</span><span class="params">(f)</span>:</span></div><div class="line">  f = f*(<span class="number">1</span>-f)</div><div class="line">  <span class="keyword">return</span> f</div></pre></td></tr></table></figure><p><strong>softmax</strong>函数的数学形式：</p><script type="math/tex; mode=display">\text{softmax}(z_i) = \dfrac{e^{z_i}}{\sum_{j=1}^{c} e^{z_j}}      \quad 假设a_i=\text{softmax}(z_i)</script><p><strong>softmax</strong>函数求导：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial a_i}{\partial z_i}&=-\dfrac{e^{z_i}(\sum_{j} e^{z_j})-e^{z_i}e^{z_i}}{(\sum_{j} e^{z_j})^2}\\&=-\dfrac{e^{z_i}}{\sum_{j} e^{z_j}}+(\dfrac{e^{z_i}}{\sum_{j} e^{z_j}})^2\\&= a_i(1-a_i)\end{align*}</script><p><strong>softmax函数</strong>的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy</div><div class="line"><span class="comment"># 输出softmax函数值，输入向量或矩阵x</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(x.shape)&gt;<span class="number">1</span>:</div><div class="line">        max = np.max(x,axis=<span class="number">1</span>)[:,np.newaxis]</div><div class="line">        x -= max</div><div class="line">        x = np.exp(x)</div><div class="line">        softmax_deno = np.sum(x, axis=<span class="number">1</span>)[:,np.newaxis]</div><div class="line">        x = x/softmax_deno</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        max = np.max(x)</div><div class="line">        x -= max</div><div class="line">        x = np.exp(x)</div><div class="line">        softmax_deno = np.sum(x)</div><div class="line">        x = x/softmax_deno</div><div class="line">    <span class="keyword">return</span> x</div></pre></td></tr></table></figure><h3 id="目标函数-Objective-fuction"><a href="#目标函数-Objective-fuction" class="headerlink" title="　目标函数(Objective fuction)"></a>　目标函数(Objective fuction)</h3><p>目标函数，有时候又称<strong>损失函数（loss function），代价函数（cost function ）</strong>，是网络中的性能参数，也是编译一个模型必须的两个参数之一。在训练模型时，我们的最终目标就是最大化或者最小化目标函数，用$J$表示目标函数。</p><script type="math/tex; mode=display">\arg\min_{\theta}\ J</script><h4 id="交叉熵-Cross-entropy"><a href="#交叉熵-Cross-entropy" class="headerlink" title="交叉熵(Cross entropy)"></a>交叉熵(Cross entropy)</h4><p>一种常见的目标函数形式：</p><script type="math/tex; mode=display">J = -\sum_{i}y_i\log{\hat{y}_i}</script><p>其中$i$代表响应的类别，$y_i$是训练样本中的标签，而$\hat{y}_i$模型预测结果。</p><p>一般情况下，我们对$y_i$使用<strong>one-hot</strong>编码，而$\hat{y}$代表了对应类别的概率$p(y_i|w,x)$，因此，$\sum_i\hat{y_i}=1$,在这里我们称$y_i$为预测函数。</p><p>*对$\hat{y}$求导：    </p><script type="math/tex; mode=display">\dfrac{\partial{J}}{\partial{\hat{y}_i}}=-\dfrac{y_i}{\hat{y}_i}</script><p>对向量$\hat{\boldsymbol{y}}=(\hat{y}_1,\ \dots\ ,\hat{y}_c)$求导：</p><script type="math/tex; mode=display">\dfrac{\partial{J}}{\partial\hat{\boldsymbol{y}}}=(-\dfrac{y_1}{\hat{y}_1},\ \dots\ ,-\dfrac{y_c}{\hat{y}_c})</script><h3 id="预测函数-Predict-function"><a href="#预测函数-Predict-function" class="headerlink" title="　预测函数(Predict function)"></a>　预测函数(Predict function)</h3><p>对于预测函数$\hat{y}_i$,我们取$\hat{y}_i$最大的$i$作为模型最终预测的类别。使用softmax函数对输出层的输入进行归一化操作，数学表示为：</p><script type="math/tex; mode=display">\hat{y_i}=p(y_i|w,x)=\dfrac{e^{z_i}}{\sum_{j=1}^{c} e^{z_j}}</script><p>其中$c$表示类别个数，在这里即是输出层的神经元个数。$z_i$为输出层的输入。</p><p>根据softmax函数的求导可知，预测函数$\hat{y}_i$对$z_i$求导：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial \hat{y_i}}{\partial z_i} &= -\hat{y_i}(1-\hat{y_i})\\\dfrac{\partial \hat{y_k}}{\partial z_i} &= -\hat{y_k}\hat{y_i}\end{align*}</script><p>根据链式法则，目标函数$J$对$z_i$求导：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial J}{\partial z_i} &=\dfrac{\partial J}{\partial \hat{y_1}} \dfrac{\partial \hat{y_1}}{\partial z_i}+\dots+ \dfrac{\partial J}{\partial \hat{y_c}} \dfrac{\partial \hat{y_c}}{\partial z_i}\\&= y_1\hat{y_i}+\dots+y_i(\hat{y_i}-1)+\dots+y_c\hat{y_i}\\&=\hat{y}_i\sum_{j=1}^cy_c-y_i\\&=\hat{y}_i-y_i\end{align*}</script><p>目标函数$J$对向量$z$求导：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial J}{\partial \boldsymbol{z}} = {\boldsymbol{y}}-{\hat{\boldsymbol{y}}}\end{align*}</script><h3 id="前向传播-Forward-propagation"><a href="#前向传播-Forward-propagation" class="headerlink" title="前向传播(Forward propagation)"></a>前向传播(Forward propagation)</h3><p><strong>前向传播是求目标函数值的过程</strong>，从输入层开始，样本的特征向量$x$遍历模型，到达输出层$\hat{y}$，再将$\hat{y}$和  $y$进行比较，得到目标函数值$J$： </p><script type="math/tex; mode=display">\begin{align*}\boldsymbol{h} &= sigmoid(\boldsymbol{xW}_1+\boldsymbol{b}_1)\\\boldsymbol{\hat{y}} &= sigmoid(\boldsymbol{hW}_2+\boldsymbol{b}_2)\\J &= -\sum_{i}y_i\log{\hat{y}_i}\end{align*}</script><p>训练模型的过程就是优化目标函数的过程，我们需要最小化$J=J(\boldsymbol{W}_1,\boldsymbol{b}_1,\boldsymbol{W}_2,\boldsymbol{b_2})$,这歌优化过程我们可以使用<a href="http://www.cnblogs.com/pinard/p/5970503.html" target="_blank" rel="external">梯度下降法</a>,但是由于$J$是一个非凸函数，因此不能使用梯度下降法求得全局最优，也就是不能获得的$J$最小值。</p><h3 id="随机梯度下降-Stochastic-gradient-descent"><a href="#随机梯度下降-Stochastic-gradient-descent" class="headerlink" title="随机梯度下降(Stochastic gradient descent)"></a>随机梯度下降(Stochastic gradient descent)</h3><p>我们可以求目标函数的梯度，它代表目标函数变化增加最快的地方。相反，沿着梯度相反的方向，梯度减少最快，所以我们可以使用迭代的方法更新参数，使得目标函数往着最优的方向进行优化，找到目标函数的最小值：</p><script type="math/tex; mode=display">\boldsymbol{g}^{(t)} = \dfrac{\partial{J}}{\partial{\boldsymbol{W}^{(t)}}}\\\boldsymbol{W}^{(t+1)} =\boldsymbol{W}^{(t)}+ \alpha\boldsymbol{g}^{(t)}</script><p>$t$表示第$t$次进行迭代更新，$\alpha$表示学习率，代表着每一次迭代要走的步长，$Ｗ$表示我们需要更新的参数，在本例子中，我们需要对$W_1$,$b_2$,$W_2$,$b_2$进行参数更新，每次迭代都需要进行梯度的计算，每次迭代都要计算目标函数的值。</p><p>假设训练样本数量为$N$，如果每次迭代都使用所有的训练样本。这时的目标函数是：</p><script type="math/tex; mode=display">\mathbb{J}=\mathbb{E}(J)=\dfrac{1}{N}\sum_nJ_n</script><p>当$N$很大的时候，每次迭代都十分耗时，因此收敛的速度会较慢。我们可以使用一种逼近方法，称为<strong>mini-batch</strong>。</p><ul><li><strong>mini-batch</strong>很简单，就是每次迭代更新只使用$k$个训练样本，$k$可以是100这种相对较小的数。</li><li>而<strong>随机梯度下降(SGD)</strong>是每次更新迭代只使用$1$个训练样本，即$k=1$。<strong>SGD</strong>是<strong>mini-batch</strong>的特殊情况，但是我们一般说<strong>SGD</strong>就是指<strong>mini-batch</strong>。</li></ul><h3 id="后向传播-Backward-propagation"><a href="#后向传播-Backward-propagation" class="headerlink" title="后向传播(Backward propagation)"></a>后向传播(Backward propagation)</h3><p><strong>后向传播就是一个求梯度的过程</strong>从输出层开始往输入层传入误差。</p><p>我们将三层全连接神经网络模型的前向传播表示为：</p><script type="math/tex; mode=display">\begin{align*}&\boldsymbol{z}_1 = \boldsymbol{xW_1}+\boldsymbol{b}_1\\&\boldsymbol{h} = {\text sigmoid}(\boldsymbol{z}_1)\\&\boldsymbol{z}_2 = \boldsymbol{xW_2}+\boldsymbol{b}_2\\&\hat{\boldsymbol{y}} = softmax(\boldsymbol{z}_2)\\&J = -\sum_{i}y_i\log{\hat{y}_i}\end{align*}</script><p>计算后向传播：</p><script type="math/tex; mode=display">\begin{align*}&\boldsymbol{\delta}_1 = \dfrac{\partial J}{\partial \boldsymbol{z}_2} = \hat{\boldsymbol{y}}-\boldsymbol{y}\\&\boldsymbol{\delta}_2 = \dfrac{\partial J}{\partial \boldsymbol{h}} = \boldsymbol{\delta}_1\dfrac{\partial \boldsymbol{z}_2}{\partial \boldsymbol{h}} =\boldsymbol{\delta}_1\boldsymbol{W}^T_2 \\&\boldsymbol{\delta}_3 = \dfrac{\partial J}{\partial \boldsymbol{z}_1} = \boldsymbol{\delta}_2\dfrac{\partial \boldsymbol{h}}{\partial \boldsymbol{z}_1} =\boldsymbol{\delta}_2*\sigma'(\boldsymbol{z}_1) \\&\boldsymbol{\delta}_4 = \dfrac{\partial J}{\partial \boldsymbol{x}} = \boldsymbol{\delta}_3\dfrac{\partial \boldsymbol{z}_1}{\partial \boldsymbol{x}} =\boldsymbol{\delta}_3\boldsymbol{W}^T_1 \\\end{align*}</script><p>$\boldsymbol{\delta}_1$就是预测误差，得到上面传播的误差，我们对每一层的参数求梯度：</p><script type="math/tex; mode=display">\begin{align*}\dfrac{\partial J}{\partial \boldsymbol{W}_2}&= \boldsymbol{\delta}_1 \dfrac{\partial\boldsymbol{z}_2 }{\partial \boldsymbol{W}_2} = \boldsymbol{h}^T\boldsymbol{\delta}_1\\\dfrac{\partial J}{\partial \boldsymbol{b}_2} &= \boldsymbol{\delta}_1 \dfrac{\partial\boldsymbol{z}_2 }{\partial \boldsymbol{b}_2} = \boldsymbol{\delta}_1\\\dfrac{\partial J}{\partial \boldsymbol{W}_1} &= \boldsymbol{\delta}_3 \dfrac{\partial\boldsymbol{z}_1 }{\partial \boldsymbol{W}_1} = \boldsymbol{x}^T\boldsymbol{\delta}_3\\\dfrac{\partial J}{\partial \boldsymbol{b}_1} &= \boldsymbol{\delta}_3 \dfrac{\partial\boldsymbol{z}_1 }{\partial \boldsymbol{b}_1} = \boldsymbol{\delta}_3\\\end{align*}</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;深度学习应用于自然语言处理-前向神经网络&quot;&gt;&lt;a href=&quot;#深度学习应用于自然语言处理-前向神经网络&quot; class=&quot;headerlink&quot; title=&quot;深度学习应用于自然语言处理-前向神经网络&quot;&gt;&lt;/a&gt;深度学习应用于自然语言处理-前向神经网络&lt;/h2&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;深度学习的浪潮袭来，现已在各个领域中应用。深度学习的表现令人叹为观止，不得不说我们迎来了依靠深度学习的人工智能学习时代。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;　人工智能，让世界更美好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一章主要是通过学习 &lt;a href=&quot;http://cs224d.stanford.edu/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Stanford cs224d&lt;/a&gt; 课程已经阅读一些有些的博客所作出的总结。&lt;/p&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="工具资源" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>词向量</title>
    <link href="http://yoursite.com/2017/12/17/word-embedding/"/>
    <id>http://yoursite.com/2017/12/17/word-embedding/</id>
    <published>2017-12-17T12:04:30.000Z</published>
    <updated>2017-12-17T12:58:15.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自然语言处理－词向量"><a href="#自然语言处理－词向量" class="headerlink" title="自然语言处理－词向量"></a>自然语言处理－词向量</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在计算机视觉中，作为输入的图片可以直接数值化。在语言识别中，作为输入的语音也可以直接数值化。而在自然语言处理中，我们无法将文字直接数值化，为了能够让计算机处理文字，我们需要将文字映射到一个数值空间。由于词是组成语义的基本单位，所以对词的表述就显得尤为重要，我们把词的数值（表征）表示为<strong>Word Representation</strong>，一般来说，词向量经常指<strong>Word Embedding</strong>，也称<strong>Distributed Word Representation</strong>。</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>从<strong>Word Representation</strong>的发展过程引入<strong>Word Embedding</strong>，先从简单的SVD介绍开始，再到NNLM,word2vec等词向量模型。</p><h3 id="one-hot编码"><a href="#one-hot编码" class="headerlink" title="one-hot编码"></a>one-hot编码</h3><p>one-hot编码也称独热编码，这是一种简单的词表征方式，每个词使用一个$R^{|V|}$的向量表示，$|V|$表示词表的大小。</p><script type="math/tex; mode=display">w^{address}=\begin{bmatrix}1\\0\\0\\\vdots\\0\end{bmatrix},w^{home}=\begin{bmatrix}0\\1\\0\\\vdots\\0\end{bmatrix},w^{at}=\begin{bmatrix}0\\0\\1\\\vdots\\0\end{bmatrix}</script><p>使用one-hot编码的词向量之间是相互独立的，因为对于每个词$(w^{i})^{T}w^j = 0$，这种编码方式并没有编码不同词之间的语义相似性。</p><a id="more"></a><h3 id="基于矩阵分解的词表征"><a href="#基于矩阵分解的词表征" class="headerlink" title="基于矩阵分解的词表征"></a>基于矩阵分解的词表征</h3><h4 id="词–文档矩阵-Word-Document-Matrix"><a href="#词–文档矩阵-Word-Document-Matrix" class="headerlink" title="词–文档矩阵(Word-Document Matrix)"></a>词–文档矩阵(Word-Document Matrix)</h4><p>如果我们有大量的文档，我们用一个矩阵来存储所有文档的词频信息。矩阵的行向量代表词，列向量代表文档，每个元素代表词在文档中出现的频数，比如我们现在有两篇文档：</p><p>$I \quad love \quad NLP \ I \quad love \quad deep \quad learningI$</p><p>经过统计次数，我们可以得到以下矩阵：</p><script type="math/tex; mode=display">\boldsymbol{X} = \begin{array}{c}&\tiny{d_1}&\tiny{d_2}\\\begin{array}{c}\tiny{I} \\\tiny{love} \\\tiny{NLP} \\\tiny{deep} \\\tiny{learning} \\\end{array}\left.\right[&\begin{array}{c}1 \\ 1 \\ 1 \\ 0 \\ 0\end{array}&\begin{array}{c}1 \\ 1 \\ 0 \\ 1 \\ 1\end{array}&\left.\right]\end{array}</script><p>如果两个文档有相似的主题，那么两个文档的列向量会趋于有相似类型的词数量。该模型主要用于衡量文档主题的相似性。</p><h4 id="基于窗口的词共现矩阵-Window-based-Co-occurrence-Matrix"><a href="#基于窗口的词共现矩阵-Window-based-Co-occurrence-Matrix" class="headerlink" title="基于窗口的词共现矩阵(Window based Co-occurrence Matrix)"></a>基于窗口的词共现矩阵(Window based Co-occurrence Matrix)</h4><p>给定一个词，计算在一个限定大小的窗口中出现的其他词的次数。我们将这些计数放在一个矩阵中，矩阵的行表示词，列也是词。假如窗口大小为1，我们需要计算当前词左右两边的两个词。比如,我们两个句子：</p><p>$I \quad love \quad NLP \ I \quad love \quad deep \quad learningI$</p><p>窗口长度为１，我们得到的矩阵为：</p><script type="math/tex; mode=display">\boldsymbol{X} = \begin{array}{c}&\tiny{I}&\tiny{love}&\tiny{NLP}&\tiny{deep}&\tiny{learning}\\\begin{array}{c}\tiny{I} \\\tiny{love} \\\tiny{NLP} \\\tiny{deep} \\\tiny{learning} \\\end{array}\left.\right[&\begin{array}{c}0 \\ 2 \\ 0 \\ 0 \\ 0\end{array}&\begin{array}{c}2 \\ 0 \\ 1 \\ 1 \\ 0\end{array}&\begin{array}{c}0 \\ 1 \\ 0 \\ 0 \\ 0\end{array}&\begin{array}{c}0 \\ 1 \\ 0 \\ 0 \\ 1\end{array}&\begin{array}{c}0 \\ 0 \\ 0 \\ 1 \\ 0\end{array}&\left.\right]\end{array}</script><p>以看到矩阵是对称矩阵，可以行或者列作为词表征。这个矩阵的意义在于假如两个词有相似的context则偏向于有相似的意思，也就是说相似的词有相似的词表征。</p><h4 id="SVD-Singular-Value-Decomposition"><a href="#SVD-Singular-Value-Decomposition" class="headerlink" title="SVD(Singular Value Decomposition)"></a>SVD(Singular Value Decomposition)</h4><p><strong>SVD，奇异值矩阵分解</strong>。对于任意一个矩阵$X$都可以做奇异值分解：</p><script type="math/tex; mode=display">\boldsymbol{X}_{m\times n}=\boldsymbol{U}_{m\times m}\boldsymbol{S}_{m\times n}\boldsymbol{V}^T_{n\times n}</script><p>其中$U$和$V$都是正交矩阵，$S$只有对角元素：</p><script type="math/tex; mode=display">\boldsymbol{S} = \begin{bmatrix}\boldsymbol{S}_1 & \boldsymbol{O}\\\boldsymbol{O} & \boldsymbol{O}\\\end{bmatrix}，\boldsymbol{S}_1=\begin{bmatrix}\sigma_1 &0&\dots&0\\0&\sigma_2 &&\vdots\\\vdots&&\ddots&0\\0&\dots&0&\sigma_r\end{bmatrix}</script><p>其中$\sigma_1…\sigma_r$是矩阵$X$的奇异值。</p><h4 id="LSA-Latent-Semantic-Analysis"><a href="#LSA-Latent-Semantic-Analysis" class="headerlink" title="LSA(Latent Semantic Analysis)"></a>LSA(Latent Semantic Analysis)</h4><p>上述描述的两种矩阵中，都存在一个明显的问题－当出现大量的文档和词的时候，我们得到的矩阵会十分庞大，而且会出现矩阵稀疏问题。后来，有人为了提高相似度的计算准确度，提出了对矩阵进行SVD分解，可以得到更好的词表征。这种方法称为<strong>LSA，潜在语义分析</strong>。LSA是为了研究词表征，另外还有类似的研究文档表征的方法叫<strong>LSI(Latent Semantic Index)</strong>。 我们通过计数统计得到了词-文档矩阵或者词共现矩阵$X$，然后对矩阵$X$使用SVD，取最大的$k$个奇异值，由于每个奇异值对应于$U$的列，因此得到$\hat{\boldsymbol{U}}_{n\times k}$，每一行代表一个词表征，因此可以得到$k$维的词表征。</p><p>优点：降低矩阵稀疏度　减少噪声</p><p>缺点：有新词或新的语料出现，矩阵需要重新计算　矩阵维度高　</p><p>　　　矩阵过于稀疏，很多词无法共现　会出现过高或过低的词频</p><p><strong>Word Embedding</strong> 出现解决了上述问题。</p><h3 id="基于迭代的词表征-词向量"><a href="#基于迭代的词表征-词向量" class="headerlink" title="基于迭代的词表征(词向量)"></a>基于迭代的词表征(词向量)</h3><p>迭代的词表征得到的是一个稠密的向量，与矩阵分解不同的是，词向量是通过迭代训练模型得到。</p><h4 id="NNLM"><a href="#NNLM" class="headerlink" title="NNLM"></a>NNLM</h4><p>这个<a href="http://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf" target="_blank" rel="external">模型</a>是由Bengio大神于2003年发表，可以说是Neural Language Model的开山之作。本来作者的主要目的是建立语言模型，结果发现了词向量这种副产品，由此引发了后人对词向量的火热研究。</p><p>模型使用了一个简单的前向神经网络，如下图所示： <img src="../../Pictures/datastructure/language_model_bengio.jpg" alt="language_model_bengio"></p><p>该模型通过上下文来预测下一个单词，图中所示的输入为上文的各个词$w_i$，然后将他们的词向量$C(w_i)$连接起来，输出是每个词的概率$P(w_t|content)$，虚线表示的是词向量层和输出层的直接连接。</p><h4 id="Word2vec"><a href="#Word2vec" class="headerlink" title="Ｗord2vec"></a>Ｗord2vec</h4><p>Ｗord2vec这个工具，是Tomas Mikolov在Google的时候开发的用来训练词向量的工具。Ｗord2vec这个工具中有两个模型（CBOW、Skip-Gram），还有两种加速训练的trick（层次Softmax、负采样），下面分别一一讲述。</p><ul><li>$w$表示词</li><li>$x$表示one-hot编码</li><li>$u$和$v$表示词向量</li><li>$x(w)$表示one-hot编码中对应词$w$位置的值，取值为0或1，只有一个位置上的值为1。</li></ul><h5 id="CBOW-Continuous-Bag-of-word-Model"><a href="#CBOW-Continuous-Bag-of-word-Model" class="headerlink" title="CBOW(Continuous Bag-of-word Model)"></a>CBOW(Continuous Bag-of-word Model)</h5><p>模型的网络结构如下：</p><p><img src="../../Pictures/datastructure/cbow.jpg" alt="cbow"></p><p><strong>说明</strong>: </p><p>模型中存在两套词向量。</p><p>一套称为Input词向量，用矩阵$V<em>{|V|\times d}=(v_1,\dots,v</em>{|V|})$表示，|V|指的是词表大小，ｄ指词向量维度</p><p>一套称为Output词向量，用矩阵$U<em>{|V|\times d}=(v_1,\dots,v</em>{|V|})$表示</p><p><strong>建模过程</strong></p><ul><li><p>确定一个窗口大小m</p></li><li><p>选定目标词位置t。得到该位置的上下文：</p><script type="math/tex; mode=display">(w^{(t−m)},...,w^{(t−1)},w^{(t+1)},...,w^{(t+m)})</script></li><li><p>得到上下文各个词的one-hot表示：</p><script type="math/tex; mode=display">(x^{(t−m)},...,x^{(t−1)},x^{(t+1)},...,x^{(t+m)})</script></li><li><p>使用矩阵$V$，计算$v = Vx$得到上下文的词向量（对于图中的<strong>INPUT层</strong>）</p><script type="math/tex; mode=display">(v^{(t−m)},...,v^{(t−1)},v^{(t+1)},...,v^{(t+m)})</script></li><li><p>将上下文的词向量相加或者平均，得到。<strong>（对应图中的PROJECTION层）</strong>： </p><script type="math/tex; mode=display">\hat{v} = \dfrac{v^{(t−m)}+\dots+v^{(t−1)}+v^{(t+1)}+\dots+v^{(t+m)}}{2m}</script></li><li><p>使用矩阵$U$，计算目的词的概率分布<strong>（对应图中的OUTPUT层）</strong>:</p><script type="math/tex; mode=display">P(w \mid w^{(t−m)},...,w^{(t−1)},w^{(t+1)},...,w^{(t+m)})=\text{softmax}(U\hat{v})=\dfrac{e^{u\hat{v}}}{\sum\limits_{u_i\in U}{e^{u_i\hat{v}}}}</script></li><li><p>使用负对数似然（又称交叉熵）损失函数$J$：</p><script type="math/tex; mode=display"><Empty \space Math \space Block></script><script type="math/tex; mode=display">\begin{align*}    J &= -\sum_{w} x^t(w)\log P(w \mid w^{(t−m)},...,w^{(t−1)},w^{(t+1)},...,w^{(t+m)})\\    &= -\log P(w^t \mid w^{(t−m)},...,w^{(t−1)},w^{(t+1)},...,w^{(t+m)})    \end{align*}</script></li></ul><p><strong>训练过程</strong></p><ul><li><p>选取batch的大小n</p></li><li><p>使用SGD训练，对于每个训练样本的损失函数$J_i$，构造batch的损失函数：</p><script type="math/tex; mode=display">J_{batch} = \sum_i^n J_i</script></li><li><p>每一轮迭代更新$U$和$V$</p></li></ul><h5 id="Skip-Gram-Continuous-Skip-gram-Model"><a href="#Skip-Gram-Continuous-Skip-gram-Model" class="headerlink" title="Skip-Gram(Continuous Skip-gram Model)"></a>Skip-Gram(Continuous Skip-gram Model)</h5><p>既然可以用上下文来预测目标词，反过来也能用目标词来预测上下文，Skip-Gram因此应运而生。</p><p><img src="../../Pictures/datastructure/Skip-Gram.jpg" alt="Skip-Gram"></p><p>与CBOW一样，模型中存在两套词向量$U$和$V$。</p><p><strong>建模过程</strong></p><ul><li><p>确定Context的窗口大小$m$。</p></li><li><p>选取一个目标词$w^t$，然后在目标词的Context中的选择一个词$w^c$，组成训练样本： </p><script type="math/tex; mode=display">(w^t, w^c)</script></li><li><p>得到训练样本one-hot表示为：$(x^t,x^c)$</p></li><li><p>使用矩阵$V$，得到目标词的词向量<strong>（对应图中INPUT层）</strong>：$v^t = c^tV$</p></li><li><p>由于只有一个词，所以不需要相加或者平均，直接复制到下一层<strong>（对应PROJECTION层）</strong>： $\hat{v} = v^t$</p></li><li><p>使用矩阵$U$，计算上下文中的词的概率分布<strong>（对应图中的OUTPUT层）</strong>： </p><script type="math/tex; mode=display">P(w \mid w^t) = \text{softmax}(U\hat{v}) = \dfrac{e^{u\hat{v}}}{\sum\limits_{u_i\in U}{e^{u_i\hat{v}}}}</script></li><li><p>使用负对数似然（又称交叉熵）损失函数$J$：</p><script type="math/tex; mode=display">J = -\sum_{w} x^c(w)\log P(w \mid w^t) = -\log P(w^c \mid w^t)</script></li></ul><p><strong>训练过程</strong></p><ul><li><p>选取batch的大小n</p></li><li><p>使用SGD训练，对于每个训练样本的损失函数$J_i$，构造batch的损失函数：</p><script type="math/tex; mode=display">J_{batch} = \sum_i^n J_i</script></li><li><p>每一轮迭代更新$U$和$V$</p></li></ul><h5 id="加速技巧"><a href="#加速技巧" class="headerlink" title="加速技巧"></a>加速技巧</h5><p>Word2vec的训练是无监督的，我们只需要分好词，在训练的时候像有监督一样进行梯度下降。因此，在训练模型的时候，我们需要同时更新$U$和$V$。</p><p>从公式可以看出，每次迭代只需要更新矩阵中的少量向量（Skip-Gram中是一个）。然而如果我们使用简单的Softmax，我们就要每次都更新整个$U$，假如词表大小到达千万级以上，可想而知这是多么耗时。因此，我们需要一些Trick来加速训练。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自然语言处理－词向量&quot;&gt;&lt;a href=&quot;#自然语言处理－词向量&quot; class=&quot;headerlink&quot; title=&quot;自然语言处理－词向量&quot;&gt;&lt;/a&gt;自然语言处理－词向量&lt;/h2&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在计算机视觉中，作为输入的图片可以直接数值化。在语言识别中，作为输入的语音也可以直接数值化。而在自然语言处理中，我们无法将文字直接数值化，为了能够让计算机处理文字，我们需要将文字映射到一个数值空间。由于词是组成语义的基本单位，所以对词的表述就显得尤为重要，我们把词的数值（表征）表示为&lt;strong&gt;Word Representation&lt;/strong&gt;，一般来说，词向量经常指&lt;strong&gt;Word Embedding&lt;/strong&gt;，也称&lt;strong&gt;Distributed Word Representation&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;从&lt;strong&gt;Word Representation&lt;/strong&gt;的发展过程引入&lt;strong&gt;Word Embedding&lt;/strong&gt;，先从简单的SVD介绍开始，再到NNLM,word2vec等词向量模型。&lt;/p&gt;
&lt;h3 id=&quot;one-hot编码&quot;&gt;&lt;a href=&quot;#one-hot编码&quot; class=&quot;headerlink&quot; title=&quot;one-hot编码&quot;&gt;&lt;/a&gt;one-hot编码&lt;/h3&gt;&lt;p&gt;one-hot编码也称独热编码，这是一种简单的词表征方式，每个词使用一个$R^{|V|}$的向量表示，$|V|$表示词表的大小。&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
w^{address}=\begin{bmatrix}
1\\0\\0\\\vdots\\0
\end{bmatrix},w^{home}=\begin{bmatrix}
0\\1\\0\\\vdots\\0
\end{bmatrix},w^{at}=\begin{bmatrix}
0\\0\\1\\\vdots\\0
\end{bmatrix}&lt;/script&gt;&lt;p&gt;使用one-hot编码的词向量之间是相互独立的，因为对于每个词$(w^{i})^{T}w^j = 0$，这种编码方式并没有编码不同词之间的语义相似性。&lt;/p&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="word_embedding" scheme="http://yoursite.com/tags/word-embedding/"/>
    
  </entry>
  
  <entry>
    <title>王家卫电影台词</title>
    <link href="http://yoursite.com/2017/12/17/Wong/"/>
    <id>http://yoursite.com/2017/12/17/Wong/</id>
    <published>2017-12-17T09:05:26.000Z</published>
    <updated>2017-12-21T12:35:01.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="东邪西毒"><a href="#东邪西毒" class="headerlink" title="东邪西毒"></a>东邪西毒</h2><p>从小我就懂得保护自己，我知道要想不被人拒绝，最好的办法就是先拒绝别人。<br>我曾经听人说过，当你不可以再拥有的时候。你唯一可以做的，就是让自己不要忘记。<br>你越想忘记一个人时，其实你越会记得他。人的烦恼就是记性太好，如果可以把所有事都忘掉，以后每一日都是个新开始，你说多好。<br>每个人都会经过这个阶段，见到一座山，就想知道山后面是什么。我很想告诉他，可能翻过山后面，你会发现没什么特别。回望之下，可能会觉得这一边更好。<br>多年之后，我有个绰号叫西毒，任何人都可以变得狠毒，只要你尝试过什么叫做嫉妒。<br>其实“醉生梦死”只不过是她跟我开的一个玩笑，你越想知道自己是不是忘记的时候，你反而记得更清楚。我曾经听人说过，当你不能够再拥有，你唯一可以做的，就是令自己不要忘记。<br>知不知道饮酒和饮水有什么区别？酒越饮越暖，水越喝越寒。</p><a id="more"></a><p>有些人是离开之后，才会发现离开了的人才是自己的最爱。<br>每个人都会坚持自己的信念，在别人来看是浪费时间，她却觉得很重要。<br>不久前，我遇上一个人，送给我一坛酒，她说那叫“醉生梦死”，喝了之后，可以叫你忘掉以前做过的任何事。我很奇怪，为什么会有这样的酒。她说人最大的烦恼，就是记性太好，如果什么都可以忘掉，以后的每一天将会是一个新的开始，那你说这有多开心。<br>虽然我很喜欢她，但是我不想让她知道，因为我明白得不到的东西永远是最好的。每次她凝望着那小孩子，我知道她心里其实在想另一个人。我很妒忌欧阳峰，我很想知道被人喜欢的感觉是怎样的，结果我伤害了很多人。<br>有些事情你越想忘记，就会记得越牢。当有些事情你无法得到时，你惟一能做的，就是不要忘记。<br>以前我认为那句话很重要 因为我觉得有些话说出来就是一生一世 现在想一想 说不说也没有什么分别 有些事会变的。<br>以前也这么想，但是看着他一天天长大，我知道他早晚会离开我。现在我觉得什么都无所谓啦。以前我认为那句话很重要，因为我觉得有些话说出来就是一生一世，现在想一想，说不说也没有什么分别，有些事会变的。我一直以为是我自己赢了，直到有一天看着镜子，才知道自己输了，在我最美好的时候，我最喜欢的人都不在我身边。如果能重新开始那该多好啊！<br>我曾经问过自己，你最喜欢的女人是不是我，现在我已经不想再知道啦。如果有一天我忍不住问起，你一定要骗我，就算你心里有多么不愿意，也不要告诉我你最喜欢的人不是我。<br>我知道那个人不会再来，可是我还是再等。我在门口坐了两天两夜，看着天空在不断的变化，我才发现原来我到这里这么久，却从来没有看清楚这片天空。<br>告诉你，你这样看着我，可是非常有危险的。因为你随时可能爱上我。<br>每个人都会坚持自己的信念，在别人来看是浪费时间，她却觉得很重要。</p><h2 id="春光乍泄"><a href="#春光乍泄" class="headerlink" title="春光乍泄"></a>春光乍泄</h2><p>一直以为我跟何宝荣不一样，原来寂寞的时候，所有的人都一样。<br>我终于来到瀑布，我突然想起何宝荣，我觉得好难过，我始终认为站在这儿的应该是两个人。<br>一个人可以假装开心，但声音就装不了，仔细一听就知道了。<br>跟他接近得多了，我什么也听不到，只听见自己的心在跳，不知他可有听到？<br>我终于明白，他为什么那么开心在外面走来走去，是因为他知道自己有个地方让他回去。<br>很多事情我都没有告诉何宝荣，我并不希望他赶快好起来，他受伤的那段日子，是我们最快乐的时光。<br>愈是期待愈是美丽来让这夜春光代替难道要等青春全枯萎 至得到一切<br>黎耀辉，不如我们由头来过吧。</p><h2 id="重庆森林"><a href="#重庆森林" class="headerlink" title="重庆森林"></a>重庆森林</h2><p>我和她接近的时候，我们之间的距离只有0.01公分，我对她一无所知，57个小时之后，我爱上了她。<br>每天你都有机会和很多人擦身而过，而你或者对他们一无所知，不过也许有一天他会变成你的朋友或是知己， 我是一个警察，我的名字叫何志武，编号223。<br>每个人都有失恋的时候，而每一次我失恋呢，我就会去跑步，因为跑步可以将你身体里面的水分蒸发掉，而让我不那么容易流泪，我怎么可以流泪呢？在阿美的心中里面，我可是一个很酷的男人。<br> 从分手的那一天开始，我每天买一罐5月1号到期的凤梨罐头，因为凤梨是阿美最爱吃的东西，而5月1号是我的生日。 我告诉我自己，当我买满30罐的时候， 她如果还不回来，这段感情就会过期。<br>不知道从什么时候开始，在什么东西上面都有个日期，秋刀鱼会过期，肉罐头会过期，连保鲜纸都会过期，我开始怀疑，在这个世界上，还有什么东西是不会过期的？<br>在1994年的5月1号，有一个女人跟我讲了一声“生日快乐”，因为这一句话，我会一直记住这个女人。如果记忆也是一个罐头的话，我希望这罐罐头不会过期；如果一定要加一个日子的话，我希望她是一万年。<br>其实了解一个人并不代表什么，人是会变的，今天他喜欢凤梨，明天他可以喜欢别的。<br>不知道什么时候开始，我变成一个很小心的人，每次我穿雨衣的时候，我都会戴太阳眼镜，你永远都不会知道什么时候会下雨，什么时候出太阳。<br>我没有想到她说的休息就是真正的休息，整个晚上我看了两套粤语长片，吃了四次厨师沙拉。当天差不多快亮的时候，我知道我该走了。在我要走的时候，我帮她脱了鞋子。我记得我妈说过，如果女人穿着高跟鞋睡觉，第二天会脚肿。她昨天晚上一定是走了很长的路，象她这样漂亮的女人，高跟鞋应该是要很干净的才对。<br>有时候，耳朵比眼睛还重要，很多东西用耳朵听比用眼睛看好，一个人可以假装开心，但声音就装不了，仔细一听就知道了。<br>不知道是我忘了关水龙头，还是房子越来越有感情。我一直以为它是最坚强的，没想到它哭得最厉害。一个人哭，你只需要给他一包纸巾，可是一个房子哭，你可要做多很多功夫。<br>那天下午我做了个梦，我到了他的家，走出那房子的时候，我以为我会醒来，谁知道，原来有些梦是永远不会醒的。<br>看着它哭的时候，我很开心，因为它外表好像改变了，可是它的本质没有变，它依然是一条感情丰富的毛巾。<br>也对，宵夜都有那么多选择，何况男朋友。</p><h2 id="花样年华"><a href="#花样年华" class="headerlink" title="花样年华"></a>花样年华</h2><p>那是一种难堪的相对。她一直低着头，给他一个接近的机会。他没有勇气接近，她掉转头，走了……<br> 我从来没有想到，婚姻会这么复杂。还以为一个人，做的好就行了。可是两个人在一起，单是自己做的好是不够的。<br>其实我跟你一样。只是我不去想。又不是我的错，为什么老是问自己做错什么，何必浪费时间呢。我不想这样下去。<br>如果我有一张船票，你，会不会跟我走？<br>那些消失了的岁月，仿佛隔着一块积着灰尘的玻璃，看得到，抓不着。他一直在怀念着过去的一切。如果他能冲破那块积着灰尘的玻璃，他会走回早已消失的岁月。<br>本来我也这么想，所以不怕别人说什么，我相信自己不会跟他们一样，可是原来我会。<br>以前的人，心中如果有什么不可告人的秘密，他们会跑到山上，找一棵树，在树上挖一个洞，然后把秘密全说进去，再用泥巴把洞封上，那秘密就会永远留在那棵树里，没有人会知道。<br>如果我有一张船票，你，会不会跟我走？</p><h2 id="阿飞正传"><a href="#阿飞正传" class="headerlink" title="阿飞正传"></a>阿飞正传</h2><p>我听别人说这世界上有一种鸟是没有脚的，它只能够一直的飞呀飞呀，飞累了就在风里面睡觉，这种鸟一辈子只能下地一次，那一次就是它死亡的时候。<br>十六号，四月十六号。一九六零年四月十六号下午三点之前的一分钟你和我在一起，因为你我会记住这一分钟。从现在开始我们就是一分钟的朋友，这是事实，你改变不了，因为已经过去了。我明天会再来。<br>我以前以为一分钟很快就会过去，其实是可以很长的。有一天有个人指着手表跟我说，他说会因为那一分钟而永远记住我，那时候我觉得很动听……但现在我看着时钟，我就告诉自己，我要从这一分钟开始忘掉这个人。</p><h2 id="堕落天使"><a href="#堕落天使" class="headerlink" title="堕落天使"></a>堕落天使</h2><p>当你年轻时，以为什么都有答案，可是老了的时候，你可能又觉得其实人生并没有所谓的答案。每天你都有机会和很多人擦身而过，有些人可能会变成你的朋友或者是知己，所以我从来没有放弃任何跟人磨擦的机会。有时候搞得自己头破血流，管他呢！开心就行了。<br>跟一个人合作久了，你的习惯或多或少会受他的影响。虽然我很熟悉这种香水，可是我怎么也不习惯从别的女人身上闻到。<br>做拍档，除了要了解她外，还要给机会让她了解你。<br>有些人是不适合太接近的，知道得太多反而没有兴趣。我是一个很现实的人，我知道怎样可以让自己更加快乐。</p><h2 id="一代宗师"><a href="#一代宗师" class="headerlink" title="一代宗师"></a>一代宗师</h2><p>念念不忘，必有回响。<br>叶里藏花一度，梦里踏雪几回。<br>人生如棋，落子无悔。<br>有时候我昨天遇到一个人，感觉他非常有意思，印象深刻。但后来就再也碰不上了，人生就是这样。</p><script type="math/tex; mode=display">从此只有眼前路，没有身后身。</script><p>我在最好的时候碰到你,是我的运气。可惜我没时间了。想想,说人生无悔,都是赌气的话。人生若无悔,那该多无趣啊。我心里有过你。可我也只能到喜欢为止了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;东邪西毒&quot;&gt;&lt;a href=&quot;#东邪西毒&quot; class=&quot;headerlink&quot; title=&quot;东邪西毒&quot;&gt;&lt;/a&gt;东邪西毒&lt;/h2&gt;&lt;p&gt;从小我就懂得保护自己，我知道要想不被人拒绝，最好的办法就是先拒绝别人。&lt;br&gt;我曾经听人说过，当你不可以再拥有的时候。你唯一可以做的，就是让自己不要忘记。&lt;br&gt;你越想忘记一个人时，其实你越会记得他。人的烦恼就是记性太好，如果可以把所有事都忘掉，以后每一日都是个新开始，你说多好。&lt;br&gt;每个人都会经过这个阶段，见到一座山，就想知道山后面是什么。我很想告诉他，可能翻过山后面，你会发现没什么特别。回望之下，可能会觉得这一边更好。&lt;br&gt;多年之后，我有个绰号叫西毒，任何人都可以变得狠毒，只要你尝试过什么叫做嫉妒。&lt;br&gt;其实“醉生梦死”只不过是她跟我开的一个玩笑，你越想知道自己是不是忘记的时候，你反而记得更清楚。我曾经听人说过，当你不能够再拥有，你唯一可以做的，就是令自己不要忘记。&lt;br&gt;知不知道饮酒和饮水有什么区别？酒越饮越暖，水越喝越寒。&lt;/p&gt;
    
    </summary>
    
      <category term="影音" scheme="http://yoursite.com/categories/%E5%BD%B1%E9%9F%B3/"/>
    
    
      <category term="影音" scheme="http://yoursite.com/tags/%E5%BD%B1%E9%9F%B3/"/>
    
      <category term="书名" scheme="http://yoursite.com/tags/%E4%B9%A6%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>springMVC</title>
    <link href="http://yoursite.com/2017/11/04/springMVC/"/>
    <id>http://yoursite.com/2017/11/04/springMVC/</id>
    <published>2017-11-04T11:00:32.000Z</published>
    <updated>2017-12-17T11:53:12.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="springMVC-框架原理"><a href="#springMVC-框架原理" class="headerlink" title="springMVC 框架原理"></a>springMVC 框架原理</h2><h3 id="前端控制器-DispatcherServlet"><a href="#前端控制器-DispatcherServlet" class="headerlink" title="前端控制器(DispatcherServlet)"></a>前端控制器(DispatcherServlet)</h3><p>接受请求，响应结果，相当于转发器，中央处理器。</p><p>有了DispatcherServlet减少了其他组件之间的耦合度。</p><h3 id="处理器映射器-HandlerMapping"><a href="#处理器映射器-HandlerMapping" class="headerlink" title="处理器映射器(HandlerMapping)"></a>处理器映射器(HandlerMapping)</h3><p>根据请求的url查找Handler。</p><h3 id="处理器适配器-HandlerAdapter"><a href="#处理器适配器-HandlerAdapter" class="headerlink" title="处理器适配器(HandlerAdapter)"></a>处理器适配器(HandlerAdapter)</h3><p>按照特定的规则(HandlerAdapter要求的规则)去执行Handler。</p><p>注意：编写Handler需要按照HandlerAdapter的要求去做，这样适配器才能正确的执行Handler。</p><h3 id="视图解析器-View-resolver"><a href="#视图解析器-View-resolver" class="headerlink" title="视图解析器(View resolver)"></a>视图解析器(View resolver)</h3><p>进行视图解析，根据逻辑视图解析成真正的视图（view）</p><a id="more"></a><p>第一步：发起请求到前端控制器(DispatcherServlet)。</p><p>第二步：前端控制器请求HandlerMapping查找handler(根据xml配置或注解查找)</p><p>第三步：处理器映射器HandlerMapping向前端控制器返回Handler</p><p>第四步：向前端控制器调用处理器适配器执行Handler</p><p>第五步：处理器适配器开始执行Handler</p><p>第六步：Handler执行完给处理器适配器返回Model and View</p><p>第七步：处理器适配器向前端控制器返回Model and View(springMVC框架底层对象)</p><p>第八步：前端控制器请求视图解析器去进行视图解析(根据逻辑视图名解析成真正的视图jsp)</p><p>第九步：视图解析器向前端控制器返回View</p><p>第十步：前端控制器进行视图渲染，视图渲染将模型数据(在Model and View对象中)填充到request域</p><p>第十一步：前端控制器向用户响应结果</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;springMVC-框架原理&quot;&gt;&lt;a href=&quot;#springMVC-框架原理&quot; class=&quot;headerlink&quot; title=&quot;springMVC 框架原理&quot;&gt;&lt;/a&gt;springMVC 框架原理&lt;/h2&gt;&lt;h3 id=&quot;前端控制器-DispatcherServlet&quot;&gt;&lt;a href=&quot;#前端控制器-DispatcherServlet&quot; class=&quot;headerlink&quot; title=&quot;前端控制器(DispatcherServlet)&quot;&gt;&lt;/a&gt;前端控制器(DispatcherServlet)&lt;/h3&gt;&lt;p&gt;接受请求，响应结果，相当于转发器，中央处理器。&lt;/p&gt;
&lt;p&gt;有了DispatcherServlet减少了其他组件之间的耦合度。&lt;/p&gt;
&lt;h3 id=&quot;处理器映射器-HandlerMapping&quot;&gt;&lt;a href=&quot;#处理器映射器-HandlerMapping&quot; class=&quot;headerlink&quot; title=&quot;处理器映射器(HandlerMapping)&quot;&gt;&lt;/a&gt;处理器映射器(HandlerMapping)&lt;/h3&gt;&lt;p&gt;根据请求的url查找Handler。&lt;/p&gt;
&lt;h3 id=&quot;处理器适配器-HandlerAdapter&quot;&gt;&lt;a href=&quot;#处理器适配器-HandlerAdapter&quot; class=&quot;headerlink&quot; title=&quot;处理器适配器(HandlerAdapter)&quot;&gt;&lt;/a&gt;处理器适配器(HandlerAdapter)&lt;/h3&gt;&lt;p&gt;按照特定的规则(HandlerAdapter要求的规则)去执行Handler。&lt;/p&gt;
&lt;p&gt;注意：编写Handler需要按照HandlerAdapter的要求去做，这样适配器才能正确的执行Handler。&lt;/p&gt;
&lt;h3 id=&quot;视图解析器-View-resolver&quot;&gt;&lt;a href=&quot;#视图解析器-View-resolver&quot; class=&quot;headerlink&quot; title=&quot;视图解析器(View resolver)&quot;&gt;&lt;/a&gt;视图解析器(View resolver)&lt;/h3&gt;&lt;p&gt;进行视图解析，根据逻辑视图解析成真正的视图（view）&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>HTML知识点</title>
    <link href="http://yoursite.com/2017/10/11/html/"/>
    <id>http://yoursite.com/2017/10/11/html/</id>
    <published>2017-10-11T12:30:52.000Z</published>
    <updated>2017-12-17T11:52:57.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="HTML文档结构"><a href="#HTML文档结构" class="headerlink" title="HTML文档结构"></a>HTML文档结构</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line">－－<span class="meta">&lt;!DOCTYPE&gt;</span> 标签没有结束标签！</div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>（头部部分）</div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>显示在浏览器标题栏中的标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>（主体部分） </div><div class="line">（页面内容）</div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>bgcolor = 背景颜色　background = 背景图片路经</p><a id="more"></a><h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">H1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">H1</span>&gt;</span>     <span class="tag">&lt;<span class="name">H2</span>&gt;</span> 二级标题<span class="tag">&lt;/<span class="name">H2</span>&gt;</span>    <span class="tag">&lt;<span class="name">H3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">H3</span>&gt;</span>  <span class="tag">&lt;<span class="name">H4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">H4</span>&gt;</span>     <span class="tag">&lt;<span class="name">H5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">H5</span>&gt;</span>     <span class="tag">&lt;<span class="name">H6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">H6</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="font标签"><a href="#font标签" class="headerlink" title="font标签"></a>font标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">"字体大小"</span>  <span class="attr">color</span>=<span class="string">"字体颜色"</span> <span class="attr">face</span>=<span class="string">"字体类型"</span>&gt;</span>要设置的文字<span class="tag">&lt;/<span class="name">font</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="行控制标签"><a href="#行控制标签" class="headerlink" title="行控制标签"></a>行控制标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">"left"</span>/"<span class="attr">right</span>"/"<span class="attr">center</span>"&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>      换行<span class="tag">&lt;<span class="name">br</span> /&gt;</span></div></pre></td></tr></table></figure><h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">"图片地址"</span> <span class="attr">width</span> = <span class="string">"图片宽度"</span> <span class="attr">height</span> = <span class="string">"图片高度"</span> </span></div><div class="line"><span class="tag"><span class="attr">alt</span> = <span class="string">"图片的提示文字"</span> <span class="attr">align</span>=<span class="string">"top/bottom/middle/left/right"</span> <span class="attr">border</span>=<span class="string">"图片的边框宽度"</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="文字布局"><a href="#文字布局" class="headerlink" title="文字布局"></a>文字布局</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">１）<span class="tag">&lt;<span class="name">hr</span>  <span class="attr">size</span>=<span class="string">"厚度"</span>  <span class="attr">width</span>=<span class="string">"宽度"</span>  <span class="attr">color</span>=<span class="string">"颜色"</span>&gt;</span>　　水平线</div><div class="line"></div><div class="line">２）<span class="tag">&lt;<span class="name">ol</span>  <span class="attr">type</span>=<span class="string">序号类型</span>&gt;</span>（序号类型有：1、a、A、ⅰ、I）</div><div class="line"> 　　　　　<span class="tag">&lt;<span class="name">li</span>&gt;</span>填写信息<span class="tag">&lt;/<span class="name">li</span>&gt;</span>（必须用<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>将内容包括起来）   </div><div class="line"> 　　　　 ......</div><div class="line">   <span class="tag">&lt;/<span class="name">ol</span>&gt;</span>　　　　　　　  有序列表</div><div class="line">   </div><div class="line">３）<span class="tag">&lt;<span class="name">ul</span>  <span class="attr">type</span> = <span class="string">""</span>&gt;</span>(序号类型有：disc(默认值,实心圆点)、circle、square)</div><div class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>所写内容<span class="tag">&lt;<span class="name">li</span>&gt;</span></div><div class="line">         .......</div><div class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span>             无序列表</div></pre></td></tr></table></figure><h2 id="页面链接语法"><a href="#页面链接语法" class="headerlink" title="页面链接语法"></a>页面链接语法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"链接地址"</span>&gt;</span>连接标志<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto: 邮件地址"</span>&gt;</span>站长邮箱<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="滚动标签"><a href="#滚动标签" class="headerlink" title="滚动标签"></a>滚动标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">marquee</span>  </span></div><div class="line"><span class="tag">　　　　　　<span class="attr">scrolldelay</span>=<span class="string">滚动延迟时间</span>  </span></div><div class="line"><span class="tag">　　　　　　<span class="attr">direction</span>=<span class="string">up/down/left/right(滚动方向)</span> </span></div><div class="line"><span class="tag">　　　　　　<span class="attr">onmouseover</span>=<span class="string">“this.stop()”(当鼠标指在上面时停止滚动)</span>  　　</span></div><div class="line"><span class="tag">　　　　　　<span class="attr">onmouseout</span>=<span class="string">“this.start()”(当鼠标离开时继续滚动)</span> &gt;</span> </div><div class="line">　　　　　　滚动的文字和图像 </div><div class="line"><span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="表格基本框架"><a href="#表格基本框架" class="headerlink" title="表格基本框架"></a>表格基本框架</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span>  </span></div><div class="line"><span class="tag">      <span class="attr">border</span>=<span class="string">表格的边框的宽度(一般不超过5)</span> </span></div><div class="line"><span class="tag">      <span class="attr">width</span>=<span class="string">表格的宽度</span>  <span class="attr">height</span>=<span class="string">表格的高度</span>  </span></div><div class="line"><span class="tag">      <span class="attr">bordercolor</span>=<span class="string">表格边框线的颜色</span>  <span class="attr">bgcolor</span>=<span class="string">整个表格的背景颜色</span></span></div><div class="line"><span class="tag">      <span class="attr">background</span>=<span class="string">表格的背景图片地址(背景图片)</span> <span class="attr">align</span>=<span class="string">表格对齐方式</span>&gt;</span> </div><div class="line">      <span class="tag">&lt;<span class="name">tr</span>  <span class="attr">bgcolor</span>=<span class="string">行的背景颜色</span>&gt;</span>(行)  </div><div class="line">           <span class="tag">&lt;<span class="name">td</span>  </span></div><div class="line"><span class="tag">              <span class="attr">colspan</span>=<span class="string">跨的列数</span>  <span class="attr">rowspan</span>=<span class="string">跨的行数</span>  <span class="attr">bgcolor</span>=<span class="string">本单元格的背景颜色</span>      </span></div><div class="line"><span class="tag">              <span class="attr">background</span>=<span class="string">本单元格的背景图片地址(背景图片)</span>  </span></div><div class="line"><span class="tag">              <span class="attr">align</span>=<span class="string">单元格中的内容对齐方式(right/left/center/)</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">td</span>&gt;</span>(单元格)  </div><div class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="表单的基本结构"><a href="#表单的基本结构" class="headerlink" title="表单的基本结构"></a>表单的基本结构</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span>  <span class="attr">action</span>=<span class="string">"URL"</span> <span class="attr">name</span>=<span class="string">表单名字</span>  <span class="attr">method</span>=<span class="string">提交数据的方式（post/get）</span>&gt;</span> 具体的内容 <span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="表单中元素"><a href="#表单中元素" class="headerlink" title="表单中元素"></a>表单中元素</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span>元素  </div><div class="line"></div><div class="line">　　　 <span class="tag">&lt;<span class="name">input</span>  <span class="attr">name</span>=<span class="string">“”</span> <span class="attr">type</span>=<span class="string">text</span>  <span class="attr">size</span>=<span class="string">文本框的大小</span>  <span class="attr">maxlenght</span>=<span class="string">限制输入的最大字符</span>&gt;</span>(单行文本框)  </div><div class="line">　　　 <span class="tag">&lt;<span class="name">input</span>  <span class="attr">name</span>=<span class="string">“”</span> <span class="attr">type</span>=<span class="string">password</span>  <span class="attr">size</span>=<span class="string">文本框的大小</span>  <span class="attr">maxlenght</span>=<span class="string">限制输入的最大字符</span>&gt;</span>(单行文本框——设置密码)  </div><div class="line">　　　 <span class="tag">&lt;<span class="name">input</span>  <span class="attr">name</span>=<span class="string">“name”</span> <span class="attr">type</span>=<span class="string">radio</span>  <span class="attr">value</span>=<span class="string">“男”</span>  <span class="attr">checked</span>(默认选定)&gt;</span>(单选按钮——男)(设置单选按钮的时候名字一定要一样)  </div><div class="line">　　　 <span class="tag">&lt;<span class="name">input</span>  <span class="attr">name</span>=<span class="string">“name”</span> <span class="attr">type</span>=<span class="string">radio</span>  <span class="attr">value</span>=<span class="string">“女”</span>&gt;</span>(单选按钮——女) </div><div class="line">　　　 <span class="tag">&lt;<span class="name">input</span>  <span class="attr">name</span>=<span class="string">“”</span> <span class="attr">type</span>=<span class="string">submit</span>  <span class="attr">value</span>=<span class="string">提交</span>&gt;</span>(按钮——提交) </div><div class="line">　　　 <span class="tag">&lt;<span class="name">input</span>  <span class="attr">name</span>=<span class="string">“”</span> <span class="attr">type</span>=<span class="string">reset</span>  <span class="attr">value</span>=<span class="string">重置</span>&gt;</span>(按钮——重置)  </div><div class="line">　　　 <span class="tag">&lt;<span class="name">input</span>  <span class="attr">name</span>=<span class="string">“”</span> <span class="attr">type</span>=<span class="string">checkbox</span>  <span class="attr">value</span>=<span class="string">play(必须有)</span>  <span class="attr">checked</span>&gt;</span>玩游戏(复选框)</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span>下拉列表元素 语法：</div><div class="line">　　　<span class="tag">&lt;<span class="name">select</span>  <span class="attr">name</span>=<span class="string">“”</span>&gt;</span>  </div><div class="line">　　　　　　<span class="tag">&lt;<span class="name">option</span>  <span class="attr">value</span>=<span class="string">“”(必须有)</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">option</span>&gt;</span> </div><div class="line">　　　　　　<span class="tag">&lt;<span class="name">option</span>  <span class="attr">value</span>=<span class="string">“”(必须有)</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">option</span>&gt;</span> </div><div class="line">　　　　　　<span class="tag">&lt;<span class="name">option</span>  <span class="attr">value</span>=<span class="string">“”(必须有)</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">option</span>&gt;</span> </div><div class="line">　　　　　　<span class="tag">&lt;<span class="name">option</span>  <span class="attr">value</span>=<span class="string">“”(必须有)</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">option</span>&gt;</span> </div><div class="line">　　　　　　…… </div><div class="line">　　　<span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span>多行文本框元素  语法：</div><div class="line">　　　<span class="tag">&lt;<span class="name">textarea</span>  <span class="attr">name</span>=<span class="string">“”</span> <span class="attr">cols</span>=<span class="string">“宽度”</span> <span class="attr">rows</span>=<span class="string">“高度”(不要和合并单元格的rowspan和colspan相混淆)</span>&gt;</span>  具体的内容  <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="样式类型"><a href="#样式类型" class="headerlink" title="样式类型"></a>样式类型</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">1）标签选择器  语法：  </div><div class="line">   标签&#123;    </div><div class="line">        属性:属性值; </div><div class="line">       &#125;  </div><div class="line">       <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">”text/css”</span>&gt;</span><span class="undefined">  P&#123;font-size:20px;color:blue&#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>  不需要调用，直接创建标签就能使用   </div><div class="line">2）class选择器  语法：  </div><div class="line">   .类名&#123;   </div><div class="line">        属性:属性值;  </div><div class="line">        &#125;  </div><div class="line">       <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">”text/css”</span>&gt;</span><span class="undefined">  .my&#123;font-size:20px;color:blue&#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>  调用：在需要使用的地方做为属性来调用（class=类名）</div><div class="line">3）ID选择器 语法： </div><div class="line">   #名称&#123;  </div><div class="line">        属性:属性值; &#125;  </div><div class="line">       <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">”text/css”</span>&gt;</span><span class="undefined">  #my&#123;font-size:20px;color:blue&#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>  调用：在需要使用的地方做为属性来调用（ID=名称）</div></pre></td></tr></table></figure><h2 id="常用的样式属性"><a href="#常用的样式属性" class="headerlink" title="常用的样式属性"></a>常用的样式属性</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">1)文本属性  </div><div class="line">　　　font-size:字体大小 </div><div class="line">　　　font-family:字体类型  </div><div class="line">　　　font-style:字体样式（斜体） </div><div class="line">　　　color:字体颜色  </div><div class="line">　　　text-algin:文本的对齐方式（left/right/center） </div><div class="line">2)背景属性  </div><div class="line">　　　background-color:背景颜色  </div><div class="line">　　　background-image:url(“图片地址”)背景图片  </div><div class="line">　　　background-repeat:（repeat/no-repeat/repeat-x/repeat-y）背景图片如何被重复显示 </div><div class="line">3)方框属性 </div><div class="line">　　　(1)边界属性 </div><div class="line">　　　 margin-left:设置对象的左边距 </div><div class="line">　　 　margin-right: 设置对象的右边距 </div><div class="line">　　 　margin-top: 设置对象的上边距 </div><div class="line">　　 　margin-bottom: 设置对象的下边距 </div><div class="line">　　 (2)填充属性  </div><div class="line">　　　 padding-left:设置内容与左边框之间的距离 </div><div class="line">　　 　padding-right: 设置内容与右边框之间的距离 </div><div class="line">　　 　padding-top: 设置内容与上边框之间的距离 </div><div class="line">　　 　padding-bottom: 设置内容与下边框之间的距离 </div><div class="line">　　 (3)边框属性 </div><div class="line">　　  　border-style:(soild细边框/dashed/虚边框)边框样式 </div><div class="line">　　 　 border-width:边框宽度 </div><div class="line">　　 　 border-color:边框颜色 </div><div class="line">4)超链接样式 </div><div class="line">　　　 A:link&#123;&#125;未被访问的链接样式 </div><div class="line">　　　 A:visited&#123;&#125;被访问过的链接样式  </div><div class="line">　　　 A:hover&#123;&#125;鼠标悬浮在链接上时的样式  </div><div class="line">　　　 A:active&#123;&#125;鼠标下在按下时链接文字的样式</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;&lt;h2 id=&quot;HTML文档结构&quot;&gt;&lt;a href=&quot;#HTML文档结构&quot; class=&quot;headerlink&quot; title=&quot;HTML文档结构&quot;&gt;&lt;/a&gt;HTML文档结构&lt;/h2&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;－－&lt;span class=&quot;meta&quot;&gt;&amp;lt;!DOCTYPE&amp;gt;&lt;/span&gt; 标签没有结束标签！&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;lang&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;en&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;（头部部分）&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;charset&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;显示在浏览器标题栏中的标题&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;（主体部分） &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;（页面内容）&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;bgcolor = 背景颜色　background = 背景图片路经&lt;/p&gt;
    
    </summary>
    
      <category term="工具资源" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E8%B5%84%E6%BA%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo-NexT搭建个人博客（一）</title>
    <link href="http://yoursite.com/2017/10/11/hexo-next-one/"/>
    <id>http://yoursite.com/2017/10/11/hexo-next-one/</id>
    <published>2017-10-11T05:25:24.000Z</published>
    <updated>2017-12-17T08:57:24.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo</a> 是一个快速、简洁且高效的静态站点生成框架，它基于 <a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a> 。 它有以下特点：</p><ul><li><i class="fa fa-bolt">&lt;/i&gt;<h6 style="display: inline;">　超快速度</h6><br><i>Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</i></i></li><li><i class="fa fa-pencil">&lt;/i&gt;<h6 style="display: inline;">　支持Markdown</h6><br><i>Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</i></i></li><li><i class="fa fa-cloud-upload">&lt;/i&gt;<h6 style="display: inline;">　一键部署</h6><br><i>只需一条指令即可部署到Github Pages，或其他网站</i></i></li><li><i class="fa fa-cog">&lt;/i&gt;<h6 style="display: inline;">　丰富的插件</h6><br><i>Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</i></i></li></ul><p>通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 <a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="external">标签插件</a> 来快速的插入特定形式的内容。</p><p>基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的<a href="https://hexo.io/themes/" target="_blank" rel="external">主题</a>。<br><a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT</a> 因其 <span id="yu-1">精于心，简于形</span> 的风格，一直被广大用户所喜爱。</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装 Hexo 只需几分钟时间，若你在安装过程中遇到问题或无法找到解决方式，请<a href="https://neveryu.github.io/guestbook/" target="_blank" rel="external">提交问题</a>，我会尽力解决你的问题。</p><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序:</p><blockquote><p><a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a><br><a href="http://git-scm.com/" target="_blank" rel="external">Git</a></p></blockquote><p>如果您的电脑中已经安装上述必备程序，那么恭喜你！接下来只需要使用 npm 即可完成 Hexo 的安装。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure></p><p>如果你的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。</p><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><ul><li>Windows：下载安装 git 。<a id="download" href="https://git-scm.com/download/win" target="_blank" rel="external"><i class="fa fa-download"></i><span> Download Now</span></a></li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="external">Homebrew</a>，<a href="http://www.macports.org/" target="_blank" rel="external">MacPorts</a> 或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="external">安装程序</a> 安装</li><li>Linux（Ubuntu，Debian）：<code>sudo apt-get install git-core</code></li><li>Linux（Fedora，Red Hat，CentOS）：<code>sudo yum install git-core</code></li></ul><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a>。（nvm：Node Version Manager）<br>windows 下使用 nvm 请看这里： <a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="external">nvm-windows</a> ，首先需要下载安装 nvm 。<a id="download" href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="external"><i class="fa fa-download"></i><span> Download Now</span></a><br>windows下安装完nvm以后，我们可以打开命令行中执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ nvm</div><div class="line">$ nvm install latest</div></pre></td></tr></table></figure></p><p>执行完以后，重启命令行，执行命令 <code>node -v</code> ，如果出现版本号，那么 <code>Node.js</code> 就安装成功了。</p><p id="div-border-left-red">如果没有安装成功，那可能就是墙的原因。建议下载 `Node.js` 直接安装。<a id="download" href="https://nodejs.org/en/download/" target="_blank" rel="external"><i class="fa fa-download"></i><span> Download Now</span></a> </p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>有了 Node.js ，我们可以使用 npm 安装 Hexo。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure></p><p>安装 Hexo 完成后，我们首先需要为我们的项目创建一个<span id="inline-green">指定文件夹</span>（例如我在 D 盘目录下创建了一个文件夹 blog 。<code>D:\blog</code> ），在指定文件夹中执行下列命令， Hexo 将会在指定文件夹中新建所需要的文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init</div></pre></td></tr></table></figure></p><p>等待安装，安装完成后，<span id="inline-green">指定文件夹</span> 的目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── _config.yml</div><div class="line">├── package.json</div><div class="line">├── scaffolds</div><div class="line">├── source</div><div class="line">|   ├── _drafts</div><div class="line">|   └── _posts</div><div class="line">└──</div></pre></td></tr></table></figure></p><p>我们继续执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo g</div><div class="line">$ hexo s --debug</div></pre></td></tr></table></figure></p><p>Hexo 将 source 文件夹中除 <em>posts 文件夹之外，开头命名为 </em>(下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件夹会被拷贝过去。<br>这个时候，我们在浏览器中访问 <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> ，就可以看到基于 Hexo 的默认主题的原型：<br><img src="http://p1.bqimg.com/567571/27324b740c9e91e2.png" alt="hexo-next-one-1"></p><h2 id="安装-NexT-主题"><a href="#安装-NexT-主题" class="headerlink" title="安装 NexT 主题"></a>安装 NexT 主题</h2><h3 id="下载-NexT-主题"><a href="#下载-NexT-主题" class="headerlink" title="下载 NexT 主题"></a>下载 NexT 主题</h3><p>依旧是在当前目录下，使用 Git checkout 代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure></p><p>等待下载完成。</p><p id="div-border-left-yellow">在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。  我们约定，将前者称为 <span id="inline-blue">站点配置文件</span>，后者称为 <span id="inline-purple">主题配置文件</span></p><h3 id="启用-NexT-主题"><a href="#启用-NexT-主题" class="headerlink" title="启用 NexT 主题"></a>启用 NexT 主题</h3><p>打开 <span id="inline-blue">站点配置文件</span> ，找到 theme 字段，并将其值更改为 next 。<br>到此， NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存。</p><h3 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h3><p>首先启动 Hexo 本地站点，并开启调试模式（即加上 <code>--debug</code>），整个命令是 <code>hexo s --debug</code>。在服务启动的过程，注意观察命令行输出是否有任何异常信息。当命令行输出中提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</div></pre></td></tr></table></figure><p>此时即可使用浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> ，检查站点是否正确运行。</p><p id="div-border-left-green">当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse</p>![hexo-next-one-1](http://p1.bqimg.com/567571/8333728b5eaab526.png)现在，我们已经成功安装并启用了 NexT 主题。<p id="div-border-top-blue">关于更多基本操作和基础知识，请查阅 [Hexo](https://hexo.io/zh-cn/) 与 [NexT](http://theme-next.iissnan.com/) 官方文档.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="本地调试步骤"><a href="#本地调试步骤" class="headerlink" title="本地调试步骤"></a>本地调试步骤</h2><p>三部曲：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div><div class="line">$ hexo g</div><div class="line">$ hexo s --debug</div></pre></td></tr></table></figure></p><p>这种带 debug 的运行，如果出现错误，可以在命令行中看到错误提示信息。</p><h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h2><p>三部曲：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div><div class="line">$ hexo g</div><div class="line">$ hexo d</div></pre></td></tr></table></figure></p><p>当然在部署之前，需要先配置好配置文件中的 deploy。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"postName"</span>  <span class="comment">#新建文章</span></div><div class="line">$ hexo new page <span class="string">"pageName"</span> <span class="comment"># 新建页面</span></div><div class="line">$ hexo generate <span class="comment"># 生成静态页面至public目录</span></div><div class="line">$ hexo server <span class="comment"># 开启预览访问端口(默认端口4000，'ctrl+c'关闭server)</span></div><div class="line">$ hexo deploy <span class="comment"># 项目部署</span></div><div class="line">$ hexo <span class="built_in">help</span> <span class="comment"># 查看帮助</span></div><div class="line">$ hexo version <span class="comment"># 查看Hexo的版本</span></div></pre></td></tr></table></figure><h2 id="简写命令"><a href="#简写命令" class="headerlink" title="简写命令"></a>简写命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ hexo new == hexo n</div><div class="line">$ hexo generate == hexo g</div><div class="line">$ hexo server == hexo s</div><div class="line">$ hexo deploy == hexo d</div></pre></td></tr></table></figure><h2 id="常见问题1"><a href="#常见问题1" class="headerlink" title="常见问题1"></a>常见问题1</h2><p>在 hexo 的配置和设置文件中，在冒号后面没留空格会导致出问题：<br>错误的设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">author:Neveryu</div><div class="line">email:react.dong.yu@gmail.com</div><div class="line">language:zh-CN</div></pre></td></tr></table></figure></p><p>正确的设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">author: Neveryu</div><div class="line">email: react.dong.yu@gmail.com</div><div class="line">language: zh-CN</div></pre></td></tr></table></figure></p><h2 id="常见问题2"><a href="#常见问题2" class="headerlink" title="常见问题2"></a>常见问题2</h2><p>关于 Git 提交中用户名和 Email 的设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;Your name&quot;</div><div class="line">git config --global user.email &quot;Your email&quot;</div></pre></td></tr></table></figure></p><h2 id="常见问题3"><a href="#常见问题3" class="headerlink" title="常见问题3"></a>常见问题3</h2><p>Hexo 中的图标使用的是 <a href="http://fontawesome.io/" target="_blank" rel="external">Font Awesome</a> ，所以，我们的博客已经自带了 Font Awesome 中的所有图标，基本可以满足我们的所有需求，我们可以去 Font Awesome 中查找我们想要使用的图标。<br><i class="fa fa-github">&lt;/i&gt; `<i class="fa fa-github"></i><code>&lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt;</code><i class="fa fa-github fa-lg">&lt;/i&gt;`<br><i class="fa fa-github fa-2x"></i> <code>&lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt;</code></i></i></p><p></p><h5 style="color:#f63;"><i>最后要说的是：</i></h5><p></p><p id="div-border-top-green"><i>[博客源码](https://github.com/Neveryu/Neveryu.github.io) ， 欢迎 star</i></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt; 是一个快速、简洁且高效的静态站点生成框架，它基于 &lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node.js&lt;/a&gt; 。 它有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;i class=&quot;fa fa-bolt&quot;&gt;&amp;lt;/i&amp;gt;&lt;h6 style=&quot;display: inline;&quot;&gt;　超快速度&lt;/h6&gt;&lt;br&gt;&lt;i&gt;Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。&lt;/i&gt;&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=&quot;fa fa-pencil&quot;&gt;&amp;lt;/i&amp;gt;&lt;h6 style=&quot;display: inline;&quot;&gt;　支持Markdown&lt;/h6&gt;&lt;br&gt;&lt;i&gt;Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。&lt;/i&gt;&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=&quot;fa fa-cloud-upload&quot;&gt;&amp;lt;/i&amp;gt;&lt;h6 style=&quot;display: inline;&quot;&gt;　一键部署&lt;/h6&gt;&lt;br&gt;&lt;i&gt;只需一条指令即可部署到Github Pages，或其他网站&lt;/i&gt;&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=&quot;fa fa-cog&quot;&gt;&amp;lt;/i&amp;gt;&lt;h6 style=&quot;display: inline;&quot;&gt;　丰富的插件&lt;/h6&gt;&lt;br&gt;&lt;i&gt;Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。&lt;/i&gt;&lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 &lt;a href=&quot;https://hexo.io/zh-cn/docs/tag-plugins.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;标签插件&lt;/a&gt; 来快速的插入特定形式的内容。&lt;/p&gt;
&lt;p&gt;基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的&lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;主题&lt;/a&gt;。&lt;br&gt;&lt;a href=&quot;http://theme-next.iissnan.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NexT&lt;/a&gt; 因其 &lt;span id=&quot;yu-1&quot;&gt;精于心，简于形&lt;/span&gt; 的风格，一直被广大用户所喜爱。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Next" scheme="http://yoursite.com/tags/Next/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://yoursite.com/2017/09/20/hello-world/"/>
    <id>http://yoursite.com/2017/09/20/hello-world/</id>
    <published>2017-09-20T07:23:54.000Z</published>
    <updated>2017-12-18T14:00:33.683Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to sysuNie! It is my first try to share the intereseting things to all of you . If you get any problems while looking my blog,  you can ask me on <a href="https://github.com/sysuNie" target="_blank" rel="external">GitHub</a>.</p><h2 id="Coding-Change-World"><a href="#Coding-Change-World" class="headerlink" title="Coding Change World"></a>Coding Change World</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">import numpy as np</div><div class="line">import matplotlib.pyplot as plt</div><div class="line">x = np.linspace(-8 , 8, 1024)</div><div class="line">y1 = 0.618*np.abs(x) - 0.8* np.sqrt(64-x**2)</div><div class="line">y2 = 0.618*np.abs(x) + 0.8* np.sqrt(64-x**2) </div><div class="line">plt.plot(x, y1, color = <span class="string">'r'</span>)</div><div class="line">plt.plot(x, y2, color = <span class="string">'r'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="/home/miacher/Documents/love.jpg" alt=""> </p>]]></content>
    
    <summary type="html">
    
      welcome to my blog
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔，开博" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94%EF%BC%8C%E5%BC%80%E5%8D%9A/"/>
    
  </entry>
  
</feed>
